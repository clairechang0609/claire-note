{"pages":[{"title":"404","text":"找不到此頁面 返回首頁 .navbar, .article-meta.columns.is-variable.is-1.is-multiline.is-mobile.is-size-7-mobile, .footer { display: none; } .container { position: fixed; left: 50%; top: 50%; transform: translate(-50%, -50%); text-align: center; } h1.is-size-3 { font-size: 3rem !important; color: rgb(27, 102, 85); } .headerlink { display: none; } h3:hover::before { display: none; } .content p:not(:last-child) { margin-bottom: 2rem; } p a { padding: 0.35rem 1rem; background-color: rgb(30, 160, 142); color: white; border-radius: 20px; } p a:hover { color: white; }","link":"/404.html"},{"title":"I'm Claire Chang","text":"當了 6 年的平面設計師，在朋友的推薦下踏入前端領域，發現可以做動態的網站相當有趣， 於是在 2020 年 10 月成功轉職為前端工程師，目前持續學習耕耘中。 一直以來從網路大神寫的文章獲益良多，決定把自己學習碰到的坑與過程記錄下來， 除了讓自己複習一遍，也希望能給予碰到相同問題的人一些幫助。 有任何想跟我交流互動的內容，歡迎留言給我喲！ https://www.behance.net/claire0609e29c https://github.com/clairechang0609","link":"/about/index.html"}],"posts":[{"title":"CSS 製作固定比例寬高區塊（Aspect Ratio / Height Based on Width）","text":"在開發響應式網站（Responsive Web Design）常會需要製作等比例寬高圖片，不管螢幕尺寸如何縮放，圖片都能保持在固定比例，做法蠻多，以下列出其中兩種做法： aspect-ratioChrome 88（2021） 開始支援的屬性，設置方式也很簡單，直接輸入寬高比就可以了 aspect-ratio: width / height; 缺點：aspect-ratio 屬性瀏覽器支援度較低，可以參考 can I use padding-bottom如果在意瀏覽器支援度，可以使用 padding-bottom 建立外層容器 寬高比 padding-bottom 代入值 16:9 56.25% 4:3 75% 5:4 80% padding-bottom: 56.25%; 通常會搭配 position 定位使用，如下： &lt;div class=\"image-wrap\"&gt; &lt;p&gt;some description&lt;/p&gt;&lt;/div&gt; .image-wrap { position: relative; width: 100%; padding-bottom: 56.25%;}p { position: absolute; width: 100%;} 範例程式碼： See the Pen CSS Aspect Ratio / Height Based on Width by Claire Chang (@claire-chang-the-bashful) on CodePen. 參考文章： https://stackoverflow.com/questions/1495407/maintain-the-aspect-ratio-of-a-div-with-csshttps://developer.mozilla.org/en-US/docs/Web/CSS/aspect-ratio","link":"/2023/02/03/css/css-aspect-ratio/"},{"title":"CSS Grid Layout Module 格線佈局 (1) 完整介紹與範例","text":"CSS Grid 佈局系統能夠幫助我們輕鬆控制網格中元素位置和大小，跟 Flex 比較： Flex：一維佈局系統，主要用於單行或是單列的對齊跟排列 Grid：二維網格系統，提供更豐富靈活的佈局控制，同時操控「欄（column）」跟「列（row）」，適合用於複雜度高的網頁版型 常用屬性外層容器 display：定義容器類型（grid / inline-grid / subgrid） grid-template-columns：定義網格欄的大小和數量 grid-template-rows：定義網格列的大小和數量 grid-gap / grid-column-gap / grid-row-gap：設定網格間的間距 grid-template-areas：定義網格空間位置，由單個或數個字串組成，搭配 grid-area 使用 justify-items / align-items / place-items：定義所有元素的對齊方式，同 flex 用法 內層元素 grid-column / grid-column-start / grid-column-end：控制元素在網格中所佔欄空間位置 grid-row / grid-row-start / grid-row-end：控制元素在網格中所佔列空間位置 grid-area：定義元素空間名稱，搭配 grid-template-areas 使用 justify-self / align-self / place-self：定義單一元素的對齊方式，同 flex 用法 元素自動佈局 grid-auto-columns：定義預設欄的大小 grid-auto-rows：定義預設列的大小 grid-auto-flow：控制自動佈局的方向和順序 grid-template-columns / grid-template-rows / grid-column / grid-row外層容器 &lt;div class=\"container\"&gt; ... &lt;/div&gt; grid-template-columns 與 grid-template-rows 可以指定線段名稱（用 [] 表示），如果不指定，預設會從 1 開始編號，如果輸入 -1，則會從最後一條線開始算起 .container { display: grid; grid-template-columns: 100px 150px 150px auto; grid-template-rows: [start] 75px [line-2] 150px [line-3] 25% [end]; grid-gap: 5px;} 一條線段可以給定多個名稱 .container { grid-template-rows: [start line-1] 75px [line-2] 150px [line-3] 25% [end line-4];} 如果有連續重複寬 / 高，可以使用 repeat(count, value) 簡化 .container { grid-template-columns: 100px repeat(2, 150px) auto;} 搭配 minmax(min-value, max-value) 函式，設定範圍最大與最小值，達成自適應空間效果 .container { grid-template-columns: repeat(2, minnax(300px, 50%));} 除了上述範例的單位，也能運用 fr（fraction）單位來分配空間，fr 單位用於將可用空間分為相對比例，能夠自適應容器變化。 以下為例：假設目前容器寬 500px，扣掉 100px，容器內可用空間為 400px，共配置了 4fr，因此 1fr 可以分到 100px .container { grid-template-columns: 1fr 2fr 100px 1fr;} 內層元素 &lt;div class=\"container\"&gt; &lt;div class=\"item-a\"&gt;&lt;/div&gt; &lt;div class=\"item-b\"&gt;&lt;/div&gt; &lt;div class=\"item-c\"&gt;&lt;/div&gt; &lt;div class=\"item-d\"&gt;&lt;/div&gt;&lt;/div&gt; grid-column / grid-row 可以帶入以下值： line：線段編號 span ：元素佔欄位數 span ：元素所在格線名稱 auto：自動 .item-a { grid-column-start: 1; grid-column-end: 3; grid-row-start: start; grid-row-end: line-2;}.item-b { grid-column: 1 / 2; // 合併 grid-column-start &amp; grid-column-end grid-row: line-2 / line-3; // 合併 grid-row-start &amp; grid-row-end}.item-c { grid-column: 2 / span 3; grid-row: line-2 / span 1;}.item-d { grid-column: 1 / -1; grid-row: line-3;} grid-template-areas / grid-areas外層容器＋內層元素 .container { display: grid; grid-template-columns: 100px 150px 150px auto; grid-template-rows: [start] 75px [line-2] 150px [line-3] 25% [end]; grid-gap: 5px; grid-template-area: \"header header . .\" \"sidebar content content content\" \"footer footer footer footer\";}.item-a { grid-area: header;}.item-b { grid-area: sidebar;}.item-c { grid-area: content;}.item-d { grid-area: footer;} justify-items / align-items / justify-self / align-self用於控制內層元素在容器中的對齊方式，與 flex 用法相同，沒有定義時預設為 stretch （填滿容器） 元素若未定義位置，預設會是由左至右，由上至下順排，一個元素佔一個網格位置 外層容器統一定義 align-items justify-items place-items：合併 align-items 與 justify-items .container { justify-items: start; align-items: stretch;} 等同於 .container { place-items: stretch start;} 內層元素個別定義 align-self justify-self place-self：合併 align-self 與 justify-self .item-a { justify-self: start; align-self: start;}.item-b { justify-self: center; align-self: stretch;}.item-c { justify-self: stretch; align-self: center;}.item-d { place-self: end stretch; // 合併寫法} grid-auto-columns / grid-auto-rows / grid-auto-flows當透過內層元素數量超過預先定義的網格數量，或是元素超出網格外，grid-auto-columns / grid-auto-rows 可以協助我們自動定義欄或列的尺寸，範例說明： &lt;div class=\"container\"&gt; &lt;div class=\"item\"&gt;1&lt;/div&gt; &lt;div class=\"item\"&gt;2&lt;/div&gt; ... &lt;div class=\"item\"&gt;16&lt;/div&gt;&lt;/div&gt; .container { grid-template-columns: repeat(4, 100px); grid-template-rows: repeat(2, 50px);} 未定義前，畫面呈現如下： 加入 grid-auto-columns 與 grid-auto-rows .container { grid-template-columns: repeat(4, 100px); grid-template-rows: repeat(2, 50px); grid-auto-columns: 100px; grid-auto-rows: 50px;} 畫面呈現如下： grid-auto-flow 用來自動定義網格內元素的排列方式，預設值為 row，以上面範例作為延伸 .container { grid-auto-flow: column;} 畫面呈現如下： 完整範例程式碼 See the Pen CSS Grid Layout Guide by Claire Chang (@claire-chang-the-bashful) on CodePen. 參考文章： https://css-tricks.com/snippets/css/complete-guide-grid/https://www.casper.tw/css/2017/03/22/css-grid-layout/https://ithelp.ithome.com.tw/articles/10268087","link":"/2023/05/19/css/css-grid-layout/"},{"title":"CSS Grid Layout Module 格線佈局 (2) Masonry 瀑布流應用","text":"上一篇文章 介紹了 CSS Grid，接下來運用網格系統來實作瀑布流版面。 瀑布流（Waterfall Flow）是一種網頁佈局的設計方式。瀑布流的特點是將內容項目垂直排列，並根據可用的空間進行自適應調整，形成像瀑布一樣的流動效果 。 瀑布流佈局中，每個元素的寬度通常是固定的，但高度會根據內容的大小變化。這樣可以使元素在垂直方向上緊密堆疊，填滿可用空間。當一列的空間被填滿後，下一個元素會自動排列到空間較少的列中，達到均衡的排版。 透過 CSS Grid 或 Flexbox 可以達成瀑布流佈局的效果，本篇會使用 CSS Grid 搭配 JavaScript 來完成實作。 本篇作法無法達成轉場效果，如果想讓畫面轉換更加流暢，可以參考 這篇文章（masonry-layout 套件運用） 概念解析利用 CSS Grid 格線系統來達成瀑布流的效果： grid-auto-rows 設定列高 grid-gap 建立網格間距 利用 Javascript 取得元素的高度，並計算 grid-row-end 屬性 利用網格系統，每個元素會去找到空間使用最少的列，並排列在其後 格線的結構如下圖： HTML 外層容器 .container 內層元素 .item &lt;ul class=\"container\"&gt; &lt;li class=\"item\"&gt; &lt;div class=\"content\"&gt; &lt;h3&gt;1.&lt;/h3&gt; Lorem ipsum dolor sit amet consectetur adipisicing elit. Ipsam voluptatibus hic laborum ea maiores, harum nobis. Placeat numquam ad laboriosam esse est porro, cum deserunt velit libero beatae quam necessitatibus. Iste sapiente commodi est labore amet quae rerum magni! Alias eum molestias sint nostrum optio ipsam quia delectus sunt. Rerum &lt;/div&gt; &lt;/li&gt; &lt;li class=\"item\"&gt; &lt;div class=\"content\"&gt; &lt;h3&gt;2.&lt;/h3&gt; Lorem ipsum dolor sit amet consectetur, adipisicing elit. Voluptatibus dolore natus ea &lt;/div&gt; &lt;/li&gt; ... &lt;li class=\"item\"&gt; &lt;div class=\"content\"&gt; &lt;h3&gt;16.&lt;/h3&gt; Lorem ipsum dolor sit amet consectetur, adipisicing elit. Sequi itaque veniam at labore consequuntur dicta adipisci ut laudantium deserunt &lt;/div&gt; &lt;/li&gt;&lt;/ul&gt; CSS外層容器 auto-fill：搭配 repeat(count, value) 函式使用，根據可用空間填滿欄或列 minmax(min-value, max-value)：指定範圍最小與最大值，自動調整欄或列的尺寸 .container { display: grid; grid-gap: 1rem; grid-template-columns: repeat(auto-fill, minmax(250px, 1fr)); grid-auto-rows: 1rem;} 內層元素 grid-row-end：透過 Javascript 動態計算 Javascript rowHeight：取得 grid-auto-rows 值 rowGap：取得 grid-row-gap 值 透過 getBoundingClientRect().height 取得元素的高度 利用以上值計算元素 grid-row-end: span &lt;number&gt;： 表示所佔列數，根據起始位置往後推算 監聽螢幕 resize 事件，重新計算元素高度 getBoundingClientRect().height vs offsetHeight：getBoundingClientRect().height 取得的是相對於螢幕視窗的可視高（渲染後的結果），而 offsetHeight 取得的是元素完整高，getBoundingClientRect().height 會受到 transform 影響，例如元素設定高度 100px 以及 transform: scale(0.5);，getBoundingClientRect().height 得到 50，而 offsetHeight 得到的是 100 const grid = document.querySelector(\".container\");const style = window.getComputedStyle(grid);const allItems = document.querySelectorAll(\".item\");const resizeGridItem = (item) =&gt; { rowHeight = parseInt(style.getPropertyValue(\"grid-auto-rows\")); rowGap = parseInt(style.getPropertyValue(\"grid-row-gap\")); rowSpan = Math.ceil((item.querySelector(\".content\").getBoundingClientRect().height + rowGap) / (rowHeight + rowGap)); item.style.gridRowEnd = `span ${rowSpan}`;}const resizeAllGridItems = () =&gt; { allItems.forEach(ele =&gt; { resizeGridItem(ele); });}window.onload = resizeAllGridItems();window.addEventListener(\"resize\", resizeAllGridItems); 範例程式碼 See the Pen CSS Grid Layout Masonry by Claire Chang (@claire-chang-the-bashful) on CodePen. 參考文章： https://css-tricks.com/piecing-together-approaches-for-a-css-masonry-layout/https://developer.mozilla.org/en-US/docs/Web/CSS/CSS_Grid_Layout/Masonry_Layouthttps://medium.com/@andybarefoot/a-masonry-style-layout-using-css-grid-8c663d355ebb","link":"/2023/05/23/css/css-grid-masonry/"},{"title":"CSS Grid Layout Module 格線佈局 (3) Responsive Table 響應式表格應用","text":"在響應式網頁設計中，常需要處理不同裝置間版面的切換，以表格為例：在桌機上用表格呈現內容，而在行動裝置上使用卡片式版面，這樣的設計優化能夠提升使用者在不同裝置上的瀏覽體驗。 為了達成這種優化，有以下幾種做法： 製作兩個版面，利用斷點來進行版面切換 製作一個共用版面，搭配 CSS Grid Layout 進行設計，在手機版時調整 &lt;table&gt; 的屬性，達成卡片的視覺效果 本篇介紹第二個做法，這麼做可以降低程式碼的複雜度，提升程式碼可重用性，專案維護性也較高。 CSS Grid 相關知識，可以參考 這篇文章 概念解析使用 &lt;table&gt; 建立表格，在行動裝置斷點，將 &lt;tr&gt; 設定為 display: grid，利用格線系統達成卡片式版面 HTML&lt;table&gt; &lt;thead&gt; &lt;tr&gt; &lt;th scope=\"col\"&gt;#&lt;/th&gt; &lt;th scope=\"col\"&gt;Product&lt;/th&gt; &lt;th scope=\"col\"&gt;Ingredient&lt;/th&gt; &lt;th scope=\"col\"&gt;Price&lt;/th&gt; &lt;th scope=\"col\"&gt;&lt;/th&gt; &lt;/tr&gt; &lt;/thead&gt; &lt;tbody&gt; &lt;tr&gt; &lt;td class=\"index\"&gt;1&lt;/td&gt; &lt;td class=\"product\"&gt;Apple Juice&lt;/td&gt; &lt;td class=\"ingredient\"&gt;Apple, Sugar, Water&lt;/td&gt; &lt;td class=\"price\"&gt;$ 100&lt;/td&gt; &lt;td class=\"add-btn\"&gt; &lt;button type=\"button\"&gt;Add&lt;/button&gt; &lt;/td&gt; &lt;/tr&gt; ... &lt;/tbody&gt;&lt;/table&gt; CSS 設定斷點為 W768（Ipad） 當螢幕視窗小於 768px，tbody &gt; tr 設定為 display: grid，td 欄位利用格線系統排版 table { width: 1000px; max-width: 100%; margin: 0 auto; white-space: nowrap; border-spacing: 5px;}@media screen and (max-width: 768px) { thead { display: none; } tbody &gt; tr { display: grid; grid-gap: 0.5rem; grid-template-columns: repeat(2, 1fr); grid-template-rows: repeat(3, auto); } .index { display: none; } .product { justify-self: start; margin-bottom: 0.5rem; } .ingredient { grid-column: 1; grid-row: 2; justify-self: start; } .price { grid-column: 1; grid-row: 3; justify-self: start; align-self: center; } .add-btn { grid-column: 2; grid-row: 3; justify-self: end; align-self: center; }} 範例程式碼 See the Pen CSS Grid Responsive Table by Claire Chang (@claire-chang-the-bashful) on CodePen. 參考資源： https://adamlynch.com/flexible-data-tables-with-css-grid/https://codepen.io/gilli/pen/QVaWGR","link":"/2023/05/24/css/css-grid-responsive-table/"},{"title":"CSS 圖片自適應容器（object-fit / background-image）","text":"網頁切版中很常遇到一個問題：當圖片大小不一致時，如何讓圖片在不變形的情況下自適應容器大小？圖片變形不僅會影響網頁的美感和視覺效果，甚至影響使用者閱讀。本篇介紹兩個方法來解決這個問題 background-image背景圖片是很簡單支援度高的寫法，使用 background-image 取代 &lt;img&gt; 圖片標籤，並使用 background 相關屬性來調整圖片 &lt;div class=\"background-image-container\"&gt;&lt;/div&gt; .background-image-container { width: 300px; height: 300px; background-image: url(\"https://i.imgur.com/W7xqcWS.jpg\"); background-size: cover; background-position: center;} 使用 background-size: cover 讓圖片覆蓋整個容器，並保留圖片比例，並搭配 background-position: center 確保圖片置中，圖片呈現與裁切如下： object-fit某些情境我們會需要使用 &lt;img&gt; 圖片標籤，像是圖片需能被搜尋引擎爬蟲讀取（需要有 alt 屬性），這時就可以透過 object-fit 來達成 object-fit 選項 fill：預設效果，元素會被拉伸填滿外層容器，長寬比會被扭曲 contain：元素的長寬比不變，最大邊會填滿容器 cover：元素的長寬比不變，最小邊會填滿容器，也就是元素可能會被裁切 none：元素維持本身的大小和長寬比，不會被調整 scale-down：元素維持本身的大小和長寬比，但如果大於容器，會被縮小適應容器 &lt;div class=\"object-fit-container\"&gt; &lt;img src=\"https://i.imgur.com/W7xqcWS.jpg\" alt=\"landscape\" /&gt;&lt;/div&gt; .object-fit-container { width: 300px; height: 300px; img { object-fit: cover; width: 100%; height: 100%; }} width 跟 height 用來設定圖片需要被填滿的範圍，另外也可以透過 object-position 來調整圖片的位置（預設是置中） 範例程式碼 See the Pen css image fit container by Claire Chang (@claire-chang-the-bashful) on CodePen. 參考文章： https://ithelp.ithome.com.tw/articles/10250499https://www.casper.tw/development/2020/10/11/img-cover/","link":"/2023/05/10/css/css-object-fit/"},{"title":"Javascript 常用陣列方法","text":"陣列方法可以幫助開發者更有效率的進行資料處理，前端框架 Vue 跟 React 都採取視覺單位關注點分離，框架協助處理畫面部分，而資料面的處理就要靠開發者的功力。 因自己在工作上大量運用到相關技巧，因此將內容筆記起來，方便未來需要時複習使用。 範例使用資料const fruits = [ { name: 'apple', price: 45 }, { name: 'strawberry', price: 100 }, { name: 'banana', price: 30 }, { name: 'papaya', price: 60 }, { name: 'watermelon', price: 75 }] 迴圈處理方法 forEach()不會回傳值（不需要 return），跟 for 迴圈功能相似，但操作上更簡潔，只會依序執行每個項目 參數說明： item：陣列元素，在此為一個物件 index：索引值 array：整個陣列 fruits.forEach((item, index, array) =&gt; { item.price += 10; // 價格調漲 10})console.log(fruits);// output: [// { \"name\": \"apple\", \"price\": 55 },// { \"name\": \"strawberry\", \"price\": 110 },// { \"name\": \"banana\", \"price\": 40 },// { \"name\": \"papaya\", \"price\": 70 },// { \"name\": \"watermelon\", \"price\": 85 }// ] 以下為錯誤使用： const priceIncreasedFruits = fruits.forEach((item, index, array) =&gt; { return item.price += 10;})console.log(priceIncreasedFruits); // output: undefined map()需要回傳值，用於對陣列中的項目進行調整，透過回傳值組合成新的陣列 const priceIncreasedFruits = fruits.map((item, index, array) =&gt; { return { ...item, price: item.price + 10 // 價格調漲 10 }})console.log(priceIncreasedFruits);// output: [// { \"name\": \"apple\", \"price\": 55 },// { \"name\": \"strawberry\", \"price\": 110 },// { \"name\": \"banana\", \"price\": 40 },// { \"name\": \"papaya\", \"price\": 70 },// { \"name\": \"watermelon\", \"price\": 85 }// ] filter()篩選符合條件的項目（條件判斷為 true）並回傳新的陣列 const filteredFruits = fruits.filter((item, index, array) =&gt; { return item.price &gt; 50; // 價格大於 50})console.log(filteredFruits);// output: [// { \"name\": \"strawberry\", \"price\": 100 },// { \"name\": \"papaya\", \"price\": 60 },// { \"name\": \"watermelon\", \"price\": 75 }// ] find()跟 filter() 類似，差別在於找到符合條件的一筆資料後就會停止，並返回該筆資料，如果沒有符合條件的資料，會回傳 undefined const findFruit = fruits.find((item, index, array) =&gt; { return item.price &gt; 50; // 價格大於 50})console.log(findFruit); // output: { \"name\": \"strawberry\", \"price\": 100 } findIndex()篩選方式同 find()，找到符合條件的一筆資料後就會停止，並返回該筆資料索引值，如果沒有符合條件的資料，會回傳 -1 const findFruitIndex = fruits.findIndex((item, index, array) =&gt; { return item.price &gt; 50; // 價格大於 50})console.log(findFruitIndex); // output: 1 every()用以檢查陣列內「所有項目」是否符合條件，並回傳 Boolean 值 const checkPriceValidity = fruits.every((item, index, array) =&gt; { return item.price &gt; 50; // 價格大於 50})console.log(checkPriceValidity); // output: falseconst checkPriceValidity2 = fruits.every((item, index, array) =&gt; { return item.price &lt;= 100; // 價格小於等於 100})console.log(checkPriceValidity2); // output: true some()與 every() 相似，差別在於條件的判斷，some() 用以檢查陣列內是否有「任一項目」符合條件，並回傳 Boolean 值 const checkPriceValidity = fruits.some((item, index, array) =&gt; { return item.price &gt; 50; // 價格大於 50})console.log(checkPriceValidity); // output: true sort()語法：array.sort(compareFunction) sort() 內帶入比較函式 compareFunction(a, b)，各項目依照邏輯來排序，並返回調整排序後的陣列，如果沒有定義條件，則按照預設的字串排序規則進行排序 a 和 b 依序為陣列裡的項目 如果 compareFunction(a, b) 返回負數，則 a 會被排在 b 前面 如果 compareFunction(a, b) 返回正數，則 b 會被排在 a 前面 如果 compareFunction(a, b) 返回 0，則 a 和 b 相對位置不變 依照上述邏輯，如果想達成「升冪排列」： const sortedFruits = fruits.sort((a, b) =&gt; { return a.price - b.price; // 依價格排序})console.log(sortedFruits);// output: [// { \"name\": \"banana\", \"price\": 30 },// { \"name\": \"apple\", \"price\": 45 },// { \"name\": \"papaya\", \"price\": 60 },// { \"name\": \"watermelon\", \"price\": 75 },// { \"name\": \"strawberry\", \"price\": 100 }// ] reduce()語法：arr.reduce(callback[accumulator, currentValue, currentIndex, array], initialValue) 應用的範圍較廣，常用於累計運算。將陣列中的項目依序傳給 callback 函式，並將回傳值傳入下次運算，最後返回累計結果 參數說明： accumulator：累計值，上一次運算的回傳值，如果是第一次計算，則為初始值 currentValue：當前項目 currentIndex：當前項目索引值 array：整個陣列 initialValue：初始值 const countPrice = fruits.reduce((accumulator, currentValue, currentIndex, array) =&gt; { return accumulator + currentValue.price; // 價格計算}, 0)console.log(countPrice); // output: 310 reduce() 也可以做更複雜的運算，例如： 將所有水果名稱組成陣列 const fruitsName = fruits.reduce((accumulator, currentValue, currentIndex, array) =&gt; { return [ ...accumulator, currentValue.name ];}, []);console.log(fruitsName);// output: [ \"apple\", \"strawberry\", \"banana\", \"papaya\", \"watermelon\" ] 將陣列結構轉成物件（key: value） const fruitPrices = fruits.reduce((accumulator, currentValue, currentIndex, array) =&gt; { accumulator[currentValue.name] = currentValue.price; return accumulator;}, {});console.log(fruitPrices);// output: { \"apple\": 45, \"strawberry\": 100, \"banana\": 30, \"papaya\": 60, \"watermelon\": 75 } 其他方法 push()在陣列最後面加入項目 fruits.push({ name: 'guava', price: 35 });console.log(fruits);// output: [// ...// { name: 'guava', price: 35 }// ] pop()移除陣列內最後一筆項目 fruits.pop();console.log(fruits);// output: [// ...// { \"name\": \"watermelon\", \"price\": 75 }// ] unshift()在陣列最前面加入項目 fruits.unshift({ name: 'guava', price: 35 });console.log(fruits);// output: [// { name: 'guava', price: 35 },// ...// ] shift()移除陣列內第一筆項目 fruits.shift();console.log(fruits);// output: [// { name: 'apple', price: 45 },// ...// ] slice()語法：arr.slice(begin, end) 選擇開始與結束索引值間的項目（包含開始，不包含結束），結束索引值可不填，並回傳一個新的陣列，原陣列不受影響 const remainFruits = fruits.slice(1, 3);console.log(remainFruits);// output: [// { \"name\": \"strawberry\", \"price\": 100 },// { \"name\": \"banana\", \"price\": 30 }// ] splice()語法：array.splice(start, deleteCount, addItem1, addItem2, ...) 移除索引值起的數筆項目，並加入新的項目，加入項目為選填 fruits.splice(1, 3);console.log(fruits);// output: [// { \"name\": \"apple\", \"price\": 45 },// { \"name\": \"watermelon\", \"price\": 75 }// ] 加入新的項目 fruits.splice(1, 3, { name: 'guava', price: 35 });console.log(fruits);// output: [// { \"name\": \"apple\", \"price\": 45 },// { \"name\": \"guava\", \"price\": 35 }// { \"name\": \"watermelon\", \"price\": 75 }// ] join()語法：arr.join(separator) 將陣列中的值合併成一個字串，並可加入分隔字符，回傳一個字串 const fruits = [ 'apple', 'strawberry', 'banana', 'papaya', 'watermelon' ];console.log(fruits.join(', '));// output: apple, strawberry, banana, papaya, watermelon indexOf()跟 findIndex() 的目的相同，均為找到項目在陣列中的索引值，如果找不到該項目，會返回 -1，但使用方式與情境有些差異，indexOf() 不適合用在物件搜尋 const fruits = [ 'apple', 'strawberry', 'banana', 'papaya', 'watermelon' ];console.log(fruits.indexOf('strawberry')); // output: 1 includes()檢查陣列中是否包含特定值，回傳結果為 Boolean，不適合用在物件搜尋 const fruits = [ 'apple', 'strawberry', 'banana', 'papaya', 'watermelon' ];console.log(fruits.includes('papaya')); // output: true reverse()反轉陣列內的項目排序 const reverseFruits = fruits.reverse();console.log(reverseFruits);// output: [// { \"name\": \"watermelon\", \"price\": 75 },// { \"name\": \"papaya\", \"price\": 60 },// { \"name\": \"banana\", \"price\": 30 },// { \"name\": \"strawberry\", \"price\": 100 },// { \"name\": \"apple\", \"price\": 45 }// ] concat()組合兩個陣列，並返回新陣列，原陣列不受影響 const newFruits = [ { name: 'guava', price: 35 } ];const concatFruits = fruits.concat(newFruits);console.log(concatFruits);// output: [// ...// { name: 'guava', price: 35 }// ] concat() 的功能也可以用 ES6 解構取代 const concatFruits = [ ...fruits, ...newFruits ]; 參考資源： https://www.casper.tw/javascript/2017/06/29/es6-native-array/https://developer.mozilla.org/zh-TW/docs/Web/JavaScript/Reference/Global_Objects/Array/reducehttps://hackmd.io/@hsuchihting/ryvYW2YvL","link":"/2023/05/25/javascript/js-array-methods/"},{"title":"Javascript 函數原型方法：call、apply、bind 改變 this 指向","text":"函數原型 call、apply、bind 方法可以用來改變 this 指向的對象，bind 和其他兩個方法 call、apply 較不同，call、apply 會直接執行函式，bind 只是將 this 綁定到函式內，並不會實際執行，這樣說明還是有點難懂，那就接下去看看吧。 首先建立基本參數 const customer = { name: 'Daniel'}function callName() { console.log(this.name);}callName(); // undefined 如果我們直接執行函式，這時候會得到 undefined，原因是 this 指向的是 window，裡面並沒有 name 這個參數，如果要將 this 指向 customer 這個物件，該怎呢做呢？ bindbind 會建立一個被包裹後的新函式，該函式被呼叫時，會將&nbsp;this 設為綁定的參數，另外也可以綁定其他的參數，綁定之後的參數在該函式就無法再修改。 語法fun.bind(this, arg1, arg2, ...) 使用 bind 將 this 「綑綁」進去，建立一個新的函式 const copyCallName = callName.bind(customer);copyCallName(); // Daniel 這時候執行 copyCallName()，就可以取得 customer 物件的內容 也可以直接執行 callName.bind(customer)(); // Daniel 或是寫在函式表達式後面 const callName = function() { console.log(this.name);}.bind(customer)callName(); // Daniel this 被綁定後將無法變更 const student = { name: 'Andy'}const callName = function() { console.log(this.name);}.bind(customer)callName.bind(student)(); // Daniel 綁定其他參數首先在 callName 函式加入兩個參數 callName(age, gender) { console.log(this.name); console.log(age); console.log(gender);} 沒有綁定的情況下，可以任意代入值 const copyCallName = callName.bind(customer);copyCallName(30, 'male');// Daniel// 30// male 參數被 bind 綁定後將無法變更 const copyCallName = callName.bind(customer, 18, 'female');copyCallName(30, 'male'); // 賦值無效// Daniel// 18// female callfun.call() 會直接執行函式，並且將 this 跟其他參數依序代入 語法fun.call(this, arg1, arg2, ...) 回到前面定義的參數 const customer = { name: 'Daniel'}callName(age, gender) { console.log(this.name); console.log(age); console.log(gender);} 呼叫方式如下 function useCallName() { callName.call(customer, ...arguments);}useCallName(30, 'male');// Daniel// 30// male arguments：javascript 內建參數，不需預先定義，函式內自動建立此參數，在函式呼叫時傳遞進去的引數透過陣列傳入 直接呼叫結果相同 callName.call(customer, 30, 'male');// Daniel// 30// male apply有點像 call() 的簡化版本，只傳入兩個參數，第二個參數是其餘參數包裝成的陣列 語法fun.apply(this, [ arg1, arg2, ... ]) 呼叫方式如下 function useCallName() { callName.apply(customer, arguments);}useCallName(30, 'male');// Daniel// 30// male 直接呼叫結果相同 callName.apply(customer, [ 30, 'male' ]);// Daniel// 30// male 延伸：改變 this 指向的其他做法以下述為例進行說明： const customer = { name: 'Daniel', LazyCallName() { setTimeout(function() { console.log(this.name); }, 1000); }}customer.LazyCallName(); // undefined 如果要取到 name 的值，可以透過三個方法： 1. bind 透過函數原型方法 bind，將 this 指向 customer 這個物件 const customer = { name: 'Daniel', LazyCallName() { setTimeout(function() { console.log(this.name); }.bind(this), 1000); }}customer.LazyCallName(); // Daniel 2. 在外層函式宣告變數儲存 this 在外層 LazyCallName function 先定義變數 vm，將 this 儲存起來 const customer = { name: 'Daniel', LazyCallName() { const vm = this; setTimeout(function() { console.log(vm.name); }, 1000); }}customer.LazyCallName(); // Daniel 3. ES6 Arrow Function 由於箭頭函式的 this&nbsp;綁定的是定義時所在的物件，透過箭頭函式，this 以 LazyCallName function 為基準產生作用域（函式也是物件型別），指向 customer 物件 const customer = { name: 'Daniel', LazyCallName() { setTimeout(() =&gt; { console.log(this.name); }, 1000); }}customer.LazyCallName(); // Daniel 參考文章： https://realdennis.medium.com/javascript-聊聊call-apply-bind的差異與相似之處-2f82a4b4dd66https://medium.com/swlh/call-apply-bind-javascript-methods-7d96a73816e8https://b-l-u-e-b-e-r-r-y.github.io/post/BindCallApply/","link":"/2023/02/04/javascript/js-call-apply-bind/"},{"title":"Javascript ES6 Class 與建構函式","text":"繼承與原型鏈在 class 出現前，通常使用建構函式（Constructor）建立原型（Prototype）。原型並非實體（可以將其理解成藍圖），必須透過 new 運算子實體化，繼承該原型。 new operator（運算子）：產生一個新的空白物件，連結原先建構函式（函式本身也是物件），建構函式內的 this 會綁定在新物件上 假設今天有一個『花栗鼠』的藍圖，再根據這張藍圖創造出實體，每個實體都符合藍圖的規格： // 建構函式（藍圖）function Chipmunk(name, color, size) { this.name = name; this.color = color; this.noseSize = size;};const Chip = new Chipmunk('Chip', 'brown', 'small');const Dale = new Chipmunk('Dale', 'yellow', 'large'); 透過函式物件內 prototype 新增的屬性，會掛載在原型上 Chipmunk.prototype.climb = function() { console.log(`${this.name} is climbing the tree`);}; 透過繼承， 實體化後的物件也都可以取得原型方法 console.log(Chip);console.log(Dale);// output: 結果如下 Chip.climb(); // output: Chip is climbing the treeDale.climb(); // output: Dale is climbing the tree 將共用方法掛在原型上，方法只會被定義一次，只需要一個記憶體空間，減少效能的消耗與浪費 多層繼承假設我們希望在花栗鼠建構式前面再加上動物界原型，結構如下： 動物界原型 → 花栗鼠建構函式 → 實體化建構式 1. 動物界原型 function Animal(family) { this.kingdom = 'animals'; this.family = family;};Animal.prototype.eat = function() { console.log(`${this.name} is eating something`);}; 2. 花栗鼠建構函式 透過 Object.create() 繼承動物界原型 透過原型方法 call() 調用動物界建構函式（需指定 this） 因繼承動物界原型，導致 Chipmunk 建構函式被覆寫，透過 Chipmunk.prototype.constructor = Chipmunk 補回，讓原型鏈更加完整 function Chipmunk(name, color, size) { Animal.call(this, 'squirrel'); this.name = name; this.color = color; this.noseSize = size;};Chipmunk.prototype = Object.create(Animal.prototype);Chipmunk.prototype.constructor = Chipmunk;Chipmunk.prototype.climb = function() { console.log(`${this.name} is climbing the tree`);}; 3. 實體化建構式 const Chip = new Chipmunk('Chip', 'brown', 'small');const Dale = new Chipmunk('Dale', 'yellow', 'large'); console.log(Chip);// output: 結果如下 以上寫法有幾個缺點： 建構函式通常使用大駝峰（PascalCase）命名，但還是容易與一般函式混淆 如果沒有加上 new 運算子，並不會報錯，但結果會是 undefined 繼承原型方式較為複雜，共用方法也必須另外定義，缺少『封裝』結構，維護性較差 ES6 Class 類別先前的寫法，容易混淆 Class 跟 Constructor 的關係，ES6 Class 是簡化操作 Constructor 的語法糖，結構上更好理解 class Chipmunk { constructor(name, color, size) { this.name = name; this.color = color; this.noseSize = size; } climb() { console.log(`${this.name} is climbing the tree`); }}const Chip = new Chipmunk('Chip', 'brown', 'small');const Dale = new Chipmunk('Dale', 'yellow', 'large'); Class 只是語法糖，並非類別基礎（Class-Based）物件導向（Object Oriented Programming），它仍然是原型基礎（Prototype-Based）物件導向 Class 多層繼承結構同前述：動物界原型 → 花栗鼠建構函式 → 實體化建構式 1. 動物界原型 class Animal { constructor(family) { this.kingdom = 'animals'; this.family = family; } eat() { console.log(`${this.name} is eating something`); }} 2. 花栗鼠建構函式 透過 extends 繼承動物界原型 透過 super() 調用動物界建構函式 class Chipmunk extends Animal { constructor(name, color, size) { super('squirrel'); this.name = name; this.color = color; this.noseSize = size; } climb() { console.log(`${this.name} is climbing the tree`); }} 3. 實體化建構式 const Chip = new Chipmunk('Chip', 'brown', 'small');const Dale = new Chipmunk('Dale', 'yellow', 'large'); Class 常用方法私有變數：變數前綴加上 #，外部無法取用，class 內可以使用 class Chipmunk { #tree = 'oak'; // 私有變數 constructor(name, color, size) { this.name = name; this.color = color; this.noseSize = size; } climb() { console.log(`${this.name} is climbing the ${this.#tree}`); }}const Chip = new Chipmunk('Chip', 'brown', 'small');console.log(Chip.tree); // output: undefinedChip.climb(); // output: Chip is climbing the oak Getter／Setter：取得與設定方法，通常用於計算 class Chipmunk { realAge = 0; constructor() { // ... } set age(val) { this.realAge = val; } get age() { return this.realAge * 30; }}const Chip = new Chipmunk('Chip', 'brown', 'small');Chip.age = 1;console.log(Chip.age); // output: 30 Static 靜態方法／變數： 不經過實體化即可取用 Class 內方法 實體化物件不可取用該方法（不能調用 this） class Chipmunk { constructor() { // ... } static caculateAge(age, minus) { return age * minus; }}const Chip = new Chipmunk('Chip', 'brown', 'small');console.log(Chipmunk.caculateAge(2, 30)); // output: 60console.log(Chip.caculateAge(2, 30)); // output: Uncaught TypeError: Chip.caculateAge is not a function 參考文章： https://medium.com/enjoy-life-enjoy-coding/javascript-es6-中最容易誤會的語法糖-class-基本用法-23e4a4a5e8edhttps://developer.mozilla.org/zh-TW/docs/Web/JavaScript/Inheritance_and_the_prototype_chainhttps://ithelp.ithome.com.tw/articles/10185583","link":"/2023/03/06/javascript/js-class/"},{"title":"Javascript Currying 柯里化","text":"Currying is a technique in functional programming where a function that takes multiple arguments is transformed into a sequence of functions that each take a single argument. Currying 是一種函式編程（程式設計的一種，可以參考此篇文章）技術，將接收多個參數的函式，拆解為多個函式，每個函式只接受一個參數 使用目的 將程式碼拆成片段，讓函式能重複運用（DRY 避免重複代碼原則），有助於創建 higher-order function 簡化參數處理，一次處理一個參數，提高彈性和易讀性 範例一般函式：function add(x, y) { return x + y;}add(5, 3); // output：8 Curry Function：function add(x) { return (y) =&gt; { return x + y; }}add(5)(3); // output：8 應用方式： const addFive = add(5);addFive(3); // output：8 curry function 利用 closure（閉包）的特性，當內部函式被回傳後，可以取得內部函式「所在環境」的變數值。 用以下拆解進行說明： 內部函式（inner）被回傳後，可以取得所在環境（add）的變數值（x） function add(x) { function inner(y) { return x + y; } return inner;}const addFive = add(5);addFive(3); // output：8 首先將 add(5) 存放在 addFive 參數，當呼叫 addFive(3)，add 內部函式（inner）被調用，完成運算後回傳結果 8。 Currying vs. Partial applicationCurrying 有時會跟 Partial application（偏函數應用）混淆，以下舉例說明差異 Curry Function：一個函式只能包含一個 Arity（參數個數） function add(x) { return (y) =&gt; { return (z) =&gt; { return x + y + z; } }}add(1)(2)(3); // output：6 Partial application：一個函式可以包含多個參數個數 function add(x) { return (y, z) =&gt; { return x + y + z; }}add(1)(2, 3); // output：6 進階應用需搭配 Javascript 函數原型方法 call、apply（參考文章），以及遞迴函式概念（參考文章） 建立共用 Curry function，將函式作為參數 function curry(func) { return curried = (...args) =&gt; { // 引數個數大於或等於參數個數 if (args.length &gt;= func.length) { return func.apply(this, args); } return (...moreArgs) =&gt; { return curried.apply(this, args.concat(moreArgs)); } }} 將 add 作為引數代入 func 參數 function add(x, y, z) { return x + y + z;}const curriedAdd = curry(add); 以下三個使用方式執行結果相同 curriedAdd(1)(2)(3); // output：6curriedAdd(1, 2)(3); // output：6curriedAdd(1)(2, 3); // output：6 利用 Curry Function，函式可以更加彈性的運用，提高程式碼的維護性 const curriedAdd1 = curriedAdd(1);curriedAdd1(2, 3); // output：6curriedAdd1(3, 4); // output：8const curriedAdd2 = curriedAdd(1, 2);curriedAdd2(3); // output：6curriedAdd2(5); // output：8 參考文章： https://medium.com/javascript-scene/curry-and-function-composition-2c208d774983 https://ithelp.ithome.com.tw/articles/10236374 https://medium.com/swlh/currying-in-javascript-bbe4ddedf86b","link":"/2023/02/16/javascript/js-currying/"},{"title":"Javascript Debounce & Throttle 提升網頁效能","text":"debounce 與&nbsp;throttle 用來防止 scroll, resize 等事件處理器在短時間內被頻繁觸發，綁定的函示重複執行，造成網頁不斷重新運算進而影響效能，作法就是控制函式觸發的次數或頻率，以下分別說明兩者的操作方式。 Debounce概念是加入一個倒數計時器，連續觸發時會一直重新倒數，直到計時器歸零，才執行函式。 簡單舉例：就像是便利商店的自動門，當一段時間內頻繁有客人進來，自動門會持續開著，直到大家都進入後，等待幾秒才關上。 function debounce(func, delay = 1000) { let timer = null; return function(...args) { clearTimeout(timer); timer = setTimeout(() =&gt; { func.apply(this, args); }, delay) }} 利用閉包（closure）將 timer 變數與內部函式分享，func.apply(this, args) 可以替換成 func.call(this, ...args) 或是 func.bind(this)(...args) 如果不太清楚函數原型方法 call、apply、bind，以及裡面代入的 this 和 argument，可以參考這一篇 範例：input 輸入搜尋事件 當輸入停止超過一秒後，才去讀取輸入內容 &lt;input type=\"text\" placeholder=\"請輸入搜尋內容\" id=\"search\" /&gt;&lt;p id=\"content\"&gt;&lt;/p&gt; const input = document.getElementById('search');const content = document.getElementById('content');input.addEventListener('input', debounce(updateContent));function updateContent(e) { content.textContent = e.target.value;} 範例畫面： See the Pen Javascript Debounce by Claire Chang (@claire-chang-the-bashful) on CodePen. Throttle節流器，目的是減少事件執行的次數，事件連續觸發時製造間隔來控制運行次數。 簡單舉例：像是等紅綠燈，在固定的時間才會轉成綠燈，如果錯過了，必須等待一段時間，直到下次綠燈才能通過。 首次執行的時機：有以下兩種，只差在首次執行，後續的結果都是一樣的。 1. 首次「立刻」執行 function throttle(func, timeout = 1000) { let isClose = false; let timer = null; return function(...args) { if (isClose) { return; } func.apply(this, args); // 第一次執行不進入 settimeout() 計算 isClose = true; clearTimeout(timer); timer = setTimeout(() =&gt; { func.apply(this, args); isClose = false; }, timeout) }} 2. 首次「延遲」執行 function throttle(func, timeout = 1000) { let isClose = false; let timer = null; return function(...args) { if (isClose) { return; } isClose = true; clearTimeout(timer); timer = setTimeout(() =&gt; { func.apply(this, args); // 第一次執行進入 settimeout() 計算 isClose = false; }, timeout); }} 範例：scroll 視窗滾動事件 滾動視窗時，每隔一秒才執行函式，判斷是否要顯示下一區塊內容 &lt;ul id=\"content\"&gt;&lt;/ul&gt; const content = document.getElementById('content');window.addEventListener('scroll', throttle(handleScroll));function handleScroll() { if ((window.innerHeight + window.scrollY) &gt;= document.body.offsetHeight) { content.innerHTML += '&lt;li&gt; ... &lt;/li&gt;'; }} 範例畫面： See the Pen Javascript Throttle by Claire Chang (@claire-chang-the-bashful) on CodePen. debounce 與&nbsp;throttle 適合的情境略有不同，可以藉由上述範例來觀察兩者間的差異 debounce 適用在停止觸發後才執行事件（input 停止輸入後，才去讀取更新的值） throttle 適用在固定時間區間執行事件（滑鼠滾動時，每隔一秒檢查當前位置，判斷是否要撈取下一頁的資料） 參考文章： https://medium.com/@alexian853/debounce-throttle-那些前端開發應該要知道的小事-一-76a73a8cbc39 https://ithelp.ithome.com.tw/articles/10222749 https://medium.com/@steven234/throttle跟-debounce有什麼區別-e0b1979b1b4f","link":"/2023/02/04/javascript/js-debounce-throttle/"},{"title":"Javascript ES6 資料型別 Symbol","text":"JavaScript 的型別分為兩種：原始資料型別（Primitive Data Types）以及物件型別（Object Types） 原始資料型別包含以下： String 字串型別 Number 數字型別 Boolean 布林型別 Null Undefined Symbol ES6 Symbols 是 JavaScript 中的一種新資料型別，用於表示唯一的識別符。每個 Symbol 值都是唯一且不可變的，並且可以作為物件屬性的 key 值。也就是說，即使兩個 Symbol 值具有相同的描述（description），兩者也不相等。 我們可以使用 Symbol() 函數來建立一個 Symbol 值，可以帶一個參數，用以描述該 Symbol。 屬性說明 非建構函式，不能搭配 new 使用（new Symbol()） 不能使用 for...in、Object.keys() 等迴圈迭代，必須搭配 Object.getOwnPropertySymbols() 方法 不能使用點運算子 . 取得屬性值，必須使用中括號 [] 可以作為唯一 key 使用，避免相同 key 值覆寫的情況 使用方式Symbol(description) 建立唯一識別 const Daniel = Symbol('student');const Claire = Symbol('student');console.log(Daniel === Claire); // output: false Symbol.for(key) 全域存取共用 Symbol.for() 方法建立的 Symbol 會被保存在全域中，接收一個字符串作為參數，這個字符串稱為 Symbol 的 key，如果在全域 Symbol 表中已經存在該 key 對應的 Symbol，則直接回傳此 Symbol；如果不存在則新增一個 Symbol const Daniel = Symbol.for('student'); // 新建const Claire = Symbol.for('student'); // 複用console.log(Daniel === Claire); // output: true Symbol.keyFor(symbol) 取得 Symbol.for() 的 key 值 const Daniel = Symbol.for('student');console.log(Symbol.keyFor(Daniel)); // output: student Object.getOwnPropertySymbols() 迴圈 一般來說，如果物件內有重複 key 值，後者會覆寫前者，見以下範例 const students = { daniel: { age: 18, gender: 'male' }, claire: { age: 17, gender: 'female' }, andy: { age: 16, gender: 'male' }, daniel: { age: 20, gender: 'male' }}console.log(students);// output:// {// andy: {age: 16, gender: 'male'},// claire: {age: 17, gender: 'female'},// daniel: {age: 20, gender: 'male'}// } 但如果真的存在相同 key 值，像是相同名稱的學生，可以搭配 symbol 使用 const students = { [Symbol('daniel')]: { age: 18, gender: 'male' }, [Symbol('claire')]: { age: 17, gender: 'female' }, [Symbol('andy')]: { age: 16, gender: 'male' }, [Symbol('daniel')]: { age: 20, gender: 'male' }}console.log(students);// output:// {// Symbol(andy): {age: 16, gender: 'male'},// Symbol(claire): {age: 17, gender: 'female'},// Symbol(daniel): {age: 18, gender: 'male'},// Symbol(daniel): {age: 20, gender: 'male'}// } 搭配 Object.getOwnPropertySymbols 運行迴圈判斷 const adults = Object.getOwnPropertySymbols(students).filter(symbol =&gt; { return students[symbol].age &gt;= 18;});console.log(adults);// output: [ Symbol(daniel), Symbol(daniel) ] 參考文章： https://ithelp.ithome.com.tw/articles/10220499 https://ithelp.ithome.com.tw/articles/10242050","link":"/2023/03/28/javascript/js-es6-symbol/"},{"title":"Javascript 物件迴圈方法","text":"除了 for…in 方法，還有許多迴圈方法可以協助處理陣列資料，但物件並不支援這些方法，以下為例 const fruits = { apple: { price: 45 }, strawberry: { price: 100 }, banana: { price: 30 }, papaya: { price: 60 }, watermelon: { price: 75 }} 假設我們想取得每個元素的價格，直接使用陣列方法 forEach() 會產生錯誤，因為物件並沒有該寫法 fruits.forEach(item =&gt; { console.log(item.price);});// output: Uncaught TypeError: fruits.forEach is not a function 將物件轉為陣列 Object.keys() Object.values() Object.entries() Object.keys()取得一個物件的所有可枚舉屬性名稱（key），並回傳陣列 console.log(Object.keys(fruits));// output: ['apple', 'strawberry', 'banana', 'papaya', 'watermelon'] Object.keys(fruits).forEach(key =&gt; { console.log(fruits[key].price);});// output:// 45// 100// 30// 60// 75 Object.values()取得一個物件的所有可枚舉屬性的值（value），並回傳陣列 console.log(Object.values(fruits));// output: [// { \"price\": 45 },// { \"price\": 100 },// { \"price\": 30 },// { \"price\": 60 },// { \"price\": 75 }// ] Object.values(fruits).forEach(item =&gt; { console.log(item.price);});// output:// 45// 100// 30// 60// 75 Object.entries()可以取得最完整的資訊，將一個物件的所有可枚舉屬性（key）與值（value）組合一個陣列，第一個值為 key，第二個值為 value console.log(Object.entries(fruits));// output: [// [ \"apple\", { \"price\": 45 } ],// [ \"strawberry\", { \"price\": 100 } ],// [ \"banana\", { \"price\": 30 } ],// [ \"papaya\", { \"price\": 60 } ],// [ \"watermelon\", { \"price\": 75 } ]// ] Object.entries(fruits).forEach(item =&gt; { console.log(item[1].price);});// output:// 45// 100// 30// 60// 75 Object.fromEntries()Object.fromEntries() 為 Object.entries() 的反向操作，將 陣列轉物件 const fruits = [ [ 'apple', { price: 45 } ], [ 'strawberry', { price: 100 } ], [ 'banana', { price: 30 } ]];console.log(Object.fromEntries(fruits));// output: {// \"apple\": {// \"price\": 45// },// \"strawberry\": {// \"price\": 100// },// \"banana\": {// \"price\": 30// }// } 小結 Object.keys() 跟 Object.entries() 可以用來取得物件的屬性名稱跟值 Object.values() 適合適合用來取得物件各元素值 Object.fromEntries() 為 Object.entries() 的逆向操作 以上方法在處理物件時提供了不同的優點和功能，常會搭配陣列方法使用（參考文章），可以根據需求選擇最適方法 參考資源： https://ithelp.ithome.com.tw/articles/10239942https://www.casper.tw/development/2022/03/10/object-for-each/","link":"/2023/06/01/javascript/js-object-loop/"},{"title":"Three.js 3D Library (1) 基本介紹","text":"Three.js 是一個基於 WebGL 開發的 JavaScript 函式庫，可在網頁上建立 3D 圖形。Three.js 提供比 WebGL 更簡單、高效且功能豐富的方式來創建互動性的 3D 場景，並支援多種渲染器，包括 WebGL、Canvas 和 SVG 套件安裝npm i three import * as THREE from 'three' 基本元素 場景 Scene 相機 Camera 物體 Objects 光源 Light 渲染器 Renderer 場景 Scene場景是一個物件容器，用來存放所有的物體、光源和相機等元素。網頁上的 3D 圖形都是由場景中的元素所組成，一個網頁可以有多個場景 const scene = new THREE.Scene()scene.background = new THREE.Color(0xffffff) // 設定背景設為白底 建立場景後，可以使用 scene.add(object) 方法將物體加入到場景，也可以使用 scene.remove(object) 方法將物體從場景移除 相機 Camera相機決定了在場景中看到的位置和角度。Three.js 支援多種類型的相機，包括： PerspectiveCamera 透視相機 OrthographicCamera 正交相機 1. PerspectiveCamera 透視相機透視相機用於模擬人眼觀察物體的效果，建立透視相機基本參數： FOV (Field of View)：視野角度，單位為度數，通常設定為 45 度 Aspect Ratio：畫面的寬高比，通常設定為 window.innerWidth / window.innerHeight Near：相機到近端的距離，通常設定為 0.1 Far：相機到遠端的距離，通常設定為 1000 const camera = new THREE.PerspectiveCamera( 45, window.innerWidth / window.innerHeight, 0.1, 1000); 2. OrthographicCamera 正交相機正交相機無論物體距離遠近，看起來大小都相同，適合用於模擬透視效果不明顯的場景，例如平面地圖。建立正交相機基本參數： Left：畫面左邊界的位置 Right：畫面右邊界的位置 Top：畫面上邊界的位置 Bottom：畫面下邊界的位置 Near：相機到近端的距離 Far：相機到遠端的距離 const camera = new THREE.OrthographicCamera( -window.innerWidth / 2, window.innerWidth / 2, window.innerHeight / 2, -window.innerHeight / 2, 0.1, 1000); 建立相機後，可以使用 camera.position.set(x, y, z) 方法設定相機的位置，也可以使用 camera.lookAt(object) 方法讓相機對準另一個物體。 物體 Objects物體是在場景中顯示的 3D 圖形元素，有以下幾種： Mesh 網格：由幾何形狀和材質組成的物體 Points：由點和材質組成的物體，通常用於顯示粒子效果 Line：由線段和材質組成的物體，通常用於顯示簡單的線條效果 Sprite：只有 2D 圖片的物體，可以隨著相機位置旋轉和縮放 1. 網格 MeshThree.js 中最常用的物體類別，由 幾何體 Geometry 和 材質 Material 組合而成 幾何體 Geometry：定義物體的形狀、大小和位置 材質 Material：定義物體的材質和外觀，可以設定顏色、紋理、透明度… // 建立幾何體const geometry = new THREE.SphereGeometry(1, 32, 32);// 建立材質const material = new THREE.MeshBasicMaterial({ color: 0xffffff });// 建立網格const sphere = new THREE.Mesh(geometry, material);// 將網格加入到場景中scene.add(sphere); 2. 粒子 Points通常用於顯示粒子效果 // 建立幾何體const geometry = new THREE.BufferGeometry();const vertices = [];for (let i = 0; i &lt; 1000; i++) { const x = 2000 * Math.random() - 1000; const y = 2000 * Math.random() - 1000; const z = 2000 * Math.random() - 1000; vertices.push(x, y, z);}geometry.setAttribute('position', new THREE.Float32BufferAttribute(vertices, 3));// 建立材質const material = new THREE.PointsMaterial({size: 35, sizeAttenuation: true, alphaTest: 0.5, transparent: true});// 建立粒子const points = new THREE.Points(geometry, material);// 將粒子加入到場景中scene.add(points); 3. 線條 Line由一些連接的線段和材質組成的物體，通常用於顯示簡單的線條效果 以下範例為一個由三個點組成的線段 // 建立幾何體const geometry = new THREE.BufferGeometry();const vertices = new Float32Array([ -1, 0, 0, 0, 1, 0, 1, 0, 0]);geometry.setAttribute('position', new THREE.BufferAttribute(vertices, 3));// 建立材質const material = new THREE.LineBasicMaterial({ color: 0xffffff });// 建立線條const line = new THREE.Line(geometry, material);// 將線條加入到場景中scene.add(line); 光源 Light光源用於模擬光照效果，可以讓場景中的物體更加真實。有些材質不受光源影響，例如MeshBasicMaterial 跟 MeshNormalMaterial 是沒有陰影的材質。如果需要使用光源，可以嘗試使用 MeshPhongMaterial 、 MeshStandardMaterial 或 MeshLambertMaterial 光源有幾下幾種： 方向光 DirectionalLight：模擬太陽光射向物體的效果，用來產生陰影效果 環境光 AmbientLight：模擬室內的照明效果，對場景中物體的亮度沒有方向性的影響 點光源 PointLight：模擬燈泡發出的光線，可以有位置的光源 聚光燈 SpotLight：模擬射燈效果，可以有方向和位置的光源 半球光 HemisphereLight：模擬天空環境光的光源，為球形光源 1. 方向光 DirectionalLight為平行光，只有方向沒有位置，類似太陽光，來自於一個方向，可以用來模擬太陽光射向物體的效果 const light = new THREE.DirectionalLight(0xffffff, 1);light.position.set(0, 1, 0);scene.add(light); 2. 環境光 AmbientLight一種均勻的光源，對場景中物體的亮度沒有方向性的影響，用來模擬室內的照明效果 const light = new THREE.AmbientLight(0x404040);scene.add(light); 3. 點光源 PointLight一種有位置的光源，從一個點向四面八方發射光線，用來模擬燈泡光 const light = new THREE.PointLight(0xffffff, 1, 100); // 光源顏色、強度和距離限制light.position.set(0, 0, 50);scene.add(light); 4. 聚光燈 SpotLight為有方向和位置的光源，類似手電筒，可以聚焦光線，用來模擬射燈效果 const light = new THREE.SpotLight(0xffffff, 1, 100, Math.PI / 4); // 光源顏色、強度、距離限制和照射角度light.position.set(0, 0, 50);scene.add(light); 5. 半球光 HemisphereLight一種模擬天空環境光的光源，為球形光源，用來模擬天空和地面反射光互相作用的效果 const hemisphereLight = new THREE.HemisphereLight(0xffffbb, 0x080820, 1); // 天空和地面的顏色以及強度scene.add(hemisphereLight); 渲染器 Renderer前面提到的幾種元素，最後會透過渲染器將場景中的物件轉換成 2D 圖像，顯示在網頁上，通常使用 WebGLRenderer 渲染器，WebGLRenderer 使用 WebGL 進行渲染，可以讓網頁上的 3D 圖形更加流暢和精細 const renderer = new THREE.WebGLRenderer();renderer.setSize(window.innerWidth, window.innerHeight);document.body.appendChild(renderer.domElement); 使用 renderer.setSize(width, height) 方法設定渲染器的寬度和高度，使用 renderer.domElement 屬性取得渲染器的 DOM 元素，並加入網頁 DOM 元素內 1. 場景渲染加入場景跟相機進行渲染 renderer.render(scene, camera); 2. 動畫循環渲染 Render Loop如果想加入動態效果，可以搭配瀏覽器原生方法 requestAnimationFrame，自動建立每秒 60 次的循環渲染，requestAnimationFrame 的優點為： 切換瀏覽器分頁時會自動暫停，可以提升網頁效能 流暢的動畫效果 ...const cube = new THREE.Mesh( geometry, material );function animate() { requestAnimationFrame(animate); cube.rotation.x += 0.01; cube.rotation.y += 0.01; renderer.render(scene, camera);}animate(); 以上基本概念理解後，下一篇將組合以上元素，進行『模型實作』囉！ 參考資源： https://ithelp.ithome.com.tw/users/20107572/ironman/1782 https://threejs.org/","link":"/2023/04/06/javascript/js-threejs-intro/"},{"title":"Three.js 3D Library (2) 模型實作","text":"依照上一篇 Three.js 3D Library (1) 基本介紹 介紹了製造 3D 圖形的基本元素，接下來進行實作吧！ 座標系統開始實作之前，必須先了解 Three.js 使用 右手座標系統 Right-Hand Coordinate 來定義 3D 空間： X軸：向右為正方向，Y軸：向上為正方向，Z軸：向外為正方向 如果對此概念不熟悉也沒關係，Three.js 提供座標輔助： const axesHelper = new THREE.AxesHelper(10); // 自訂座標大小scene.add(axesHelper); 實作行星自轉畫面，步驟如下： 建立場景 建立相機 建立渲染器 建立物體 建立光源 渲染場景 以下為進階功能： 加入軌道控制器 打造 RWD 響應式畫面 建立場景設定背景底色 const scene = new THREE.Scene();scene.background = new THREE.Color(0x000000); // 背景色 建立相機使用透視相機，設定相機位置跟相機焦點 const camera = new THREE.PerspectiveCamera( 75, window.innerWidth / window.innerHeight, 0.1, 1000);camera.position.set(120, 120, 120); // 相機位置camera.lookAt(scene.position); // 相機焦點 建立渲染器const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true});renderer.setSize(window.innerWidth, window.innerHeight);// 將canvas內容加入DOMdocument.getElementById('container').appendChild(renderer.domElement); 建立物體結構如下： 行星體（網格物體） 球型體 行星環 群星背景（粒子物體） 再次複習一下建立網格（Mesh）或粒子（Points）物體順序：建立幾何體 → 建立材質 → 建立物體 → 將物體加入場景 行星體（網格物體）分為球型體跟行星環，軸心旋轉（X軸-30度、Y軸-10度） 輔助座標首先建立輔助座標，可以協助我們快速理解3D空間 const axesHelper = new THREE.AxesHelper(50);axesHelper.rotation.x = THREE.MathUtils.degToRad(-30); // X軸旋轉-30度axesHelper.rotation.y = THREE.MathUtils.degToRad(-10); // Y軸旋轉-10度scene.add(axesHelper); 使用 THREE.MathUtils.degToRad() 運算函式，將角度（degrees）轉換成弧度（radians） 球型體使用 IcosahedronGeometry(radius, detail) 建立多面體，詳細說明見官方文件 // 建立幾何體const sphereGeometry = new THREE.IcosahedronGeometry(20, 1);// 建立材質const sphereMaterial = new THREE.MeshPhongMaterial({ color: 0xffffff, emissive: 0x000000, specular: 0xffffff, shininess: 100, flatShading: true});// 建立網格const sphere = new THREE.Mesh(sphereGeometry, sphereMaterial); 行星環使用 RingGeometry() 建立圓環幾何體，詳細說明見官方文件 // 建立幾何體const RingGeometry = new THREE.RingGeometry(42, 28, 30, 30);// 建立材質const RingMaterial = new THREE.MeshPhongMaterial({ color: 0xffffff, emissive: 0x000000, specular: 0xffffff, shininess: 100, flatShading: true, transparent: true, opacity: 0.7});// 建立網格物體const ring = new THREE.Mesh(RingGeometry, RingMaterial);// X軸旋轉90度，讓圓環呈現水平排列ring.rotation.x = THREE.MathUtils.degToRad(90); 組合行星體使用 Group() 建立群組，軸心旋轉（同前面說明：X軸-30度、Y軸-10度） const planet = new THREE.Group();planet.add(sphere, ring); // 加入球形體&amp;行星環planet.rotation.x = THREE.MathUtils.degToRad(-30);planet.rotation.y = THREE.MathUtils.degToRad(-10);// 將物體加入場景scene.add(planet); 群星背景（粒子物體） 使用 BufferGeometry() 建立幾何體，可以減少 GPU 的消耗，詳細說明見官方文件 // 建立幾何體const geometry = new THREE.BufferGeometry();const particleAmount = 2000; // 群星數const vertices = [];for (let i = 0; i &lt; particleAmount; i++) { const x = 2000 * Math.random() - 1000; const y = 2000 * Math.random() - 1000; const z = 2000 * Math.random() - 1000; vertices.push(x, y, z);}geometry.setAttribute('position', new THREE.Float32BufferAttribute(vertices, 3));// 建立材質// 載入圖片來建立紋理const particleTexture = new THREE.TextureLoader().load('https://i.imgur.com/9TwBBHH.png');const material = new THREE.PointsMaterial({ size: 5, sizeAttenuation: true, map: particleTexture, transparent: true, alphaTest: 0.5, color: 0xf3f3af});// 建立粒子物體const particles = new THREE.Points(geometry, material);// 將物體加入場景scene.add(particles); 建立光源依序建立三種光源，讓光線看起來更自然： 環境光 AmbientLight 點光源 PointLight 聚光燈 SpotLight 環境光const ambientLight = new THREE.AmbientLight(0x222222); 點光源const pointLight = new THREE.PointLight(0x777777, 1, 0);pointLight.position.set(100, 100, 0); 聚光燈const spotLight = new THREE.SpotLight(0xffffff, 3, 150, Math.PI / 6, 1, 1);spotLight.position.set(50, 100, -80);spotLight.castShadow = true;spotLight.shadow.mapSize.width = 1024;spotLight.shadow.mapSize.height = 1024;spotLight.shadow.camera.near = 10;spotLight.shadow.camera.far = 200;spotLight.shadow.focus = 1; 聚光燈輔助可以更明確地看到光線位置 const lightHelper = new THREE.SpotLightHelper(spotLight);scene.add(lightHelper); 最後將光源加入場景 scene.add(ambientLight, pointLight, spotLight); 渲染場景搭配前一篇說明過的 動畫循環渲染 Render Loop 方法 function animate() { requestAnimationFrame(animate); // 星球體Y軸旋轉，創造自轉效果 planet.rotation.y += 0.01; // 將場景渲染到渲染器 renderer.render(scene, camera);}animate(); 到這裡畫面就完成囉！👏👏👏 接著說明進階的功能 加入軌道控制器軌道控制器 OrbitControls 讓使用者可以透過滑鼠或是觸控面板來縮放和移動相機，改變場景中的視角和位置，軌道圍繞著前面提到的 camera.lookAt() 相機焦點 軌道控制器也可以啟用自動旋轉功能，詳細請見官方文件 const control = new OrbitControls(camera, renderer.domElement); 打造 RWD 響應式畫面監聽螢幕尺寸變化，讓畫面自適應 window.addEventListener('resize', () =&gt; { camera.aspect = window.innerWidth / window.innerHeight; camera.updateProjectionMatrix(); renderer.setSize(window.innerWidth, window.innerHeight);}); 完整範例程式碼 See the Pen Three.js-Planet Animation by Claire Chang (@claire-chang-the-bashful) on CodePen. 參考資源： https://ithelp.ithome.com.tw/users/20107572/ironman/1782 https://threejs.org/ https://medium.com/小彥彥的前端五四三/threejs-內建幾何模型-二-3df675ba8315","link":"/2023/04/11/javascript/js-threejs-pattren/"},{"title":"Three.js 3D Library (3) UnrealBloomPass 後製發光效果","text":"上一篇 Three.js 3D Library (2) 模型實作 我們建立了行星動畫，接下來試著加入發光效果，讓畫面更吸睛～ UnrealBloomPass 發光效果Three.js 提供了強大的渲染引擎和豐富的功能，其中後製（Post-processing）是在渲染到螢幕前對畫面進行一些處理，再將畫面渲染到螢幕上，以達到特定的視覺效果，UnrealBloomPass 是其中一個後製功能，可以打造出逼真的發光效果。 使用 UnrealBloomPass 通常會跟 RenderPass 以及 EffectComposer（合成器）搭配使用，到這裡先釐清一下『渲染器渲染』跟『合成器渲染』的差異： 渲染器渲染（WebGLRenderer） Three.js 中最基本的場景渲染方式 直接調用 WebGLRenderer 的 render 方法，將場景中的物體渲染到渲染器的畫面中 每次調用時，只會產生一個渲染畫面 不支援後製效果，結果直接顯示在畫面中 const renderer = new THREE.WebGLRenderer();// ...renderer.render(scene, camera); // 渲染器渲染 合成器渲染（EffectComposer） 需要搭配 Three.js 中的 EffectComposer（合成器）跟 RenderPass 使用 調用 EffectComposer 的 render 方法，將場景渲染到合成器的畫面中 可以在合成器中增加多個後製效果，EX：色彩校正、模糊、光暈… 每次調用時，合成器會依序應用後製效果，生成最終的渲染畫面 const renderer = new THREE.WebGLRenderer();const composer = new EffectComposer(renderer); // 建立合成器const renderScene = new RenderPass(scene, camera);composer.addPass = new EffectComposer(renderScene); // 將 RenderPass 加入合成器// ...composer.render(); // 合成器渲染 基礎應用將整個場景內的物體都加上 UnrealBloomPass 效果，接下來用一個簡單的範例來說明，步驟如下： 建立場景 建立相機 建立渲染器 建立物體 建立 UnrealBloomPass 物件 建立合成器 將 UnrealBloomPass 加入合成器 渲染場景 // 1. 建立場景const scene = new THREE.Scene();// 2. 建立相機const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);camera.position.set(0, 0, 10);camera.lookAt(scene.position) // 相機焦點// 3. 建立渲染器const renderer = new THREE.WebGLRenderer();renderer.setSize(window.innerWidth, window.innerHeight);document.getElementById('container').appendChild(renderer.domElement);// 4. 建立物體const geometry = new THREE.BoxGeometry();const material = new THREE.MeshBasicMaterial({ color: 0xffffff });const cube = new THREE.Mesh(geometry, material);scene.add(cube);// 5. 建立 UnrealBloomPass 物件const bloomPass = new UnrealBloomPass(new THREE.Vector2(window.innerWidth, window.innerHeight), 1.5, 0.4, 0.85);// 6. 建立合成器const composer = new EffectComposer(renderer);composer.setSize(window.innerWidth, window.innerHeight);// 7. 將 UnrealBloomPass 加入合成器const renderScene = new RenderPass(scene, camera);composer.addPass(renderScene);composer.addPass(bloomPass);// 8. 渲染場景function animate() { requestAnimationFrame(animate); // 將場景渲染到合成器 composer.render();}animate(); 效果如下： 進階應用-部分物體渲染以上一篇 Three.js 3D Library (2) 模型實作 接續實作，使用 UnrealBloomPass 搭配 Shader（著色器） 來實現部分區塊發光效果 那麼就開始實作吧！首先調整步驟如下： 建立場景 建立相機 建立渲染器 建立物體 建立光源 建立 UnrealBloomPass 物件 建立 bloom 合成器 將 UnrealBloomPass 加入合成器 建立 ShaderPass，並設定自定義著色器 建立著色器的合成器 將 ShaderPass 加入合成器 合成器渲染場景 監聽螢幕縮放 RWD 建立場景/相機/渲染器/物體/光源前一篇已介紹過，這裡簡單帶過 場景背景色必須調整為黑色，否則會受發光效果影響 const scene = new THREE.Scene();scene.background = new THREE.Color(0x000000); // 背景色 相機const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);camera.position.set(120, 120, 120); // 相機位置camera.lookAt(scene.position); // 相機焦點 渲染器const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });renderer.setSize(window.innerWidth, window.innerHeight);document.getElementById('container').appendChild(renderer.domElement); 物體 行星體 球型體 行星環（後續加入發光效果） 群星背景 了呈現行星環發光效果，將圖層（Layer）設為 1（預設為 0）：ring.layers.enable(1) // 行星體-球形體const sphereGeometry = new THREE.IcosahedronGeometry(20, 1);const sphereMaterial = new THREE.MeshPhongMaterial({ color: 0xffffff, emissive: 0x000000, specular: 0xffffff, shininess: 100, flatShading: true});const sphere = new THREE.Mesh(sphereGeometry, sphereMaterial);// 行星體-行星環const RingGeometry = new THREE.RingGeometry(42, 28, 30, 30);// 調整為 MeshBasicMaterial，只設定隨機顏色，後續會加入發光效果const color = new THREE.Color().setRGB(Math.random(), Math.random(), Math.random());const RingMaterial = new THREE.MeshBasicMaterial({ color: color });const ring = new THREE.Mesh(RingGeometry, RingMaterial);ring.layers.enable(1);ring.rotation.x = THREE.MathUtils.degToRad(90);// 組合行星體const planet = new THREE.Group();planet.add(sphere, ring);planet.rotation.x = THREE.MathUtils.degToRad(-30);planet.rotation.y = THREE.MathUtils.degToRad(-10);scene.add(planet);// 群星背景const geometry = new THREE.BufferGeometry();const particleAmount = 2000; // 群星數const vertices = [];for (let i = 0; i &lt; particleAmount; i++) { const x = 2000 * Math.random() - 1000; const y = 2000 * Math.random() - 1000; const z = 2000 * Math.random() - 1000; vertices.push(x, y, z);}geometry.setAttribute('position', new THREE.Float32BufferAttribute(vertices, 3));const particleTexture = new THREE.TextureLoader().load('https://i.imgur.com/9TwBBHH.png');const material = new THREE.PointsMaterial({ size: 5, sizeAttenuation: true, map: particleTexture, transparent: true, alphaTest: 0.5, color: 0xf3f3af });const particles = new THREE.Points(geometry, material);scene.add(particles); 光源// 環境光const ambientLight = new THREE.AmbientLight(0x222222);// 點光源const pointLight = new THREE.PointLight(0x777777, 1, 0);pointLight.position.set(100, 100, 0);// 聚光燈const spotLight = new THREE.SpotLight(0xffffff, 3, 150, Math.PI / 15, 1, 1);spotLight.position.set(50, 100, -80);spotLight.castShadow = true;spotLight.shadow.mapSize.width = 1024;spotLight.shadow.mapSize.height = 1024;spotLight.shadow.camera.near = 10;spotLight.shadow.camera.far = 200;spotLight.shadow.focus = 1;scene.add(ambientLight, pointLight, spotLight); 建立 UnrealBloomPass 物件const bloomPass = new UnrealBloomPass( new THREE.Vector2(window.innerWidth, window.innerHeight), 3, // 強度 0.5, // 射散 0 // 縮放); 建立 bloom 合成器renderToScreen 必須先設定為 false，待 ShaderPass 執行 render 時再一起渲染 const bloomComposer = new EffectComposer(renderer);bloomComposer.renderToScreen = false; renderToScreen 是後製效果的選項之一，設定為 true 時，渲染結果將直接渲染到螢幕上；設定為 false 時，則渲染到目標紋理上，預設為 true 將 UnrealBloomPass 加入合成器將前面新增的 UnrealBloomPass 物件跟 RenderPass 加入合成器 bloomComposer.addPass(new RenderPass(scene, camera));bloomComposer.addPass(bloomPass); 建立 ShaderPass，並設定自定義著色器ShaderPass 為渲染過程中應用自定義著色器效果的後製通道（Post-processing Pass）。 步驟如下： 定義 ShaderMaterial 將 ShaderMaterial 加入 ShaderPass ShaderMaterial 可以定義著色器材質類型，用 GLSL（OpenGL Shading Language Language）語言編寫 Uniforms、頂點著色器（Vertex Shader）以及片段著色器（Fragment Shader） Uniforms用於將外部變數（例如紋理、時間等）傳遞給 Shader Shader 著色器WebGL 組成中包含著色器，基本上包含頂點著色器（Vertex Shader）及片段著色器（Fragment Shader） 頂點著色器（Vertex Shader） 負責場景中頂點的運算，將頂點從模型空間（Model Space）轉換到螢幕空間（Screen Space） 片段著色器（Fragment Shader） 對頂點處理生成的片元（像素）進行處理，例如材質貼圖、光照計算、透明度計算等，並生成最終的像素顏色 const shaderMaterial = new THREE.ShaderMaterial({ uniforms: { baseTexture: { value: null }, // base 紋理 bloomTexture: { value: bloomComposer.renderTarget2.texture } // bloom 紋理 }, vertexShader: ` varying vec2 vUv; void main() { vUv = uv; gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0); } `, fragmentShader: ` uniform sampler2D baseTexture; uniform sampler2D bloomTexture; varying vec2 vUv; // 紋理座標 void main() { // 輸出最終顏色 gl_FragColor = texture2D(baseTexture, vUv) + vec4(1.0) * texture2D(bloomTexture, vUv); } `});const finalPass = new ShaderPass(shaderMaterial, 'baseTexture'); 建立 Shader 合成器const finalComposer = new EffectComposer(renderer); 將 ShaderPass 加入合成器finalComposer.addPass(new RenderPass(scene, camera));finalComposer.addPass(finalPass); 合成器渲染場景建立一個圖層物件，並將圖層設定為 1（預設為 0），後面用來檢核使用 const bloomLayer = new THREE.Layers();bloomLayer.set(1); 利用 bloomLayer 判斷圖層是否為 1，前面行星環圖層設定為 1（ring.layers.enable(1)），因此除了行星環之外的物體，都設定為黑色（color: 0x000000） const materials = [];const darkenMaterial = obj =&gt; { if (!bloomLayer.test(obj.layers)) { materials[obj.uuid] = obj.material obj.material = new THREE.MeshBasicMaterial({ color: 0x000000 }) }}; 將暫時設定為黑色的物體還原為初始值 const restoreMaterial = obj =&gt; { if (materials[obj.uuid]) { obj.material = materials[obj.uuid] delete materials[obj.uuid] }}; 執行渲染，步驟如下： scene.traverse(darkenMaterial)：scene.traverse 是一個 callback 函式，第一個參數帶入物體本身，執行 darkenMaterial() 將行星環外的物體設定為黑色 bloomComposer.render()：發光效果合成器渲染，因前一步驟將行星環外的物體設定為黑色，因此只有行星環會呈現發光效果，前面提到 bloomComposer.renderToScreen 設定為 false，將效果先渲染到紋理上 scene.traverse(restoreMaterial)：將暫時設定為黑色的物體還原為初始值 finalComposer.render()：ShaderPass 合成器渲染，將效果渲染到螢幕上（包含發光效果） const animate = () =&gt; { requestAnimationFrame(animate); sphere.rotation.y += 0.01; scene.traverse(darkenMaterial); bloomComposer.render(); scene.traverse(restoreMaterial); finalComposer.render();};animate(); 監聽螢幕縮放 RWD將 bloomComposer 跟 finalComposer 加入監聽 window.addEventListener('resize', () =&gt; { camera.aspect = window.innerWidth / window.innerHeight camera.updateProjectionMatrix() renderer.setSize(window.innerWidth, window.innerHeight) bloomComposer.setSize(window.innerWidth, window.innerHeight) finalComposer.setSize(window.innerWidth, window.innerHeight)}); 完整範例程式碼 See the Pen Three.js-UnrealBloomPass by Claire Chang (@claire-chang-the-bashful) on CodePen. 參考資源： https://ithelp.ithome.com.tw/users/20107572/ironman/1782 https://threejs.org/ https://threejs.org/examples/?q=bloom#webgl_postprocessing_unreal_bloom_selective","link":"/2023/04/15/javascript/js-threejs-unrealbloompass/"},{"title":"Javascript Web Share API- Navigator.share 分享網頁內容","text":"手機 App 可以透過原生介面實現分享功能，而 Web Share API 可以協助我們在 Android 或 IOS 網頁上做到類似像 App 的分享功能，主要是透過作業系統原生介面分享，可以輕鬆地將內容分享至第三方平台（Facebook、Twitter、Line…），分享內容可以為連結、文字或是檔案。 方法介紹Navigator.share()回傳一個 Promise 函式，可以捕捉成功 / 失敗結果，需透過按鈕 click 等 UI 事件來觸發 Navigator.canShare()回傳 Boolean，用以判斷內容是否可以分享 使用限制 必須透過 HTTPS（secure contexts）連結網站 必須透過 UI 事件觸發，像是按鈕 click 瀏覽器支援度較低（caniuse-Web-Share-API） Navigator.share 參數選擇 url：分享的連結（String） title：分享的標題（String） text：分享的內文（String） files：分享的檔案（Array） 功能實作連結、文字分享&lt;button type=\"button\" id=\"share-btn\"&gt;分享&lt;/button&gt; 因瀏覽器支援度較低，建議加上判斷 Navigator.share 是否存在，避免直接報錯 const btn = document.querySelector('#share-btn');btn.addEventListener('click', async () =&gt; { try { if (!navigator.share) { return; } await navigator.share({ title: 'Title', text: 'Share Content', url: 'https://xxx.com' }) } catch (err) { console.log(err.message); }}); 檔案分享&lt;input type=\"file\" id=\"file-input\" accept=\"image/*\" /&gt;&lt;button type=\"button\" id=\"share-btn\"&gt;分享&lt;/button&gt; 先判斷檔案是否能共享，使用 Navigator.canShare，如果回傳 true，表示 Navigator.share 可以成功呼叫 const btn = document.querySelector('#share-btn');const input = document.querySelector('#file-input');btn.addEventListener('click', async () =&gt; { try { const files = input.files; if (!files.length || !navigator.canShare || !navigator.canShare({ files })) { return; } await navigator.share({ files, title: 'Image', text: 'Share Content' }) } catch (err) { console.log(err.message); }}); 範例畫面 See the Pen Web Share API：Navigator.share by Claire Chang (@claire-chang-the-bashful) on CodePen. 參考文章： https://developer.mozilla.org/en-US/docs/Web/API/Navigator/sharehttps://web.dev/web-share/","link":"/2023/02/22/javascript/js-web-share-api/"},{"title":"透過 NVM 管理多版本 Node.js（MacOS）","text":"NVM（Node Version Manager）為 Node.js 版本管理工具。 每個專案開發可能會搭配不同的 Node.js 版本，版本差異會導致編譯或開發發生問題，因此常常需要來回進行版本切換，而 NVM 最大的用途是可以輕鬆切換 Node.js 版本。 安裝 NVM打開「Terminal 終端機」輸入指令安裝 NVM（v0.39.3 為版本號） curl -o- https://raw.githubusercontent.com/nvm-sh/nvm/v0.39.3/install.sh | bash 如果我們是使用其他的 shell 指令工具，輸入 nvm 可能會報錯，像是： zsh: command not found: nvm shell：命令解析器，讓使用者透過終端機跟作業系統核心做溝通，而 bash 跟 zsh 是 shell 指令工具 發生錯誤需要手動設定，bash 跟 zsh 兩種指令工具則一： bash在根目錄檢查是否有 .bash_profile 檔案（為隱藏檔案，輸入 shift + command + . 可以顯示隱藏檔），如果沒有使用指令手動建立 touch ~/.bash_profile 接下來打開檔案加入程式碼 export NVM_DIR=\"$HOME/.nvm\"[ -s \"$NVM_DIR/nvm.sh\" ] &amp;&amp; \\. \"$NVM_DIR/nvm.sh\" # This loads nvm[ -s \"$NVM_DIR/bash_completion\" ] &amp;&amp; \\. \"$NVM_DIR/bash_completion\" # This loads nvm bash_completion 接著輸入 nvm 取得以下內容代表安裝成功 Node Version Manager (v0.39.3)Note: &lt;version&gt; refers to any version-like string nvm understands. This includes: - full or partial version numbers, starting with an optional \"v\" (0.10, v0.1.2, v1) - default (built-in) aliases: node, stable, unstable, iojs, system - custom aliases you define with `nvm alias foo` Any options that produce colorized output should respect the `--no-colors` option.Usage: nvm --help Show this message --no-colors Suppress colored output nvm --version Print out the installed version of nvm nvm install [&lt;version&gt;] Download and install a &lt;version&gt;. Uses .nvmrc if available and version is omitted. The following optional arguments, if provided, must appear directly after `nvm install`:... zsh在根目錄檢查是否有 .zshrc 檔案（為隱藏檔案），如果沒有使用指令手動建立 touch ~/.zshrc 接下來打開檔案加入程式碼 export NVM_DIR=\"$HOME/.nvm\"[ -s \"$NVM_DIR/nvm.sh\" ] &amp;&amp; \\. \"$NVM_DIR/nvm.sh\" # This loads nvm[ -s \"$NVM_DIR/bash_completion\" ] &amp;&amp; \\. \"$NVM_DIR/bash_completion\" # This loads nvm bash_completion NVM 相關指令 nvm ls-remote：當前可用的遠端 Node.js 版本 nvm list：本機安裝的 Node.js 版本 nvm install ：安裝特定版本 Node.js nvm alias default ：命令列預設使用 Node.js 版本 nvm use ：當前命令列使用 Node.js 版本 透過 NVM 安裝多版本 Node.js執行 nvm ls-remote 可以看到如下（截取片段） ...v14.11.0v14.12.0v14.13.0v14.13.1v14.14.0v14.15.0 (LTS: Fermium)v14.15.1 (LTS: Fermium)v14.15.2 (LTS: Fermium)v14.15.3 (LTS: Fermium)...v14.20.1 (LTS: Fermium)v14.21.0 (LTS: Fermium)v14.21.1 (LTS: Fermium)v14.21.2 (LTS: Fermium)v14.21.3 (Latest LTS: Fermium)v15.0.0v15.0.1v15.1.0... 挑選版本時建議安裝 LTS（長期支援）版本 假設想同時安裝 v14 跟 v16，供不同專案使用，該如何做： 1. 安裝 Node.js nvm install 14nvm install 16 2. 指定預設版本 nvm alias default 14 透過 nvm list 查看本機安裝版本 3. 專案切換版本 特定專案版本切換 nvm use 16 參考文章： https://ithelp.ithome.com.tw/articles/10261849 https://www.casper.tw/development/2022/01/10/install-nvm/","link":"/2023/02/18/node/node-nvm/"},{"title":"Nuxt.js 搭配 Axios 與自訂 Error Page","text":"版本：nuxt 2.15.8 Axios 是一套相當便利的 Promise Base Ajax 套件，而 Nuxt 又有 Axios 整合套件 @nuxtjs/axios，此篇範例會使用到 Async、Await，如果對於 Promise 尚不熟悉，可以參考 Promise 介紹文章 那們我們就來替專案加上 axios 吧！首先執行 npm install @nuxtjs/axios 接著在 nuxt.config.js 進行配置（參數選項）： // nuxt.config.jsexportdefault { modules: [ '@nuxtjs/axios' ], axios: { baseUrl: process.env.SERVER_URL, browserBaseURL: process.env.BASE_URL, credentials: true }} 如果需要區分 client 跟 server 端 base url，可以另外設定 browserBaseURL（於client 端會覆寫 baseUrl），套件將 axios 方法直接 注入(inject) 至 Vue 實例，擷取套件原始碼片段 // node_modules/@nuxtjs/axios/lib/plugin.js// Inject axios to the context as $axiosctx.$axios = axiosinject('axios', axios) 因此在 Vue 生命週期或屬性使用 this.$axios 即可呼叫 axios 方法，那麽在 Nuxt 生命週期呢？ Nuxt 生命週期（asyncData, fetch, plugins, middleware）會自動帶入 context 參數，context 包含以下參數 / 物件： const { $axios app, store, route, params, query, env, isDev, isHMR, redirect, error, $config} = context 使用方式如下（範例使用 asyncData） // pages/about.vueexport default { async asyncData(context) { const { seo } = await context.$axios.$get('/api/seo'); return { seo }; }} 我們也可以物件解構方式使用 $axios // pages/about.vueexport default { async asyncData({ $axios }) { const { seo } = await $axios.$get('/api/seo'); return { seo }; }} axios 提供以下方法進行事件捕捉： onRequest(config) onResponse(response) onError(err) onRequestError(err) onResponseError(err) 如果我們想要全域註冊攔截器(Interceptors) 進行 api 請求或是錯誤捕捉，也很簡單， 首先在 plugins 新增檔案，這裡命名為 axios.js，接著在裡面監聽想捕捉的事件方法 // plugins/axios.jsexport default ({ $axios, redirect, store }) =&gt; { $axios.onRequest(config =&gt; { console.log('on request', config.url); }); $axios.onError(error =&gt; { const code = parseInt(error.response &amp;&amp; error.response.status); if (code === 401) { redirect('/login'); } });}; 接著在 nuxt.config.js plugins 進行擴充 // nuxt.config.jsexport default { plugins: [ { src: '@/plugins/axios' } ]} axios 在發生錯誤時，預設會導到 error page，如果我們想避免畫面跳轉，可以加入 resolve promise，這樣在發生錯誤時，都不會跳轉到 error page // plugins/axios.jsexport default ({ $axios, redirect, store }) =&gt; { $axios.onError(error =&gt; { const code = parseInt(error.response &amp;&amp; error.response.status); if (code === 401) { redirect('/login'); } return Promise.resolve(false); // 避免畫面轉導錯誤頁 });}; 如果全域設定 resolve promise，在 axios 發生錯誤時，都不會進到 catch error 歐！ 自訂 Error Page Nuxt 專案有預設的 error page，可以在 .nuxt 資料夾看到 components/nuxt-error.vue，錯誤頁面也可以自訂，檔案放置位置比較特別，在 layouts 資料夾內新增一支檔案 error.vue // layouts/error.vue&lt;template&gt; &lt;div class=\"nuxt-error-wrap\"&gt; &lt;div class=\"text-center py-4\"&gt; &lt;h2&gt;{{ error.statusCode }}&lt;/h2&gt; &lt;h3&gt;{{ error.message }}&lt;/h3&gt; &lt;/div&gt; &lt;nuxt-link to=\"/\" class=\"btn btn-primary p-4\"&gt;回首頁&lt;/nuxt-link&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;export default { name: 'ErrorPage', layout: 'error-layout', props: { error: { type: Object, default: () =&gt; {} } }};&lt;/script&gt; 雖然 error.vue 檔置於 layouts 資料夾，但視為 pages 頁面，因此如果沒有配置 layout，預設會讀取 layouts/default.vue 樣板 這樣就完成了，在 Nuxt 發生錯誤時，都會進到我們自訂錯誤頁面，如果要手動進到錯誤頁，呼叫 context 內的 error 方法即可，在 Nuxt 生命週期： // pages/about.vueexport default { async asyncData({ $axios, error }) { try { const { seo } = await $axios.$get('/api/seo'); return { seo }; } catch(err) { const { statusCode, message } = err; error({ statusCode, message }); } }} 在 Vue 生命週期或屬性，使用 this.$nuxt.error() 就可以囉！ // pages/about.vueexport default { methods: { async getSeo() { try { const { seo } = await this.$axios.$get('/api/seo'); this.seo = seo; } catch(err) { const { statusCode, message } = err; this.$nuxt.error({ statusCode, message }); } } }} 參考文章： https://ithelp.ithome.com.tw/articles/10208852 https://mavrickmaster.medium.com/custom-error-pages-with-nuxt-js-3c70e6c51aff","link":"/2022/11/21/nuxt/nuxt-axios/"},{"title":"Nuxt.js 套件應用：Bootstrap 5 搭配 SCSS 打造網頁 UI","text":"版本：nuxt 2.15.8 Bootstrap 是一款相當熱門的前端開發工具，可以幫助我們快速的設計跟自訂 RWD 網站，過去 Bootstrap 相依於 jQuery 開發，Bootstrap 5 不需使用 jQuery，新增 Utilities API，可以更簡易的管理或擴充樣式，讓程式碼更輕量，另外也新增了 Bootstrap Icons 供免費使用。 透過 create-nuxt-app 建置 Nuxt.js 專案時，雖然可以選擇 CSS 模板（UI framework），但選項內並沒有 Bootstrap （Bootstrap Vue 搭配的是 Bootstrap 4.5），因此需手動安裝。 搭配 SCSS 開發需要安裝 sass loader，執行： npm i --save-dev sass sass-loader@10 接著安裝 Bootstrap： npm i --save bootstrap @popperjs/core 新增兩個檔案（檔名自訂）： plugins/bootstrap.js：用來設定動態功能 assets/scss/app.scss：用來配置樣式 然後至 nuxt.config.js 加入檔案： // nuxt.config.jsexport default { css: [ { src: '@/assets/scss/app.scss', lang: 'scss' } ], plugins: [ { src: '@/plugins/bootstrap', mode: 'client' } ]} CSS 設定不建議直接引入 ~bootstrap/scss/bootstrap ，選擇需要的樣式引入即可，避免 css 檔案過大，造成系統負擔 需注意引入的順序： // assets/scss/app.scss// 1. 引入 functions，才能操控顏色, svg, calc...@import \"~bootstrap/scss/functions\";// 2. 自訂變數，會覆蓋 bootstrap 的變數@import \"./variables\";// 3. 引入 variables, mixins, root@import \"~bootstrap/scss/variables\";@import \"~bootstrap/scss/mixins\";@import \"~bootstrap/scss/root\";// 4. 引入 utilities@import \"~bootstrap/scss/utilities\";// 5. 自訂 utilities@import \"./utilities\";// 6. 引入需要的 bootstrap components@import \"~bootstrap/scss/reboot\";@import \"~bootstrap/scss/type\";@import \"~bootstrap/scss/images\";@import \"~bootstrap/scss/containers\";@import \"~bootstrap/scss/grid\";@import \"~bootstrap/scss/tables\";@import \"~bootstrap/scss/forms\";@import \"~bootstrap/scss/buttons\";@import \"~bootstrap/scss/helpers\";// ...// 7. 使用 utilities 需引入 utilities api（將 sass map 轉換為 utility classes）@import \"~bootstrap/scss/utilities/api\";// 8. 客製樣式置於最後，覆蓋前面的樣式@import \"./style\"; 想要了解如何使用 utilities 客製樣式，可以參考 這篇文章 Javascript 設定// plugins/bootstrap.jsimport Vue from 'vue';import * as bootstrap from 'bootstrap';const { Modal, Collapse } = bootstrap;// 避免重複註冊，在 Vue 實體內加入參數判斷if (!Vue.__bootstrap_mixin__) { Vue.__bootstrap_mixin__ = true; Vue.mixin({ methods: { bootstrapModal(element) { return new Modal(element); }, bootstrapCollapse(element) { return new Collapse(element); } } });} 將需使用到的功能（EX：Modal, Collapse）透過 mixin 註冊到 Vue 實體，這樣在 .vue 檔內就可以直接使用。 範例說明如何在頁面上（pages/about.vue）操控元件（components/modal.vue），讓 Modal 開啟： // components/modal.vue&lt;template&gt; &lt;div class=\"modal fade\" tabindex=\"-1\"&gt; &lt;div class=\"modal-dialog\"&gt; &lt;div class=\"modal-content\"&gt; &lt;div class=\"modal-header\"&gt; &lt;h5&gt;Modal Title&lt;/h5&gt; &lt;button type=\"button\" class=\"btn-close\" data-bs-dismiss=\"modal\" aria-label=\"Close\"&gt;&lt;/button&gt; &lt;/div&gt; &lt;div class=\"modal-body\"&gt; ... &lt;/div&gt; &lt;div class=\"modal-footer\"&gt; &lt;button type=\"button\" class=\"btn btn-outline-secondary\" data-bs-dismiss=\"modal\"&gt;&lt;/button&gt; &lt;button type=\"button\" class=\"btn btn-secondary\"&gt;確定&lt;/button&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;export default { name: 'Modal'}&lt;/script&gt; // pages/about.vue&lt;template&gt; &lt;h2&gt;關於我們&lt;/h2&gt; &lt;Modal ref=\"modal\" /&gt; &lt;button type=\"button\" class=\"btn btn-primary\" @click=\"openModal()\"&gt;開啟 Modal&lt;/button&gt;&lt;/template&gt;&lt;script&gt;import Modal from '@/components/Modal';export default { name: 'About', components: { Modal }, data() { return { modal: '' } }, mounted() { // 操控內層元件，需指定 this.$refs.modal 內的 $el this.modal = this.bootstrapModal(this.$refs.modal.$el); }, methods: { openModal() { this.modal.show(); } }};&lt;/script&gt; 參考文章： https://getbootstrap.com/ https://easonchang0115.github.io/blogs/other/2021/20210530_1.html https://stackoverflow.com/questions/71432924/vuejs-3-and-bootstrap-5-modal-reusable-component-show-programmatically","link":"/2022/12/22/nuxt/nuxt-bootstrap5/"},{"title":"Nuxt.js 目錄結構","text":"版本：nuxt 2.15.8 使用 create-nuxt-app 安裝完成後，可以看到以下的資料夾結構： assets, layouts, middleware, mixins, plugins 以上資料夾在當前版本是需要手動建置的， 依照順序介紹各資料夾功能： assets跟 Vue 專案相同，用來存放像是 css, scss, images 需要被 webpack 編譯的靜態資源，如不需被編譯，則存放於 static。 components自訂的元件檔，例如我們常會建立共用的 Navbar.vue, Sidebar.vue …，通常為大寫命名，然後在需要的頁面引入該檔案即可使用，使用方式基本上跟 Vue 專案相同。 如果不想要個別引入元件，Nuxt 也有提供很便利的作法，只要在 nuxt.config.js 檔內設定： // nuxt.config.jsexport default { components: true} 就會全局引入元件，使用方式只要遵循資料夾結構輸入元件名稱就可以了 範例： 元件路徑：components/home/Banner.vue 使用元件：&lt;HomeBanner&gt;&lt;/HomeBanner&gt; layouts共用模板。 大家還記得在 Vue 專案下，只要在 App.vue，或是在 router 建立一個巢狀路由，外層設定共用容器，再將嵌套路由放入 children，子路由就可以共享外層模板 export default [ { path: '/products', component: Product, children: [ { path: 'food', component: Food }, { path: 'drink', component: Drink } ] }] 但是在 Nuxt 架構下，並不存在 App.vue 這隻檔案，router 也會自動配置，那該怎麼做到模板共用呢？其實很簡單，只要在 layouts 資料夾內，新增 default.vue 檔，預設所有 pages 內的檔案都會共享該版面 // default.vue&lt;template&gt; &lt;div class=\"default-wrap\"&gt; &lt;Navbar /&gt; &lt;Nuxt /&gt; &lt;Footer /&gt; &lt;/div&gt;&lt;/template&gt; &lt;Nuxt /&gt; 類似 Vue 的 &lt;router-view /&gt; （嵌套路由） 如果想要新增更多模板，只要在 layouts 內新增檔案，例如 layouts/products.vue，在欲使用的頁面引入，該頁就可以讀到 layouts/products.vue 模板 // pages/food.vueexport default { layout: 'products'} middleware前面有說到 Nuxt 專案會自動依 pages 內的資料夾結構產生對應的靜態/動態路由， 但如果說我們想要使用 路由守衛(Navigation Guards) 來進行路由監聽，像是 Vue router 內的 beforeEach callback，該怎麼做呢？ Vue 專案：// pages/food.vueconst router = new VueRouter({ mode: 'history', routes});router.beforeEach(async (to, from, next) =&gt; { if (!store.permissions.includes(route.path)) { next({ statusCode: 403 }); } next();});export default router; Nuxt 專案：我們可以手動建立一個 middleware 資料夾，在裡面新增要進行路由監聽的檔案 routeAuth.js // middleware/routeAuth.jsexport default ({ from, route, redirect, store, error }) =&gt; { if (!store.isLogin) { redirect('/login'); } if (!store.permissions.includes(route.path)) { error({ statusCode: 403 }); }}; 然後在需要進行監聽的檔案加入 middleware // layouts/default.vueexport default { middleware: 'routeAuth', data() { return {}; }} 或是在 nuxt.config.js 設定全域監聽 // nuxt.config.jsexport default { router: { middleware: [ 'routeAuth' ] }} mixinsmixins 提供彈性方式讓頁面可以重複使用方法，可以包含任何 Vue 組件項目(data, computed, watch, 生命週期)，將共用方法包裝進去，首先在 mixins 新增檔案 mixins/utils.js // mixins/utils.jsexport default { data() { return { number: 0 }; } methods: { count() { this.number++; } }}; 全域註冊：全域宣告 mixin 務必小心使用，因為會影響到所有 Vue 檔(pages, components) 在 mixins 新增一支檔案 global-mixins.js，將欲全域註冊的檔案加入 Vue 實例 // mixins/global-mixins.jsimport Vue from 'vue';import utils from '@/mixins/utils';// 避免重複註冊if (!Vue.__utils_mixin__) { Vue.__utils_mixin__ = true; Vue.mixin(utils);} 接著加入 nuxt.config.js 內 // nuxt.config.jsexport default { plugins:[ { src: '@/mixins/global-mixins' } ]} 局部註冊：局部註冊很簡單，只要在欲使用檔案引入即可，這裡假設在 pages/about.vue // pages/about.vueimport utils from '@/mixins/utils';export default { name: 'About', mixins:[ utils ]} 這樣在 About 頁面就可以取得參數 number 的值跟呼叫 count() 方法囉！ pages主要的頁面檔案，Nuxt 專案會自動依照 pages 內的資料夾結構配置路由， 換句話說，就不需要像 Vue 專案一樣需要自行設定 vue-router，為小寫命名（命名會直接是路徑名稱），每個 .vue 檔都是已經被註冊的頁面 以首頁為例：pages/index.vue → http://localhost:3000 巢狀路由： 直接舉例，先建立一支檔案 pages/about.vue // pages/about/index.vue&lt;template&gt; &lt;div&gt; about： &lt;nuxt-child /&gt; &lt;/div&gt;&lt;/template&gt; 接在 about 資料夾新增兩隻檔案，可取得配置的巢狀路徑如下 pages/about/index.vue → http://localhost:3000/about pages/about/claire.vue → http://localhost:3000/about/claire 動態路由： 如果想要顯示動態路由，只要在檔名前加上下底線就可以了： pages/about/ _name.vue → http://localhost:3000/about/claire 這樣就可以在檔案內取得動態路由參數 // pages/about/_name.vueexport default { created () { console.log(this.$route.params.name); }} pluginsNuxt 插件，於 Vue.js 執行前引入第三方套件，以 vue-notification 為例 首先使用 npm 安裝 npm i vue-notification 然後在 plugins 資料夾新增 notification.js 檔 // plugins/notification.jsimport Vue from 'vue';import Notifications from 'vue-notification';Vue.use(Notifications); 在 nuxt.config.js 配置 plugins // nuxt.config.jsexport default { plugins: [ { src: '@/plugins/notification.js' } ]} 就可以在所有頁面中使用該套件 &lt;Notifications&gt;&lt;/Notifications&gt; static靜態資源資料夾，用來存放不需要被編譯的檔案，像是圖片檔，或是可以供使用者下載的範例檔等，如需被編譯，則存放於 assets。 store放置 Vuex 狀態管理工具，用來存放全域共用的方法、資料，使用方式與 Vue 大致相同，Vuex 在使用時會碰到一個問題，當頁面重新整理，其會被還原為初始狀態，至於要怎麼解決這個問題，後續會單獨介紹。 參考文章： https://israynotarray.com/vue/20211011/3406447097/ https://dev.to/husteadrobert/how-to-use-global-navigation-guards-with-nuxt-middleware-and-why-you-absolutely-should-not-7bl https://ithelp.ithome.com.tw/articles/10207822 https://medium.com/@seyijosh44/how-to-use-mixins-in-nuxt-js-826724fa251","link":"/2022/11/17/nuxt/nuxt-catalog/"},{"title":"Nuxt.js 套件應用：CKEditor 5 文字編輯器","text":"版本：nuxt 2.15.8ckeditor: 38.0.1 CKEditor 是一套歷史悠久且功能完整、輕量的富文本編輯器（rich text editor），為使用者提供所見即所得（WYSIWYG）的編輯區域，CKEditor 5 與舊版不同，使用 MVC 架構、ES6 編寫、UI 簡潔，且因應現在的前後端分離趨勢，與前端框架 React、Angular、and Vue.js 做整合，讓我們可以更便利的開發應用。 那麼我們就開始在 Nuxt 專案使用 CKEditor 5 吧，首先選擇編輯器類型（這裡使用 Classic editor），可以透過兩種方式安裝： Adding a plugin to a build如果我們想要直接使用 Classic editor 配置好的功能，不需額外擴充，此方法可以快速簡易的建置，首先安裝套件： npm install --save \\ @ckeditor/ckeditor5-vue2 \\ @ckeditor/ckeditor5-build-classic 接著在元件內加入編輯器 &lt;template&gt; &lt;div&gt; &lt;ckeditor :editor=\"editor\" v-model=\"editorData\"&gt;&lt;/ckeditor&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;import CKEditor from '@ckeditor/ckeditor5-vue2';import ClassicEditor from '@ckeditor/ckeditor5-build-classic';export default { name: 'Editor', components: { ckeditor: CKEditor.component }, data() { return { editor: ClassicEditor, editorData: '&lt;div&gt;Hello World!&lt;/div&gt;' }; }};&lt;/script&gt; 這樣就完成了，是不是很簡單呢！ 但如果我們想擴充功能，像是新增下底線 @ckeditor/ckeditor5-basic-styles/src/underline，專案會直接報錯： Uncaught CKEditorError: ckeditor-duplicated-modules 原因是 @ckeditor/ckeditor5-build-classic 為包裝好的內容，試著進到 node_modules/@ckeditor/ckeditor5-build-classic/package.json 可以看到相依套件已經安裝進去： 因此 CKeditor 在初始化時會因為模組重複執行導致錯誤，可以改用以下方法 Adding a plugin to an editor客製化配置所有功能，步驟相對複雜，首先安裝基本套件： npm install --save \\ @ckeditor/ckeditor5-vue2 \\ @ckeditor/ckeditor5-editor-classic \\ @ckeditor/ckeditor5-dev-webpack-plugin \\ @ckeditor/ckeditor5-dev-utils \\ @ckeditor/ckeditor5-theme-lark \\ postcss@8 \\ postcss-loader@4 \\ raw-loader@4 重點步驟：需手動設定 webpack，這一步漏掉會直接報錯 // nuxt.config.jsconst path = require('path');const CKEditorWebpackPlugin = require('@ckeditor/ckeditor5-dev-webpack-plugin');const { styles } = require('@ckeditor/ckeditor5-dev-utils');export default { build: { transpile: [ /ckeditor5-[^/\\\\]+[/\\\\]src[/\\\\].+\\.js$/ ], plugins: [ // Only with ssr: false new CKEditorWebpackPlugin({ // See https://ckeditor.com/docs/ckeditor5/latest/features/ui-language.html language: 'zh', additionalLanguages: 'all', addMainLanguageTranslationsToAllAssets: true }) ], // If you don't add postcss, the CKEditor css will not work. postcss: { postcssOptions: styles.getPostCssConfig({ themeImporter: { themePath: require.resolve('@ckeditor/ckeditor5-theme-lark') }, minify: true }) }, extend(config) { // If you do not exclude and use raw-loader to load svg, the following errors will be caused. // Cannot read property 'getAttribute' of null const svgRule = config.module.rules.find(item =&gt; { return /svg/.test(item.test); }); svgRule.exclude = [ path.join(__dirname, 'node_modules', '@ckeditor') ]; // add svg to load raw-loader config.module.rules.push({ test: /ckeditor5-[^/\\\\]+[/\\\\]theme[/\\\\]icons[/\\\\][^/\\\\]+\\.svg$/, use: [ 'raw-loader' ] }); } }} webpack 設定說明： 語言設定：這裡設為繁體中文（’zh’） 必須在 ssr: false 條件下才能運作，否則會報錯誤 window is not defined，跟 [CKEditorWebpackPlugin] Error: No translation has been found for the XX language 排除 @ckeditor svg，並使用 raw-loader 讀取 svg 內容，否則會拋 cannot read property ‘getAttribute’ of null 錯誤 使用 PostCSS 轉換 css 代碼，否則會 css 樣式會讀取不到 接著來試著安裝編輯器功能，範例安裝 基本樣式 / 字級 / 字體： npm install --save \\ @ckeditor/ckeditor5-essentials \\ @ckeditor/ckeditor5-font \\ @ckeditor/ckeditor5-paragraph \\ 所有 ckeditor 套件版本必須相同，否則會發生錯誤（@ckeditor/ckeditor5-dev-* 跟 @ckeditor/ckeditor5-vue2 除外） 基礎設定介紹： placeholder：編輯器佔位符 plugins：編輯器應用功能 toolbar：工具列配置，也可以加入分隔符號 | 其他：各功能的相關設定請見官方文件 &lt;template&gt; &lt;div&gt; &lt;ckeditor :editor=\"editor\" :config=\"editorConfig\" v-model=\"editorData\"&gt;&lt;/ckeditor&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;import CKEditor from '@ckeditor/ckeditor5-vue2';import ClassicEditor from '@ckeditor/ckeditor5-editor-classic/src/classiceditor';import Essentials from '@ckeditor/ckeditor5-essentials/src/essentials';import FontFamily from '@ckeditor/ckeditor5-font/src/fontfamily';import FontSize from '@ckeditor/ckeditor5-font/src/fontsize';import Paragraph from '@ckeditor/ckeditor5-paragraph/src/paragraph';export default { name: 'Editor', components: { ckeditor: CKEditor.component }, data() { return { editor: ClassicEditor, editorData: '', editorConfig: { placeholder: '請輸入內容', plugins: [ Essentials, FontFamily, FontSize, Paragraph ], toolbar: { items: [ 'fontSize', 'fontFamily', '|' ], shouldNotGroupWhenFull: true }, fontSize: { options: [ 12, 16, 18, 20, 24, 32, 40, 48 ], supportAllValues: true } } }; }};&lt;/script&gt; 這樣就可以成功看到畫面囉 🙌 是否覺得功能安裝跟配置有點麻煩呢？官方貼心的提供 online-builder ，可以先挑選功能並配置好 toolbar，確認畫面後再安裝 全域註冊當專案有很多地方會使用到編輯器，我們也可以全域引入 新增檔案置於 plugins，這裡命名 ckeditor.js // plugins/ckeditor.jsimport Vue from 'vue';import CKEditor from '@ckeditor/ckeditor5-vue2';Vue.use(CKEditor); nuxt.config.js 配置 // nuxt.config.jsexport default { plugins: [ { src: '@/plugins/ckeditor' } ] } CSS style實務應用上會在後台使用編輯器來設計內容，然後將 HTML 內容儲存到資料庫，於前台取回資料並渲染在畫面上，所以會需要配置相關的 CSS，確保前後台樣式一致。 只要複製 Content styles 在專案內，然後在編輯器內容的外層容器加上 ck-content CSS class 就可以囉，範例如下： &lt;template&gt; &lt;div class=\"ck-content\"&gt; // 編輯器內容 &lt;div v-html=\"content\"&gt;&lt;/div&gt; &lt;/div&gt;&lt;/template&gt; 參考文章： https://github.com/changemyminds/nuxtjs-integrate-ckeditor5?ref=vuejsexamples.comhttps://ithelp.ithome.com.tw/articles/10198816https://medium.com/@charming_rust_oyster_221/ckeditor-5-文字編輯器-研究心得-519c97f20a4https://ckeditor.com/docs/ckeditor5/latest/installation/frameworks/vuejs-v2.html","link":"/2022/12/01/nuxt/nuxt-ckeditor5/"},{"title":"Nuxt.js nuxt.config.js 設定檔","text":"版本：nuxt 2.15.8 全名為 Nuxt configuration file，功能同 Vue 專案內 vue.config.js 檔，如果我們使用 create-nuxt-app 來建置專案，會自動產生這支檔案，在此配置的內容，會全域讀取設定。 接下來介紹一下一些常用的設定： alias路徑別名，大家還記得在 Vue 專案內，如果沒有設定路徑別名，則需要寫相對路徑（例如：../components/Navbar.vue），對於維護和開發都很不方便，一些程式碼檢核工具，甚至會視為 bad smell，因此我們會在 vue.config.js 檔內統一設定路徑別名。 Nuxt 專案很貼心的自動配置了路徑別名，預設值如下 { '~~': `&lt;rootDir&gt;`, '@@': `&lt;rootDir&gt;`, '~': `&lt;srcDir&gt;`, '@': `&lt;srcDir&gt;`, 'assets': `&lt;srcDir&gt;/assets`, // (unless you have set a custom `dir.assets`) 'static': `&lt;srcDir&gt;/static`, // (unless you have set a custom `dir.static`)} 因此在引入元件 Navbar 時可以寫成 @/components/Navbar.vue 如果需要更改配置也可以 import { resolve } from 'path';export default { alias: { 'images': resolve(__dirname, './assets/images'), '@static': resolve(__dirname, './static') }} ssrserver side render，預設為 true，如果不需 SEO，只要 spa 操作，設定 ssr: false 即可 舊版會使用 mode: 'spa' 來進行設定，但官方文件有說明 v2.14.5 版本開始已棄用，改用 ssr: false export default { ssr: false // spa} server用來設定 port（預設 3000） 跟 host（預設 localhost） export default { server: { port: 8000, host: 'my-website' }} router配置 Nuxt 路由（vue-router），這裡以設定 base url 舉例，其他請參考官方文件 export default { router: { base: '/backoffice/' }} head在 Vue 專案，我們要設定 head 內容，只要在 public/index.html 檔設定就好了，但 Nuxt 專案又該怎麼設定呢？ 全域設定在 nuxt.config.js 檔 head 內即可全域設定，通常在建立專案會預先帶入 export default { head: { title: 'test', htmlAttrs: { lang: 'en' }, meta: [ { charset: 'utf-8' }, { name: 'viewport', content: 'width=device-width, initial-scale=1' }, { hid: 'description', name: 'description', content: '' }, { name: 'format-detection', content: 'telephone=no' } ], link: [ { rel: 'icon', type: 'image/x-icon', href: '/favicon.ico' } ] }} 這樣所有頁面都可以讀到 head 設定 單頁設定Nuxt 專案很重要的一點是 SEO 效能優化，基於這點，通常會需要依照各頁設定自己的 SEO，例如pages/about.vue 頁面的 title 和 description 要單獨設定，方法也很簡單 export default { head: { title: '關於我們', meta: [ { hid: 'description', name: 'description', content: '這是關於我們頁面' } ] }} 在各頁面設定的內容優先度較高，會覆寫全域設定的 head 內容，因此當我們開啟 about 頁面，會看到 title 變成 關於我們、description 變成 這是關於我們頁面，其他配置則依照 nuxt.config.js 檔 css引入全域使用的 css 檔，像是外部套件，或是自訂檔，如果要使用 sass，必須安裝 sass-loader npm install --save-dev sass sass-loader export default { css: [ // 外部套件 { src: 'bootstrap-icons/font/bootstrap-icons.css' }, // scss 檔 { src: '@/assets/scss/app.scss', lang: 'scss' } ]} plugins全局引入外部套件，以 vue-notification 舉例，在 plugins 新增 notification.js 檔 // plugins/notification.jsimport Vue from 'vue';import Notifications from 'vue-notification';Vue.use(Notifications); 在 nuxt.config.js 配置 plugins export default { plugins: [ { src: '@/plugins/notification.js' } ]} 就可以在所有頁面中使用該套件 &lt;Notifications&gt;&lt;/Notifications&gt; components如設定為 true，會全局引入元件，使用方式只要遵循資料夾結構輸入元件名稱就可以了 export default { components: true} 範例： 元件路徑：components/home/Banner.vue 使用元件：&lt;HomeBanner&gt;&lt;/HomeBanner&gt; buildModules用來配置只在開發環境使用的模組，註冊在此可以讓專案在生產環境部署速度提升，並減少 node_modules 容量，詳情可以參考各套件的配置建議 @nuxtjs/eslint-module 套件官方建議配置於 buildModules export default { buildModules: [ '@nuxtjs/eslint-module' ]} 使用條件：Nuxt 版本必須大於 v2.9 modules用來配置開發環境與生產環境共用模組，buildModules 及 modules 配置位置詳請參考各套件建議 export default { modules: [ '@nuxtjs/style-resources' ]} styleResources用來注入全域共用 sass, scss，如果不引入，在各頁面（.vue）內的 style 會無法使用像是 mixin 等的常用變數，或是要在各頁面單獨 @import scss 檔 首先必須另外安裝 @nuxtjs/style-resources 套件 執行：npm i @nuxtjs/style-resources 在 nuxt.config.js 檔設定 export default { modules: [ '@nuxtjs/style-resources' ], styleResources: { scss: [ '@/assets/scss/components/_color.scss', '@/assets/scss/components/_mixin.scss' ] }} 這樣就可以達到變數共用了 官方文件 提到，請勿引入實際的 css 樣式，因為每個頁面跟元件都會重複編譯，造成系統極大負擔（筆者踩坑過OQ），建議只注入變數, mixins，因為這些值在編譯後就會消失了。 build客製化 webpack 設定，這裡舉例，在開發時，發現在 Vue 樣板無法使用可選串連 Optional Chaining（es2020語法），研究後發現必須需安裝擴充套件 npm install vue-template-babel-compiler --save-dev 接著在 nuxt.config.js 檔設定，就可以成功使用囉 export default { build: { loaders: { vue: { compiler: require('vue-template-babel-compiler') } } }} LoadingLoading 效果，基礎設定如下（參數選項） export default { loading: { color: 'black', height: '5px', continuous: true }} 如果想自訂更多樣式，也可以包裝成元件後引入 export default { loading: '@/components/TheLoading.vue'} env用來定義全局共用的環境變數，Nuxt 專案預設只有 nuxt.config.js 檔內可以讀取環境變數， 因此如果要讓 .vue 檔或是 .js 檔讀到變數，這裡提供以下兩個做法： 方法一：直接在 nuxt.config.js 檔內配置屬性export default { env: { BASE_URL: process.env.BASE_URL }} 但有時變數多，不想各別配置，可以採用方法二 方法二：安裝套件 @nuxtjs/dotenv執行：npm i @nuxtjs/dotenv，在 modules 內設定： export default { modules: [ '@nuxtjs/dotenv' ]} 這樣就可以全域使用 .env 變數囉。 專案如果有區分開發跟生產環境 .env 檔，也可以設定如下： export default { modules: [ [ '@nuxtjs/dotenv', { filename: `.env.${process.env.ENV}` } ] ]} 使用方法二需注意，變數如果內含變數，會讀取不到第二層的變數（饒口），直接提供範例，假設在 .env 檔內有兩個變數BASE_DOMAIN=my-websitesBASE_URL=\"http://${BASE_DOMAIN}\"在 .vue 檔直接使用 process.env.BASE_URL，取得值為 http://${BASE_DOMAIN}，無法解析成 http://my-websites，此情況還是需搭配方法一使用 參考文章： https://ithelp.ithome.com.tw/articles/10207330 https://nuxtjs.org/docs/configuration-glossary https://hackmd.io/@xq/nuxt-config","link":"/2022/11/19/nuxt/nuxt-config-setting/"},{"title":"Nuxt.js 設定 GA & GTM","text":"版本：nuxt 2.15.8 網站上線後，我們會需要 Google Analytics 和 Google Tag Manager 工具來追蹤分析網站流量，接下來說明如何在 Nuxt.js 專案內加入追蹤碼。 Google Analytics申請代碼： 至 Google Analytics 分析，使用 google 帳戶登入，點選左下角的管理 選擇建立資源 設定資源名稱，選項勾選後，點選建立 選擇資料串流平台：網站 設定網站網址跟串流名稱，接著就新增成功並取得 GA 代碼。 設定代碼：搭配套件 vue-gtag ，執行：npm i vue-gtag@1.16.1 Vue v2.x 需搭配 vue-gtag v1.x 接著我們新增檔案至 plugins，這裡命名為 gtag.js // plugins/gtag.jsimport Vue from 'vue';import VueGtag from 'vue-gtag';Vue.use(VueGtag, { config: { id: 'UA-XXXXXXXXX-X' }}); 配置到 nuxt.config.js // nuxt.config.jsexport default { plugins: [ { src: '@/plugins/gtag.js' } ]} Google Tag Manager申請代碼： 至 Google Tag Manager 代碼管理工具，使用 google 帳戶登入並建立帳戶 設定帳戶名稱（命名一個容易辨識網站的名稱），接著設定容器（GTM 要放入的網域），按下建立，就可以看到新增的容器跟 GTM 代碼囉 設定代碼：搭配套件 @nuxtjs/gtm ，執行：npm i @nuxtjs/gtm，然後配置 nuxt.config.js // nuxt.config.jsexport default { modules: [ '@nuxtjs/gtm', ], gtm: { id: 'GTM-XXXXXXX' }} 預設內容 參考，也可以調整設定 // nuxt.config.jsexport default { modules: [ '@nuxtjs/gtm', ], gtm: { id: 'GTM-XXXXXXX', enabled: true, // for dev mode pageTracking: true }} 如果代碼都是固定的內容，這樣就完成囉～ 不過事情總沒這麼簡單，如果今天專案有後台，GA 跟 GTM 都可供使用者設定，代碼都是變動的參數，又該怎麼做呢？ 整合後端 API 進行代碼設定這裡同時說明 GA 跟 GTM 的配置，首先安裝套件 npm i vue-gtag@1.16.1 npm i @nuxtjs/gtm 由於要串接 API，這裡搭配 @nuxtjs/axios 使用，執行：npm i @nuxtjs/axios 新增 plugins/gtag.js // plugins/gtag.jsimport Vue from 'vue';import VueGtag from 'vue-gtag';export default async ({ $gtm, $axios }) =&gt; { const { gaFour, gtm } = await $axios.$get('/api/ga'); // GA4 Vue.use(VueGtag, { config: { id: gaFour } }); // GTM if (gtm) { $gtm.init(gtm); }}; 配置 nuxt.config.js // nuxt.config.jsexport default { plugins: [ { src: '@/plugins/gtag.js' } ], modules: [ '@nuxtjs/gtm' ], gtm: { enabled: true, pageTracking: true }} 參考文章： https://www.turingdigital.com.tw/blog/install-ga4-property https://www.cyberbiz.io/support/?p=228 https://stackoverflow.com/questions/64612031/setup-google-analytics-4-in-nuxt-js","link":"/2022/12/14/nuxt/nuxt-ga-and-gtm/"},{"title":"Nuxt.js 專案架設","text":"版本：nuxt 2.15.8 說到 Nuxt，必須先從 Vue.js 說起，Vue.js 為專注在視圖層(View) 的 JS 框架，為 SPA（Single Page Application）應用程式，簡而言之整個網站應用只有單一頁面，一但頁面被加載進來後，就不會再進行該頁面請求，由於 Vue 是利用 JS 載入資料，並動態產生元件，SEO 只能抓取到 HTML 內容，因此 SEO 表現趨近於零。 而 Nuxt 是基於 Vue.js、Node.js、Webpack 以及 Badel.js 的輕量框架，可以同時創建 SSR（Server Side Render）及 SPA，在頁面載入前即渲染（伺服器回傳完整 HTML 檔，每次跳轉頁面，瀏覽器都需要刷新），搜尋引擎爬蟲可以取得資料，大幅解決 SEO 的問題。 以下圖片說明： 接下來一起來嘗試創建一個 Nuxt 專案吧！ 如同 Vue CLI，Nuxt 也有類似的指令列(command-line)工具 create-nuxt-app， 依據官方文件提供的專案包建置方式： npx create-nuxt-app &lt;project-name&gt; 使用 npx 安裝，安裝的套件在執行完後就會被移除 npx介紹 接著會跑出一些選項： Project name：設定專案名稱 Programming language：選擇程式語言 Package manager：軟體套件管理系統 npm / yarn UI framework：css 模板 Template engine：樣版引擎 Nuxt.js modules：相依套件 Linting tools：程式碼檢查工具 Testing framework：測試工具 Rendering mode：渲染模式 Deployment target：運行模式 （在此示範 Server Side Render) Development tools：開發工具 Version control system：版控工具 以上選擇完畢就開始安裝專案包，運行完成就可以開始編譯專案，跟著提示訊息執行：cd testnpm run dev 在 package.json 內可以看到相關指令 \"scripts\": { \"dev\": \"nuxt\", \"build\": \"nuxt build\", \"start\": \"nuxt start\", \"generate\": \"nuxt generate\"} 接下來就可以看到畫面囉 👏 參考文章： https://medium.com/web-design-zone/建立nuxt-js專案初體驗-21920735e38b https://levelup.gitconnected.com/spa-ssg-ssr-and-jamstack-a-front-end-acronyms-guide-6add9543f24d","link":"/2022/11/16/nuxt/nuxt-installation/"},{"title":"Nuxt.js Lazy Loading 圖片延遲載入","text":"版本：nuxt 2.15.8 Lazy Loading 是常見的圖片優化技巧，在使用大量圖片的網站尤其適用，可以提升網頁載入速度，節省流量的浪費，Google Lighthouse 也顯示此為有效提升評分的方式，言下之意會影響到 Google 搜索排名，本文介紹如何搭配套件 lazysizes 使用。 引入 lazysizes 套件 執行 npm i lazysizes 接著在 plugins 資料夾新增檔案 lazysizes.js // plugins/lazysizes.jsimport lazySizes from 'lazysizes';export default lazySizes; nuxt.config.js 配置 plugin // nuxt.config.jsexport default { plugins: [ { src: '@/plugins/lazysizes', mode: 'client' } ], build: { extend(config, { _isDev, isClient, loaders: { vue } }) { if (isClient) { vue.transformAssetUrls.img = [ 'data-src', 'src' ]; } } }} Lazy Loading 運用 將 src 屬性替換為 data-src 加上 lazyload class name src 建議加上預設圖片，避免在頁面載入時產生破圖 &lt;template&gt; &lt;div&gt; &lt;img data-src=\"https://.../image.png\" class=\"lazyload\" src=\"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAQAAAC1HAwCAAAAC0lEQVR42mNkYAAAAAYAAjCB0C8AAAAASUVORK5CYII=\" /&gt; &lt;/div&gt;&lt;/template&gt; lazy loading 運作原理如下： &lt;img&gt; 使用 data-src 屬性代入要加載的圖片路徑，瀏覽器無法辨識該屬性因此無法載入 監聽圖片 dom 元素是否進入瀏覽器可視區 當 dom 元素進入可視範圍，將 data-src 的值複製到 src 內，進行圖片載入 也可以試著包裝成共用元件 // components/TheLazyLoadImage.vue&lt;template&gt; &lt;img :data-src=\"src\" :src=\"defaultImage\" class=\"lazyload\" :alt=\"alt\" /&gt;&lt;/template&gt;&lt;script&gt;export default { name: 'LazyLoadImage', props: { src: { type: String, required: true, default: '' }, alt: { type: String, required: true, default: '' }, defaultImage: { type: String, default: 'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAQAAAC1HAwCAAAAC0lEQVR42mNkYAAAAAYAAjCB0C8AAAAASUVORK5CYII=' } }};&lt;/script&gt; 接著在頁面使用 &lt;template&gt; &lt;TheLazyLoadImage src=\"https://.../image.png\" alt=\"example image\" /&gt;&lt;/template&gt;&lt;script&gt;import TheLazyLoadImage from '@/components/TheLazyLoadImage';export default { name: 'LazyLoadImage', components: { TheLazyLoadImage }};&lt;/script&gt; 看一下編譯後的結果 &lt;img class=\"lazyloaded\" data-src=\"https://.../image.png\" src=\"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAQAAAC1HAwCAAAAC0lEQVR42mNkYAAAAAYAAjCB0C8AAAAASUVORK5CYII=\" alt=\"example image\" /&gt; 當 &lt;img&gt; 進入可視範圍後，顯示如下 &lt;img class=\"lazyloaded\" data-src=\"https://.../image.png\" src=\"https://.../image.png\" alt=\"example image\" /&gt; 範例程式碼 See the Pen Vue.js Lazy Loading Images by Claire Chang (@claire-chang-the-bashful) on CodePen. 參考文章： https://medium.com/@dannjb/a-lazy-loading-image-component-for-nuxt-js-c34e0909e6e1 https://medium.com/@mingjunlu/lazy-loading-images-via-the-intersection-observer-api-72da50a884b7","link":"/2023/02/02/nuxt/nuxt-lazy-loading/"},{"title":"Nuxt.js Lifecycle 生命週期","text":"版本：nuxt 2.15.8 Nuxt 最大的特點就是 Server Side Render，因此他有獨立的生命週期，來看一下官方提供的圖片： nuxtServerInit只在 Nuxt 環境初始化時觸發，當我們想將 server 端資料提前傳給 client 端，可以使用此方法，要注意只能寫在 VueX store/index.js actions // store/index.jsexport const state = () =&gt; ({ userInfo: {}});export const mutations = { setUserInfo(state, value) { state.userInfo = value; }};export const actions = { nuxtServerInit({ commit }, { req }) { // req.session.user = { name: 'claire' } commit('setUserInfo', req.session.user); }}; 這樣就可以在 Nuxt 初始化時，觸發 nuxtServerInit 方法，將值傳入 state，我們可以從瀏覽器 Vue 開發者工具看到內容： 如果想將資料傳給其他 VueX modules，可以這樣做： 首先新增一支檔案 store/greeting.js // store/greeting.jsexport const state = () =&gt; ({ message: ''});export const mutations = { setMessage(state, value) { state.message = value; }}; 接著在 store/index.js 定義 nuxtServerInit // store/index.jsexport const actions = { nuxtServerInit({ commit }, { req }) { commit('greeting/setMessage', 'Hello World!'); }}; 這樣就可以觸發 store/greeting.js setMessage 方法，見下圖開發者工具 Route Middleware中間組件，在頁面渲染前執行，有三種定義方式，執行順序為：Global → Layout → Page 接下來分別說明該如何定義 Global Middleware在 middleware 資料夾內建立檔案，這裡命名為 global.js // middleware/global.jsexport default ({ from, route, redirect, store, error }) =&gt; { console.log('global middleware'); if (!store.isLogin) { redirect('/login'); }}; 接著在 nuxt.config.js 配置 // nuxt.config.jsexport default { router: { middleware: [ 'global' ] }} Layout Middleware建立 middleware 檔案，這裡命名為 middleware/layout.js，然後配置到任一 layouts 檔案，範例使用 layouts/default.vue // layouts/default.vueexport default { name: 'Default', middleware: 'layout'}; 或是匿名配置也可以： // layouts/default.vueexport default { name: 'Default', middleware({ from, route, redirect, store, error }) { console.log('layout middleware'); }}; Page Middleware概念同 layouts middleware，配置於任一 pages 檔案，範例使用 pages/about.vue，這裡使用匿名配置來說明 // pages/about.vueexport default { name: 'About', middleware({ from, route, redirect, store, error }) { console.log('page middleware'); }}; 接著我們從開發者工具查看 console 結果依序為下圖，因此我們可以透過 layout 跟 page middleware 來覆寫 global middleware validate於 pages 檔案配置此方法，用來驗證動態路由參數有效性，範例使用 pages/about/_userId.vue // pages/about/_userId.vueexport default { name: 'User', validate({ params, query }) { return true; // 驗證通過 return false; // 驗證無效，會自動轉導 error page }} 驗證通過必須 return true，否則會自動轉跳 404 error page asyncData於 server 端處理非同步的生命週期，在此傳入的內容可以被搜尋引擎爬蟲取得，是提升 SEO 效能的重點生命週期。 只會在頁面載入時調用，由於生命週期在 Vue 之前，因此無法取得 this ，且 asyncData 僅限 pages 底下頁面使用，方法內會自動帶入 context 參數，我們可以安裝 @nuxtjs/axios 套件，axios 會被注入進 context 內，我們可以物件解構方式使用（ { $axios, params } = context )（範例使用 pages/about.vue） // pages/about.vueexport default { name: 'About', async asyncData({ $axios, params }) { const id = params.id; const { data } = await $axios.$get(`/api/user/${id}`); return { userName: data }; }} 透過 return value，資料被賦予進 Vue 實體，我們透過 this.userName 即可成功取值 // pages/about.vue&lt;template&gt; &lt;div&gt; &lt;h1&gt;{{ userName }}&lt;/h1&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;export default { name: 'About', async asyncData({ $axios, params }) { const id = params.id; const { data } = await $axios.$get(`/api/user/${id}`); return { userName: data }; }}&lt;/script&gt; data 如果有相同變數名稱，會在 asyncData 生命週期被複寫，所以除非需要再次修改變數，否則請避免重複命名變數 asyncData 是在 server 端、路由更新前即調用，由於是在瀏覽器渲染前的生命週期，因此無法使用 loading placeholder，也不能使用瀏覽器相關 API fetchNuxt v2.12 新增功能，功能類似 asyncData ，在畫面渲染前，同時於 server 端跟 client 端的生命週期，可以使用於任一 .vue 頁面，由於是在 Vue created 之後，因此可以取得 this，初次載入頁面時，fetch 會在 server 端執行，如果是透過 &lt;nuxt-link&gt; 進行路由切換，fetch 在 client 端執行，因此可以在此生命週期加入 loading 效果 &lt;nuxt-link&gt; 為 Nuxt 的路由切換元件，相當於 Vue.js 的 &lt;router-link&gt; ，因此我們只能使用內部連結，外部連結必須使用 &lt;a&gt; 標籤，透過 &lt;nuxt-link&gt; 切換路由，會被視為 SPA 頁面跳轉 以下說明使用方式 &lt;template&gt; &lt;ul&gt; &lt;li v-for=\"(post, key) in posts\" :key=\"key\"&gt; {{ post }} &lt;/li&gt; &lt;/ul&gt;&lt;/template&gt;&lt;script&gt;export default { data() { return { posts: [] } }, async fetch() { const { data } = await this.$axios.$get('/api/posts'); this.posts = data; }}&lt;/script&gt; 如果要重複觸發 fetch 生命週期，可以使用 this.$fetch 來呼叫： &lt;template&gt; &lt;div&gt; &lt;ul&gt; &lt;li v-for=\"(post, key) in posts\" :key=\"key\"&gt; {{ post }} &lt;/li&gt; &lt;/ul&gt; &lt;button @click=\"$fetch\"&gt;重新取得貼文&lt;/button&gt; &lt;/div&gt;&lt;/template&gt; 如果我們希望 fetch 只在 client 端運行，可以加上 fetchOnServer: false（預設 true） 取得 fetch 狀態我們可以透過 this.$fetchState 取得 fetch 當前執行狀態，有以下參數： pending：Boolean / 是否執行完成，可以在此加入 loading 效果（client 端） error：null or Error 物件 / 判斷是否發生錯誤 timestamp：整數 / 最後一次執行時間（搭配 activated 使用） 範例： &lt;template&gt; &lt;div&gt; &lt;p v-if=\"$fetchState.pending\"&gt;Loading...&lt;/p&gt; &lt;p v-if=\"$fetchState.error\"&gt;有東西出錯了&lt;/p&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;export default { data() { return { posts: [] } }, activated() { // 每 30 秒自動呼叫 fetch if (this.$fetchState.timestamp &lt;= Date.now() - 30000) { this.$fetch() } }, async fetch() { const { data } = await this.$axios.$get('/api/posts'); this.posts = data; }}&lt;/script&gt; 生命週期執行順序接著我們從瀏覽器開發者工具觀察生命週期執行順序 asyncData() { console.log('asyncData');},fetch() { console.log('fetch');},beforeCreate() { console.log('beforeCreate');},created() { console.log('created');},beforeMount() { console.log('beforeMount');} 可以發現，created 跟 beforeCreate 這兩個 Vue.js 生命週期會同時出現在 server 端跟 client 端，如果要避免方法被重複執行，可以這樣做： 加上 process.client 判斷 created(){ if (process.client){ // 執行內容 }} 使用 Nuxt fetch 生命週期 使用 Vue beforeMount 生命週期 參考文章： https://stackoverflow.com/questions/60411436/nuxtjs-page-is-created-twice https://happy9990929.github.io/2021/09/10/vue-nuxt-lifecycle-hooks/","link":"/2022/11/24/nuxt/nuxt-lifecycle/"},{"title":"Nuxt.js 自訂頁面 Loading 效果","text":"版本：nuxt 2.15.8 Nuxt.js 提供了預設的進度條效果，當切換路徑時會自動顯示。我們可以自由地調整進度條的樣式、關閉進度條，或者進行客製化介面設計。 設定 Loading 樣式1. 關閉 loading 效果全域關閉效果 // nuxt.config.jsexport default { loading: false}; 或是針對單頁關閉效果 // pages/about.vue&lt;template&gt; &lt;h1&gt;About&lt;/h1&gt;&lt;/template&gt;&lt;script&gt; export default { loading: false };&lt;/script&gt; 2. 調整預設元件樣式// nuxt.config.jsexport default { loading: { color: 'blue', height: '5px' }}; 參數如下： 參數 Type 預設值 說明 color String ‘black’ 進度條色彩 failedColor String ‘red’ 錯誤時進度條色彩 height String ‘2px’ 進度條高度 throttle Number 200 顯示進度條前的緩衝時間 (ms) duration Number 5000 進度條顯示最長時間 (ms) continuous Boolean false loading 時間大於 duration 時，是否持續顯示進度條 css Boolean true 設定 false 會移除預設進度條樣式（並可自行設定樣式） rtl Boolean false 進度條方向是否由右至左（預設由左至右） 3. 客製化 Loading 樣式如果不想使用預設 loading 樣式，也可以自己建立，新增 components/TheLoading.vue（命名自訂） // nuxt.config.js&lt;template&gt; &lt;div v-if=\"loading\" class=\"loading-page\"&gt; &lt;span&gt;Loading...&lt;/span&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;export default { data() { return { loading: false } }, methods: { start() { this.loading = true }, finish() { this.loading = false }}};&lt;/script&gt; 接著註冊到 nuxt.config.js // nuxt.config.jsexport default { loading: '@/components/TheLoading.vue'}; 觸發 Loading 事件我們可以透過 start()、finish() 方法來觸發跟結束 loading 效果 // pages/about.vue&lt;template&gt; &lt;h1&gt;About：&lt;/h1&gt; &lt;h3&gt;name：{{ info.name }}&lt;/h3&gt; &lt;h3&gt;age：{{ info.age }}&lt;h3&gt;&lt;/template&gt;&lt;script&gt;export default { data() { return { info: { name: '', age: '' } }; }, mounted() { this.getInfo(); }, methods: { async getInfo() { // loading 開始 this.$nuxt.$loading.start(); const response = await $axios.$get('/api/info'); this.info = response; // loading 結束 this.$nuxt.$loading.finish(); } }};&lt;/script&gt; 參考文章： https://nuxtjs.org/docs/features/loading/ https://ithelp.ithome.com.tw/articles/10205496","link":"/2022/12/29/nuxt/nuxt-loading/"},{"title":"Nuxt.js 套件應用：Masonry 打造瀑布流版面","text":"版本：nuxt 2.15.8 前端網頁開發想必對瀑布流版面不陌生，能夠快速的幫我們達成 RWD 區塊排版，其中最有名的就是 masonry-layout 這套 javascript 套件。 步驟如下： 1. 安裝套件npm i masonry-layout 2. 製作全域共用 mixins在 plugins 新增檔案 masonry.js，這裡使用原生 JS 寫法：new Masonry(element, optoins) ，options 選項參考 官方文件 // plugins/masonry.jsimport Vue from 'vue';import Masonry from 'masonry-layout';// 避免重複註冊if (!Vue.__masonry_mixin__) { Vue.__masonry_mixin__ = true; Vue.mixin({ methods: { masonry(element, optoins) { return new Masonry(element, optoins); } } });} 全域 mixins 相當方便，但也很耗記憶體，因此必須加上判斷條件（EX：Vue.__masonry_mixin__），避免重複註冊 mixins 3. nuxt.config.js 配置 plugins必須加上 mode: 'client' ，因套件有使用到 window 物件，在 server 端讀取不到變數會報錯： window is not defined // nuxt.config.jsexport default { plugins: [ { src: '@/plugins/masonry', mode: 'client' } ]} 4. 頁面應用接下來就可以在頁面上使用了，範例頁面 pages/index.vue // pages/index.vue&lt;template&gt; &lt;div class=\"masonry-wrap\" ref=\"masonry\"&gt; &lt;div class=\"masonry-item\" v-for=\"item in 12\" :key=\"item\" :class=\"`masonry-item-${item}`\"&gt; &lt;div class=\"card\"&gt; {{ item }} &lt;/div&gt; &lt;/div&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;export default { name: 'Home', mounted() { this.masonry(this.$refs.masonry, { columnWidth: 160, gutter: 20, itemSelector: '.masonry-item', transitionDuration: '0.3s', horizontalOrder: true }); }}&lt;/script&gt;&lt;style lang=\"scss\" scoped&gt; * { box-sizing: border-box; } .masonry-wrap { max-width: 1000px; padding: 50px; } .masonry-item { width: 160px; height: 100px; margin-bottom: 20px; .card { padding: 1rem; height: 100%; background: rgb(225, 225, 225); border-radius: 5px; border: 1px solid rgb(200, 200, 200); } } .masonry-item-1, .masonry-item-7, .masonry-item-12 { height: 200px; } .masonry-item-3, .masonry-item-9 { height: 150px; }&lt;/style&gt; 結果如下 See the Pen Vue.js 2.x 套件應用：Masonry 打造瀑布流版面 by Claire Chang (@claire-chang-the-bashful) on CodePen. 參考文章： https://masonry.desandro.com/ https://medium.com/@jake101/using-masonry-js-in-nuxt-c4dbf8c17647","link":"/2022/12/23/nuxt/nuxt-masonry/"},{"title":"Nuxt.js Meta Tags and SEO","text":"版本：nuxt 2.15.8 在 Vue.js 專案，我們可以直接在 index.html &lt;head&gt; 設定全站共用的 meta tags，那在 Nuxt 又該怎麼設定呢？ Nuxt.js 藉由 vue-meta 來更新應用內的 head 設定跟 meta 屬性，使用 create-nuxt-app 建構專案會自動安裝，我們可以在頁面定義不同的內容，幫助搜尋引擎爬蟲掌握頁面內容，提升 SEO。 全域配置// nuxt.config.jsexport default { head: { title: 'my website title', meta: [ { charset: 'utf-8' }, { name: 'viewport', content: 'width=device-width, initial-scale=1' }, { hid: 'description', name: 'description', content: 'my website description' }, { hid: 'og:title', property: 'og:title', content: 'my website title' } ], link: [ { rel: 'icon', type: 'image/x-icon', href: '/favicon.ico' } ] }} 我們可以看到 head 自動渲染： &lt;head&gt; &lt;title&gt;my website title&lt;/title&gt; &lt;meta data-n-head=\"ssr\" charset=\"utf-8\"&gt;&lt;/head&gt; 為了避免元件內 局部配置 head 造成 meta tags 重複，需加上 hid key，並賦予唯一值，這樣當元件定義相同 hid 的 meta 標籤，vue-meta 會自動覆蓋掉 全域配置 局部配置以物件定義： // pages/about.vueexport default { head: { title: 'about-us', meta: [ { hid: 'description', name: 'description', content: 'about-us' } ] }} 如果需要透過 this 來取得 meta 資料，需要調整為 function return： // pages/about.vueexport default { data() { return { seo: { title: 'about-us', description: 'about-us' } } }, head() { return { title: this.seo.title, meta: [ { hid: 'description', name: 'description', content: this.seo.description } ] } }} 參考文章： https://nuxtjs.org/docs/features/meta-tags-seo/","link":"/2022/12/10/nuxt/nuxt-meta-tags/"},{"title":"Nuxt.js 實作 301 轉址（301 Redirect）","text":"版本：nuxt 2.15.8 301 轉址又稱為重新導向，將指定網址導向另一網址，在網站結構更新、網站搬遷時常會使用到，當用戶輸入舊網址時，會自動跳轉到新網址。 轉址跟 SEO 的關係如果需轉址的網頁已經經營許久，如果沒有設定轉址，過去累積的頁面權重和流量不會跟著轉移，新的網站必須重新累積，且搜尋引擎可能會出現重複內容，將會影響 SEO 排名。 301 轉址跟 302 轉址差別如果只是暫時性網站維護，之後會重新導回舊有網站，需使用 302 暫時轉址；如果是永久更換，則使用 301 轉址。 實作 301 轉址當網站改版，網址的結構異動，我們可以這樣做： 舊網頁： https://example.com/events/summer-sale 新網頁： https://new-example.com/special/summer-sale 舊網頁 新網頁 /events/event-title /special/event-title /events/treatment-title /treatment/treatment-title /events/product-title /product/product-title 新網頁是當前已開發的頁面，就不多做說明，至於要怎麼轉導舊網頁，我們可以透過 middleware，首先新增對應路由的頁面：pages/events/_id.vue (由於舊路由皆為 events 底下，統一建立動態路由)，接著進行設定： // pages/events/_id.vue&lt;template&gt; &lt;div&gt;&lt;/div&gt;&lt;/template&gt;&lt;script&gt;export default { name: 'EventsUrlRedirection', middleware({ route, redirect, error }) { const redirectArr = { '/events/event-title': '/special/event-title', '/events/treatment-title': '/treatment/treatment-title', '/events/product-title': '/product/product-title' }; if (redirectArr[route.path]) { redirect(301, redirectArr[route.path]); } else { // 當頁面不存在，導向 404 error page error({ statusCode: 404 }); } }};&lt;/script&gt; redirect 預設 status code 302 ，使用預設值直接寫 redirect(path) 就可以了 middleware 也可獨立拆分，外層新增 middleware 資料夾，新增檔案 urlRedirection.js // middleware/urlRedirection.jsexport default ({ route, redirect, error }) =&gt; { const redirectArr = { '/events/event-title': '/special/event-title', '/events/treatment-title': '/treatment/treatment-title', '/events/product-title': '/product/product-title' }; if (redirectArr[route.path]) { redirect(301, redirectArr[route.path]); } else { error({ statusCode: 404 }); }}; 接著回到 pages/events/_id.vue： // pages/events/_id.vue&lt;template&gt; &lt;div&gt;&lt;/div&gt;&lt;/template&gt;&lt;script&gt;export default { name: 'EventsUrlRedirection', middleware: 'urlRedirection'};&lt;/script&gt; 這樣就完成了～ 參考文章： https://welly.tw/serp-rank-optimization/301-and-302-redirection-guide-for-seo https://nuxtjs.org/docs/internals-glossary/context/#redirect","link":"/2022/12/18/nuxt/nuxt-redirect/"},{"title":"Nuxt.js 替網站增加 sitemap 網站地圖","text":"版本：nuxt 2.15.8 當我們的新網站上線，外部連結少，或是網站規模很大時，透過 sitemap 網站地圖，可以讓 google 搜尋引擎爬蟲可以更快速的了解我們的網站上有哪些網頁並加以收錄，並建立索引，提升網頁出現的機率。 我們可以透過 @nuxtjs/sitemap 來快速建立 sitemap，執行：npm i @nuxtjs/sitemap 在 config 資料夾新增 sitemap.js 檔案，接著在 nuxt.config.js 配置： // nuxt.config.jsimport sitemap from './config/sitemap';export default { modules: [ '@nuxtjs/sitemap', ], sitemap: sitemap} 接著移動到到 config/sitemap.js 進行設定。 sitemap 選項說明： path：設定 sitemap 名稱，預設為 /sitemap.xml hostname：網站 domain cacheTime：sitemap 更新的頻率（預設為 1000 * 60 * 15 15 分鐘） gzip：是否生成壓縮檔，預設 false exclude：排除被加進 sitemap 的頁面（陣列） sitemap: { exclude: [ '/guideline', '/sample/**' ]} defaults：預設設定（自動帶入 routes） sitemap: { defaults: { changefreq: 'daily', // 更新頻率 priority: 0.8, // 優先度 lastmod: new Date() // 最後更新時間 }} filter：篩選路徑（function） sitemap: { filter({ routes }) { return routes.map(route =&gt; { // 設定首頁優先度為 1 if (route.url === '/') { route.priority = 1; } return route; }); }} routes：加入路徑（本篇重點，以下詳細說明） Routes 設定@nuxtjs/sitemap 會自動加入 靜態路由 頁面，但 動態路由 必須手動加入 -| pages/---| index.vue --&gt; static route---| about.vue --&gt; static route---| users/-----| _id.vue --&gt; dynamic route 加入動態路由方法： 手動加入（使用陣列） sitemap: { routes: [ { url: '/users/1', changefreq: 'daily', priority: 0.6, lastmod: new Date() }, { url: '/users/2', changefreq: 'daily', priority: 0.6, lastmod: new Date() } ]} 透過 API 串接加入（使用 function 回傳 promise） 範例會使用 @nuxtjs/axios 進行 API 串接，執行：npm i @nuxtjs/axios sitemap: { routes: async () =&gt; { const { data } = await axios.get('https://test/api/sitemap'); return data.map(user =&gt; { return { url: `/users/${user.id}`, changefreq: 'daily', priority: 0.6, lastmod: new Date() } }); }} 將上述設定合併起來： // config/sitemap.jsconst axios = require('axios');const sitemap = { path: '/sitemap.xml', // sitemap 名稱 hostname: 'https://test.com', // domain cacheTime: 1000 * 60 * 60 * 24, // update frequency of the day defaults: { changefreq: 'daily', priority: 0.8, lastmod: new Date() }, filter({ routes }) { return routes.map(route =&gt; { if (route.url === '/') { route.priority = 1; } return route; }); } routes: async () =&gt; { const { data } = await axios.get('https://test.com/api/sitemap'); return data.map(user =&gt; { return { url: `/users/${user.id}`, changefreq: 'daily', priority: 0.6, lastmod: new Date() } }); }};export default sitemap; 接著在頁面上輸入 hostname/sitemap.xml（EX：https://test.com/sitemap.xml），就可以看到我們的 sitemap 檔案囉 🙌 參考文章： https://www.hellosanta.com.tw/knowledge/category-13/post-236 https://sitemap.nuxtjs.org/usage/sitemap-options","link":"/2022/12/15/nuxt/nuxt-sitemap/"},{"title":"Nuxt.js 套件應用：Swiper 製作輪播動畫","text":"版本：nuxt 2.15.8 網站開發常使用到輪播功能，Swiper 是一款基於 js 開發、功能完整實用性高的輪播套件，本篇將介紹如何在 Nuxt.js 專案內搭配 Vue 整合套件 vue-awesome-swiper 實作輪播動畫 套件安裝： npm i swiper@6.8.4 npm i vue-awesome-swiper@4.1.1 官方文件版本說明：Vue2 搭配 Swiper 5-6 ＆&nbsp;vue-awesome-swiper@4.1.1如果是 Vue3 此套件已不支援，需改用 Swiper Vue.js Components 接著全域註冊 Swiper 元件，在 plugins 資料夾新增檔案 swiper.js（檔名自訂） // plugins/swiper.jsimport Vue from 'vue';import Swiper, { /* swiper modules... */ } from 'swiper';import VueAwesomeSwiper from 'vue-awesome-swiper';Swiper.use([ /* swiper modules... */ ]);export default () =&gt; { Vue.use(VueAwesomeSwiper);}; 上述 swiper modules 區塊可以替換需要的模組（模組選項），範例使用 Navigation, Pagination 在 nuxt.config.js 進行配置 // nuxt.config.jsexport default { css: [ { src: 'swiper/swiper-bundle.min.css' } ], plugins: [ { src: '@/plugins/swiper', mode: 'client' } ]} 接下來可以透過兩種方式使用： swiper components 元件&lt;template&gt; &lt;client-only&gt; &lt;div&gt; &lt;swiper class=\"swiper\" :options=\"swiperOption\" ref=\"bannerSwiper\"&gt; &lt;swiper-slide&gt;banner 1&lt;/swiper-slide&gt; &lt;swiper-slide&gt;banner 2&lt;/swiper-slide&gt; &lt;swiper-slide&gt;banner 3&lt;/swiper-slide&gt; &lt;swiper-slide&gt;banner 4&lt;/swiper-slide&gt; &lt;swiper-slide&gt;banner 5&lt;/swiper-slide&gt; &lt;/swiper&gt; &lt;div class=\"swiper-button-prev\" slot=\"button-prev\"&gt;&lt;/div&gt; &lt;div class=\"swiper-button-next\" slot=\"button-next\"&gt;&lt;/div&gt; &lt;/div&gt; &lt;/client-only&gt;&lt;/template&gt;&lt;script&gt;export default { data() { return { swiperOption: { slidesPerView: 3, spaceBetween: 5, grabCursor: true } } }};&lt;/script&gt; swiper 設定項目請見文件，如果專案為 server-side render，使用此方式外層需加上 &lt;client-only /&gt; ，否則在 server 端會因為 dom 元素無法被解析而報錯 [Vue warn]: The client-side rendered virtual DOM tree is not matching server-rendered content. This is likely caused by incorrect HTML markup, for example nesting block-level elements inside &lt;p&gt;, or missing &lt;tbody&gt;. Bailing hydration and performing full client-side render. 我們可以使用 this.$refs.bannerSwiper.$swiper 來取得 Swiper 實體並使用相關方法 根據文件說明，&lt;client-only /&gt; 的元素在 mounted 生命週期才渲染完畢，因此在 mounted 呼叫 $refs 可能會取不到內容（即便使用 $nextTick），需將方法包裝成迴圈： export default { mounted(){ this.getSwiperInstance() }, methods: { getSwiperInstance() { this.$nextTick(() =&gt; { if (this.$refs.bannerSwiper) { this.$refs.bannerSwiper.$swiper.slideTo(2); } else { this.getSwiperInstance(); } }); } }} directive 指令若 Swiper 內容需被搜尋引擎爬蟲讀取，可以利用 Vue directive 方法，使用能被瀏覽器解析的 Dom 元素包裝 Swiper，見以下範例： &lt;template&gt; &lt;div class=\"banner-wrap mx-auto py-4 px-3\"&gt; &lt;div v-swiper:bannerSwiper=\"swiperOption\" class=\"swiper\"&gt; &lt;div class=\"swiper-wrapper\"&gt; &lt;div class=\"swiper-slide\"&gt;banner 1&lt;/div&gt; &lt;div class=\"swiper-slide\"&gt;banner 2&lt;/div&gt; &lt;div class=\"swiper-slide\"&gt;banner 3&lt;/div&gt; &lt;div class=\"swiper-slide\"&gt;banner 4&lt;/div&gt; &lt;div class=\"swiper-slide\"&gt;banner 5&lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;export default { data() { return { swiperOption: { slidesPerView: 3, spaceBetween: 5, grabCursor: true } } }, mounted() { this.bannerSwiper.slideTo(2, 500, false); }};&lt;/script&gt; 如果同一個頁面有多個 Swipers，必須要透過命名（ ex: v-swiper:bannerSwiper ）來進行綁定，我們也可以透過名稱 this.bannerSwiper 的取得 Swiper 實體並使用相關方法，是不是簡單許多呢！ 參考文章： https://github.com/surmon-china/surmon-china.github.io/blob/vue2/projects/vue-awesome-swiper/examples/00-typescript-composition-api.vue https://nuxtjs.org/docs/features/nuxt-components/#the-client-only-component https://ken551113.github.io/2019/11/26/Using-Vue-Awesome-Swiper-On-Nuxt/","link":"/2022/11/29/nuxt/nuxt-swiper/"},{"title":"Nuxt.js 套件應用：VeeValidate 表單驗證","text":"版本：nuxt 2.15.8 vee-validate 是使用於 Vue.js 的輕量表單驗證套件（參考 php 框架 laravel 表單驗證所開發），僅需在表單上加入簡易語法就能進行驗證，執行：npm i vee-validate@3.4.14 Vue.js v2.x 需搭配 vee-validate v3.x 新增 plugins/vee-validate.js，在 nuxt.config.js 配置 // nuxt.config.jsexport default { plugins: [ { src: '@/plugins/vee-validate.js', mode: 'client' } ]} 移動到 plugins/vee-validate.js 註冊全域表單驗證元件，步驟如下： 1. 規則引入引入部分規則： import { extend } from 'vee-validate';import { required, email } from \"vee-validate/dist/rules\";extend('email', email);extend('required', { ...required, message: '欄位必填'}); 引入全部規則： import { extend } from 'vee-validate';import * as rules from 'vee-validate/dist/rules';Object.keys(rules).forEach(rule =&gt; { extend(rule, rules[rule]);}); 2. 語系設定（以繁體中文舉例）import { localize } from 'vee-validate';import tw from 'vee-validate/dist/locale/zh_TW.json';localize('zh_TW', tw); 全域自訂提示訊息 localize('zh_TW', { ...tw, messages: { required: '{_field_} 必填' }, fields: { email: { required: '郵件 必填' } }}); 3. 調整互動模式跟 CSS classes互動模式選項： aggressive：預設模式，input 跟 blur 事件進行驗證 lazy：change 或 blur 事件進行驗證 passive：不會自動驗證，需主動呼叫 eager：官方說明為使用者體驗最佳的互動模式，結合 aggressive (驗證失敗後) 跟 lazy (驗證前) import { configure } from 'vee-validate';configure({ mode: 'eager', // Interaction Modes classes: { valid: 'is-valid', invalid: 'is-invalid' }}); 4. 將元件註冊至 Vue InstanceValidationObserver：驗證完整表單 ValidationProvider：驗證單一表單內容 import { ValidationObserver, ValidationProvider } from 'vee-validate';Vue.component('ValidationObserver', ValidationObserver);Vue.component('ValidationProvider', ValidationProvider); 將以上內容整合起來： // plugins/vee-validate.jsimport Vue from 'vue';import tw from 'vee-validate/dist/locale/zh_TW.json';import * as VeeValidate from 'vee-validate';import * as rules from 'vee-validate/dist/rules';Object.keys(rules).forEach(rule =&gt; { VeeValidate.extend(rule, rules[rule]);});VeeValidate.localize('zh_TW', tw);VeeValidate.configure({ mode: 'eager', classes: { valid: 'is-valid', invalid: 'is-invalid' }});Vue.component('ValidationObserver', VeeValidate.ValidationObserver);Vue.component('ValidationProvider', VeeValidate.ValidationProvider); 接下來就可以在各頁面、元件使用表單驗證功能囉： Validation Provider：驗證單一表單內容（input）1. v-slot：取得元件回傳的內容2. rules：規則選擇，多個規則可以使用 ‘|’ 分隔3. props：回傳內容給元件，EX: name &lt;ValidationProvider rules=\"required|email\" name=\"E-mail\" v-slot=\"{ errors, classes }\"&gt; &lt;input type=\"email\" placeholder=\"請輸入信箱\" v-model=\"email\" :class=\"classes\" /&gt; &lt;small&gt;{{ errors[0] }}&lt;/small&gt;&lt;/ValidationProvider&gt; Validation Observer：驗證完整表單方法一：使用 v-slot=\"{ invalid }\" ，驗證不通過 disabled 按鈕（type=\"submit\"），submitForm() 為自訂方法 &lt;validation-observer v-slot=\"{ invalid }\"&gt; &lt;form @submit.prevent=\"submitForm\"&gt; &lt;ValidationProvider&gt;...&lt;/ValidationProvider&gt; &lt;button type=\"submit\" :disabled=\"invalid\"&gt;送出表單&lt;/button&gt; &lt;/form&gt;&lt;/validation-observer&gt; 方法二：使用 v-slot=\"{ handleSubmit }\" ，透過 handleSubmit 方法來監聽表單，驗證通過點擊按鈕才會執行 submitForm() &lt;validation-observer v-slot=\"{ handleSubmit }\"&gt; &lt;form @submit.prevent=\"handleSubmit(submitForm)\"&gt; &lt;ValidationProvider&gt;...&lt;/ValidationProvider&gt; &lt;button type=\"submit\"&gt;送出表單&lt;/button&gt; &lt;/form&gt;&lt;/validation-observer&gt; 將 &lt;ValidationProvider /&gt;、&lt;ValidationObserver /&gt; 結合起來，範例頁面 pages/contact-us.vue： // pages/contact-us.vue&lt;template&gt; &lt;client-only&gt; &lt;ValidationObserver v-slot=\"{ handleSubmit }\" ref=\"observer\"&gt; &lt;form @submit.prevent=\"handleSubmit(submitForm)\"&gt; // 姓名 &lt;label for=\"name\"&gt;姓名&lt;/label&gt; &lt;ValidationProvider rules=\"required\" name=\"姓名\" v-slot=\"{ errors, classes }\"&gt; &lt;input type=\"text\" v-model=\"name\" :class=\"classes\" /&gt; &lt;small&gt;{{ errors[0] }}&lt;/small&gt; &lt;/ValidationProvider&gt; // email &lt;label for=\"email\"&gt;E-mail&lt;/label&gt; &lt;ValidationProvider rules=\"required|email\" name=\"E-mail\" v-slot=\"{ errors, classes }\"&gt; &lt;input type=\"email\" v-model=\"email\" :class=\"classes\" /&gt; &lt;small&gt;{{ errors[0] }}&lt;/small&gt; &lt;/ValidationProvider&gt; &lt;button type=\"submit\"&gt;送出表單&lt;/button&gt; &lt;/form&gt; &lt;/ValidationObserver&gt; &lt;/client-only&gt;&lt;/template&gt;&lt;script&gt; export default { data() { return { name: '', email: '' } }, methods: { submitForm() { // ... } } }&lt;/script&gt; 在 ssr: true 模式下，外層必須加上 &lt;client-only /&gt; ，否則在 server 端會因為 dom 元素無法解析而拋錯誤 結果如下 See the Pen Vue.js 2.x 套件應用：VeeValidate 表單驗證 by Claire Chang (@claire-chang-the-bashful) on CodePen. 參考文章： https://medium.com/@yusufznl/how-to-validate-forms-in-nuxt-with-vee-validate-eef45508c3d4https://vee-validate.logaretm.com/v3/","link":"/2022/12/17/nuxt/nuxt-veevalidate/"},{"title":"Nuxt.js VueX Store 搭配 vuex-persistedstate 狀態保存工具","text":"版本：nuxt 2.15.8 前情提要一下，在 Vue 的專案下，常會需要做父子元件或是頁面之間的溝通傳值，如果說只是單層（ex：父元件 → 子元件、子元件 → 父元件、頁面 → 頁面），我們可以很簡單的使用 props 、 emit 或 event bus 即可，但在大型專案，共用資料就不是如此單純，可能會有元件內含元件、多層級的溝通，如果只用上述方法，對於開發及除錯都不便利，如下圖範例，元件 1-1 跟元件 2-1 的溝通相對複雜。 為了處理高難度溝通，VueX 狀態管理工具就誕生了，那麼在 Nuxt 專案下又該怎麼使用呢？ 首先先安裝 VueX 套件 npm i vuex@3.6.2 Nuxt v2.x 必須搭配 VueX v3.x 接著在專案最外層新增 store 資料夾，並在裡面建立 .js 檔，範例使用 userInfo.js // store/userInfo.jsexport const state = () =&gt; {};export const getters = {};export const mutations = {};export const actions = {}; Nuxt 專案會自動創建實例 new Vuex.Store()，將 store 檔案包裝進模組內，像這樣： new Vuex.Store({ modules: { userInfo: { namespaced: true, state: () =&gt; {}, getters: {}, mutations: {}, actions: {} } }}); VueX 基本架構： state：用以儲存狀態，功能同 .vue 檔內的 data，因此會使用方法來包裝，並 return 內容 getters：功能同 computed，用以計算 state 內的狀態，不能直接改變 state mutations：用來更改 state，不能使用非同步語法 actions：非同步語法只能寫在 actions，不能直接改變 state，需透過 mutations 改變 state 接著來替 store 加入一些內容吧 // store/userInfo.jsexport const state = () =&gt; ({ count: 0, products: [ { name: 'food', onSale: false }, { name: 'drink', onSale: true } ]});export const getters = { onSaleProducts(state) { return state.products.filter(item =&gt; item.onSale); }};export const mutations = { increment(state, number) { state.count += number; }};export const actions = { incrementAsync({ commit }, number) { setTimeout(() =&gt; { commit('increment', number); }, 1000); }}; 如果要在頁面使用 store 的內容，有以下兩種方式： 透過 this.$store 操作VueX 將 store 注入到 Vue 實例，因此我們透過 $store 就可以取得相關資料及方法，使用方式如下（範例頁面 pages/about.vue）： // pages/about.vueexport default { name: 'About', computed: { count() { // state return this.$store.state.userInfo.count; } onSaleProducts() { // getters return this.$store.getters['userInfo/onSaleProducts']; } }, methods: { increment(number) { // mutations this.$store.commit('userInfo/increment', number); }, incrementAsync(number) { // actions this.$store.dispatch('userInfo/incrementAsync', number); } }} 但是每一筆資料或是方法，都透過 this.$store 取得，程式碼冗長，如果今天我們有三個 store 儲存庫，易讀性又更低了，難道沒有簡單的使用方式嗎？ 透過輔助函式VueX 提供一系列輔助函式（mapState, mapGetters, mapMutations, mapActions），可以幫助我們更簡易的取得 store 內容，首先必須從 VueX 引入輔助函式，接著來改寫 about.vue 頁面 // pages/about.vueimport { mapState, mapGetters, mapMutations, mapActions } from 'vuex';export default { name: 'About', computed: { ...mapState('userInfo', [ 'count' ]), ...mapGetters('userInfo', [ 'onSaleProducts' ]) }, methods: { ...mapMutations('userInfo', [ 'increment' ]), ...mapActions('userInfo', [ 'incrementAsync' ]) }} 透過輔助函式，減少許多程式碼，閱讀起來也輕鬆許多。 VueX 相當方便，但還是存在一個問題，就是當頁面重新整理的時候，會回復到初始狀態。 某些情境下，我們需要保留更新後的資料，例如登入後儲存使用者資訊到 store，重整頁面後資料被清空，使用者必須重新登入。為了解決這個問題，我們可以將資料儲存於 localStorage，待畫面重整後再將資料取回放入 store，或者是使用套件 vuex-persistedstate 2022.02.04 vuex-persistedstate 套件已不繼續維護更新 接下來說明如何 Nuxt 專案如何搭配 vuex-persistedstate，存放在 localStorage 的內容，可以輕易地被讀取，因此我們需要將內容加密（搭配套件 secure-ls） 首先安裝套件：npm i vuex-persistedstate 及加密套件：npm i secure-ls，接著於 plugins 增加檔案，範例使用 persistedstate.js // plugins/persistedstate.jsimport createPersistedState from 'vuex-persistedstate';import SecureLS from 'secure-ls';const ls = new SecureLS({ encodingType: 'aes', // 加密方式，預設 base64 isCompression: false, // 是否壓縮數據 encryptionSecret: process.env.APP_KEY // 加密 key});export default ({ store, isHMR }) =&gt; { if (isHMR) { // 避免在熱更新的時候重複觸發(npm run dev) return; } window.onNuxtReady(() =&gt; { createPersistedState({ key: 'test', // 自訂 localStorage key storage: { getItem: key =&gt; ls.get(key), setItem: (key, value) =&gt; ls.set(key, value), removeItem: key =&gt; ls.remove(key) } })(store); });}; 接著配置到 nuxt.config.js 內 // nuxt.config.jsexport default { plugins: [ { src: '@/plugins/persistedstate', ssr: false } ]} 這樣一來即使畫面重整，store 也可以順利保存資料，在 localStorage 查看 test 內容也確實被加密了！ 參考文章： https://medium.com/itsems-frontend/vue-vuex1-state-mutations-364163b3acac https://chiafangsung.medium.com/使用-vuex-persistedstate-維持-vuex-狀態-f0d7c522c73a","link":"/2022/11/22/nuxt/nuxt-vuex-store/"},{"title":"Nuxt.js 3.x Assets vs Public 目錄－靜態資源管理","text":"本篇文章同步發表於 2023 iThome 鐵人賽：Nuxt.js 3.x 筆記－打造 SSR 專案 Nuxt3 提供兩個資料夾 assets/ 以及 public/，用來管理靜態資源，像是圖片、CSS 樣式、字體、icon 等，接下來說明兩個目錄適合存放的檔案類型與使用方式 Public靜態資源資料夾（同 Nuxt2 的&nbsp;static/），用來存放不需被編譯的靜態檔，可以透過根目錄 / 直接使用檔案 適合檔案性質 不需經由 Vite / Webpack 等打包工具編譯：像是 sitemap.xml 通常不需另外壓縮處理 檔案固定性高 / 檔名不能被更改：經過編譯後的檔案，檔名後會加上一組 hash，像是 robots.txt 必須固定檔名，搜尋引擎爬蟲才能正確解析，適合放在 public/ 常見檔案類型 favicon.ico robots.txt sitemap.xml CNAME（DNS 紀錄） 使用方式透過根目錄 / 直接使用 public/ 檔案 範例： public/|—— favicon.ico|—— image/ |—— picture.jpg 使用 favicon.ico： // nuxt.config.jsexport default defineNuxtConfig({ app: { head: { link: [ { rel: 'icon', type: 'image/x-icon', href: '/favicon.ico' } ] } }}); 使用 image/picture.jpg： // pages/index.vue&lt;template&gt; &lt;div&gt; &lt;img src=\"/image/picture.jpg\"&gt; &lt;/div&gt;&lt;/template&gt; 透過開發者工具檢視 圖片來源：https://unsplash.com/ Assets用來存放像是 CSS、Sass、圖片等需要被 webpack 或是 Vite 編譯的靜態資源。一般來說，assets/ 的使用率較 public/ 高 適合檔案性質 需要透過 Vite / Webpack 打包工具編譯（壓縮、最佳化）：像是 JS 或是 CSS、圖片等，希望在專案發佈前，預先對檔案進行壓縮和最佳化處理，提升網站載入速度與效能 檔案較常更新，避免被快取影響：經過編譯後的檔案，檔名會加上依據文件內容產生的 hash，每次更新編譯後 hash 會變更，能避免受瀏覽器快取影響，強制瀏覽器讀取更新後的檔案。例如：img.png 編譯後變成 img.2d8efhg.png 常見檔案類型 CSS、Sass Javascript 圖片 字體 使用方式透過 ~/assets/ 路徑使用檔案 範例： assets/|—— scss/ |—— style.scss|—— image/ |—— picture.jpg 全域使用 scss/style.scss： // nuxt.config.jsexport default defineNuxtConfig({ css: [ '~/assets/scss/app.scss' ]}); 使用 image/picture.jpg： // pages/index.vue&lt;template&gt; &lt;div&gt; &lt;img src=\"~/assets/image/picture.jpg\"&gt; &lt;/div&gt;&lt;/template&gt; 執行生產環境編譯 nuxt build (npm run build) 後，可以看到檔名加上了 hash 圖片來源：https://unsplash.com/ 路徑別名Nuxt3 預設路徑別名如下： { \"~\": \"/&lt;rootDir&gt;\", \"@\": \"/&lt;rootDir&gt;\", \"~~\": \"/&lt;rootDir&gt;\", \"@@\": \"/&lt;rootDir&gt;\", \"assets\": \"/&lt;rootDir&gt;/assets\", \"public\": \"/&lt;rootDir&gt;/public\"} 因此也可以透過 @/assets/image/picture.jpg 取得圖片，或是自訂別名來簡化路徑 動態圖片在 Nuxt2 搭配 Webpack 打包工具，透過 require 即可動態載入圖片 // Nuxt2 + Webpack&lt;img :src=\"require(`~/assets/image/${imageName}`)\" /&gt; Nuxt3 搭配 Vite 解決方法如下（討論串），透過 import.meta.glob 方法一次引入多張圖片 // Nuxt3 + Vite&lt;template&gt; &lt;div&gt; &lt;img :src=\"getImageUrl(imageName)\" /&gt; &lt;/div&gt;&lt;/template&gt;&lt;script setup&gt;const getImageUrl = name =&gt; { const assets = import.meta.glob('~/assets/image/*', { eager: true, import: 'default' }); return assets[`/assets/image/${name}`];};const imageName = 'picture.jpg';&lt;/script&gt; .output 目錄執行生產環境編譯&nbsp;nuxt build（npm run build）時自動生成的資料夾，assets/ 與 public/ 打包後會放在 .output/public/ 內 原始檔案： public/|—— public-pic.jpgassets/|—— assets-pic.jpg 打包後： public/ 內的檔案不經處理直接放到 .output/public/ assets/ 內的檔案編譯後加上 hash 放到 .output/public/_nuxt/ .output/|—— public/ |—— _nuxt/ |—— assets-pic.ef9916a0.jpg |—— public-pic.jpg 參考資源： https://nuxt.com/docs/getting-started/assetshttps://masteringnuxt.com/blog/handling-assets-in-nuxt-3https://vitejs.dev/guide/assets.html","link":"/2023/09/12/nuxt3/nuxt-v3-assets-vs-public/"},{"title":"Nuxt.js 3.x 套件應用－CKEditor 5 文字編輯器（搭配 Vite 開發）","text":"本篇文章同步發表於 2023 iThome 鐵人賽：Nuxt.js 3.x 筆記－打造 SSR 專案 CKEditor 版本：v39.0.0 Nuxt2 搭配 CKEditor 5 請參考 這篇文章 CKEditor 是一套歷史悠久且功能完整、輕量的富文本編輯器（rich text editor），為使用者提供所見即所得（WYSIWYG）的編輯區域。與舊版不同，CKEditor 5 使用 MVC 架構、ES6 編寫、UI 簡潔，且因應現在的前後端分離趨勢，與前端框架 React、Angular、and Vue.js 做整合，讓我們可以更便利的開發應用。 接下來說明如何在 Nuxt3 + Vite 環境搭配 CKEditor 開發，分別介紹以下兩種安裝方式： 1. 使用預先定義的組合2. 自行配置功能 注意： CKEditor 只能在 client 端運作，否則會拋 self is not defined 錯誤提供兩個解法： 設定為 ssr: false，關閉 server 端渲染 將 CKEditor 元件包在自訂元件內，檔名加上 .client 後綴，限制元件在 client 端運作。EX：components/TheCkeditor.client.vue 1. 使用預先定義的組合提供以下幾種組合，各組合功能可以參考 官方文件 Classic editor Inline editor Balloon editor Balloon block editor Document editor Multi-root editor Superbuild 以 Classic editor 進行說明： 套件安裝npm install --save \\ @ckeditor/ckeditor5-vue \\ @ckeditor/ckeditor5-build-classic 使用元件與組合功能ckeditor components： editor：定義編輯器使用的組件 v-model：資料雙向綁定 config：定義設定檔 // components/TheCkeditor.client.vue&lt;template&gt; &lt;div&gt; &lt;ckeditor :editor=\"ClassicEditor\" v-model=\"editorData\" :config=\"editorConfig\"&gt; &lt;/ckeditor&gt; &lt;/div&gt;&lt;/template&gt;&lt;script setup&gt;import CKEditor from '@ckeditor/ckeditor5-vue';import ClassicEditor from '@ckeditor/ckeditor5-build-classic';const ckeditor = defineComponent(CKEditor.component);const editorData = ref('content of the editor');const editorConfig = { placeholder: 'type the content here'}&lt;/script&gt; @ckeditor/ckeditor5-build-classic 將相關功能包裝成組件，使用方式非常簡單，但無法另外擴充功能，因 @ckeditor/ckeditor5-build-classic 已將相依套件安裝進去，重複安裝會拋錯誤： CKEditorError: ckeditor-duplicated-modules CKEditor 在初始化時因模組重複執行導致錯誤，需改用以下「自行配置功能」 2. 自行配置功能選擇專案需要的功能，可以彈性的客製化組合文字編輯器 注意：所有 ckeditor 套件版本必須相同（除了 @ckeditor/ckeditor5-dev-*、@ckeditor/ckeditor5-vue 跟 @ckeditor/vite-plugin-ckeditor5） 套件安裝 安裝 Vue / Vite 整合套件 npm install --save \\ @ckeditor/vite-plugin-ckeditor5 \\ @ckeditor/ckeditor5-vue 安裝預設主題樣式 npm install --save @ckeditor/ckeditor5-theme-lark 自選功能（功能眾多不一一說明） 以下舉例： @ckeditor/ckeditor5-editor-classic：toolbar style @ckeditor/ckeditor5-paragraph：paragraph style @ckeditor/ckeditor5-essentials：selectAll、undo、redo … @ckeditor/ckeditor5-font：fontSize、fontFamily、fontColor、fontBackgroundColor @ckeditor/ckeditor5-basic-styles：bold、italic、underline、strikethrough、code … @ckeditor/ckeditor5-link：link、linkImage npm install --save \\ @ckeditor/ckeditor5-editor-classic \\ @ckeditor/ckeditor5-paragraph \\ @ckeditor/ckeditor5-essentials \\ @ckeditor/ckeditor5-font \\ @ckeditor/ckeditor5-basic-styles \\ @ckeditor/ckeditor5-link nuxt.config 配置// nuxt.config.jsimport ckeditor5 from '@ckeditor/vite-plugin-ckeditor5';export default defineNuxtConfig({ vite: { plugins: [ ckeditor5({ theme: require.resolve('@ckeditor/ckeditor5-theme-lark') }) ] }}); 使用元件與自選功能ckeditor components： editor：定義編輯器使用的組件 v-model：資料雙向綁定 config：定義設定檔 placeholder：編輯器佔位符 plugins：使用插件 toolbar：配置工具列，可以加插入分隔符號 | // components/TheCkeditor.client.vue&lt;template&gt; &lt;div&gt; &lt;ckeditor :editor=\"ClassicEditor\" v-model=\"editorData\" :config=\"editorConfig\"&gt; &lt;/ckeditor&gt; &lt;/div&gt;&lt;/template&gt;&lt;script setup&gt;import CKEditor from '@ckeditor/ckeditor5-vue';import { ClassicEditor } from '@ckeditor/ckeditor5-editor-classic';import { FontSize, FontFamily, FontColor, FontBackgroundColor } from '@ckeditor/ckeditor5-font';import { Bold, Italic, Underline, Strikethrough } from '@ckeditor/ckeditor5-basic-styles';import { Link } from '@ckeditor/ckeditor5-link';import { Paragraph } from '@ckeditor/ckeditor5-paragraph';import { Essentials } from '@ckeditor/ckeditor5-essentials';const ckeditor = defineComponent(CKEditor.component);const editorData = ref('content of the editor');const editorConfig = { placeholder: 'type the content here', plugins: [ FontSize, FontFamily, FontColor, FontBackgroundColor, Bold, Italic, Underline, Strikethrough, Link, Paragraph, Essentials ], toolbar: { items: [ 'fontSize', 'fontFamily', 'fontColor', 'fontBackgroundColor', '|', 'bold', 'italic', 'underline', 'strikethrough', '|', 'link', '|', 'undo', 'redo', '|' ], // RWD 自動換行 shouldNotGroupWhenFull: true }, fontSize: { // 自訂義字級選項 options: [ 12, 14, 16, 18, 20, 24, 28, 30, 32 ] }, link: { // 點擊連結另起新分頁 addTargetToExternalLinks: true }};&lt;/script&gt; 畫面呈現如下： 自訂 CSS 樣式前面提到透過 @ckeditor/ckeditor5-theme-lark 定義了預設樣式，如果想依照專案需求調整配色，只要修改 CKEditor 的 CSS 自訂變數即可： &lt;style&gt;:root { /* Overrides the border radius setting in the theme. */ --ck-border-radius: 4px; /* Overrides the default font size in the theme. */ --ck-font-size-base: 14px; /* Helper variables to avoid duplication in the colors. */ --ck-custom-background: hsl(177, 16%, 49%); --ck-custom-foreground: hsl(166, 21%, 65%); --ck-custom-border: hsl(161, 18%, 28%); --ck-custom-white: hsl(0, 0%, 100%); /* -- Overrides generic colors. ------------------------------------------------------------- */ --ck-color-base-foreground: var(--ck-custom-background); --ck-color-focus-border: hsl(177, 16%, 49%); --ck-color-text: hsl(0, 0%, 98%); --ck-color-shadow-drop: hsla(0, 0%, 0%, 0.2); --ck-color-shadow-inner: hsla(0, 0%, 0%, 0.1); --ck-color-button-on-color: hsl(0, 0%, 100%); --ck-color-base-active: hsl(0, 0%, 100%); --ck-color-base-active-focus: hsl(0, 0%, 100%); /* -- Overrides the default .ck-button class colors. ---------------------------------------- */ --ck-color-button-default-background: var(--ck-custom-background); --ck-color-button-default-hover-background: hsl(177, 16%, 49%); --ck-color-button-default-active-background: hsl(177, 16%, 49%); --ck-color-button-default-active-shadow: hsl(177, 16%, 49%); --ck-color-button-default-disabled-background: var(--ck-custom-background); --ck-color-button-on-background: var(--ck-custom-foreground); --ck-color-button-on-hover-background: var(--ck-custom-foreground); --ck-color-button-on-active-background: var(--ck-custom-foreground); --ck-color-button-on-active-shadow: hsl(177, 16%, 49%); --ck-color-button-on-disabled-background: var(--ck-custom-foreground); --ck-color-button-action-background: hsl(168deg 76% 42%); --ck-color-button-action-hover-background: hsl(168deg 76% 38%); --ck-color-button-action-active-background: hsl(168deg 76% 36%); --ck-color-button-action-active-shadow: hsl(168deg 75% 34%); --ck-color-button-action-disabled-background: hsl(168deg 76% 42%); --ck-color-button-action-text: var(--ck-custom-white); --ck-color-button-save: hsl(120deg 100% 46%); --ck-color-button-cancel: hsl(15deg 100% 56%); /* -- Overrides the default .ck-dropdown class colors. -------------------------------------- */ --ck-color-dropdown-panel-background: var(--ck-custom-background); --ck-color-dropdown-panel-border: var(--ck-custom-foreground); /* -- Overrides the default .ck-splitbutton class colors. ----------------------------------- */ --ck-color-split-button-hover-background: var(--ck-color-button-default-hover-background); --ck-color-split-button-hover-border: var(--ck-custom-foreground); /* -- Overrides the default .ck-input class colors. ----------------------------------------- */ --ck-color-input-background: var(--ck-custom-background); --ck-color-input-border: hsl(257deg 3% 43%); --ck-color-input-text: hsl(24deg 21% 31%); --ck-color-input-disabled-background: hsl(255deg 4% 21%); --ck-color-input-disabled-border: hsl(250deg 3% 38%); --ck-color-input-disabled-text: hsl(0deg 0% 78%); /* -- Overrides the default .ck-labeled-field-view class colors. ---------------------------- */ --ck-color-labeled-field-label-background: var(--ck-custom-background); /* -- Overrides the default .ck-list class colors. ------------------------------------------ */ --ck-color-list-background: var(--ck-custom-background); --ck-color-list-button-hover-background: hsl(24deg 27% 54% / 20%); --ck-color-list-button-on-background: var(--ck-color-base-active); --ck-color-list-button-on-background-focus: var(--ck-color-base-active-focus); --ck-color-list-button-on-text: var(--ck-color-base-background); /* -- Overrides the default .ck-balloon-panel class colors. --------------------------------- */ --ck-color-panel-background: var(--ck-custom-background); --ck-color-panel-border: var(--ck-custom-border); /* -- Overrides the default .ck-toolbar class colors. --------------------------------------- */ --ck-color-toolbar-background: var(--ck-custom-background); --ck-color-toolbar-border: var(--ck-custom-border); /* -- Overrides the default .ck-tooltip class colors. --------------------------------------- */ --ck-color-tooltip-background: hsl(252deg 7% 14%); --ck-color-tooltip-text: hsl(0deg 0% 93%); /* -- Overrides the default colors used by the ckeditor5-image package. --------------------- */ --ck-color-image-caption-background: hsl(0deg 0% 97%); --ck-color-image-caption-text: hsl(0deg 0% 20%); /* -- Overrides the default colors used by the ckeditor5-widget package. -------------------- */ --ck-color-widget-blurred-border: hsl(0deg 0% 87%); --ck-color-widget-hover-border: hsl(43deg 100% 68%); --ck-color-widget-editable-focus-background: var(--ck-custom-white); /* -- Overrides the default colors used by the ckeditor5-link package. ---------------------- */ --ck-color-link-default: hsl(190deg 100% 75%); /* -- Overrides the default content border. -------------------- */ --ck-color-base-border: var(--ck-custom-border); /* Configure the z-index of the editor UI, so when inside a Bootstrap modal, it will be rendered over the modal. */ --ck-z-default: 100 !important; --ck-z-modal: calc( var(--ck-z-default) + 2000 ) !important;}&lt;/style&gt; 調整後畫面： 參考資源： https://ckeditor.com/docs/ckeditor5/latest/installation/integrations/vuejs-v3.htmlhttps://ckeditor.com/docs/ckeditor5/latest/installation/advanced/alternative-setups/integrating-from-source-vite.htmlhttps://ckeditor.com/docs/ckeditor5/latest/framework/deep-dive/ui/theme-customization.html","link":"/2023/08/08/nuxt3/nuxt-v3-ckeditor5/"},{"title":"Nuxt.js 3.x Components 目錄－建立共用元件","text":"本篇文章同步發表於 2023 iThome 鐵人賽：Nuxt.js 3.x 筆記－打造 SSR 專案 Components 目錄用來定義 Vue 共用元件，元件的特性為將部分模板、程式碼進行封裝，讓我們可以重複使用。在 Components 建立的檔案，Nuxt 會自動引入（auto-import），接著在整個專案 pages / components / layouts 都能搭配使用 建立元件components/|—— TheHeader.vue|—— TheFooter.vue // components/TheHeader.vue&lt;template&gt; &lt;nav&gt; Header &lt;/nav&gt;&lt;/template&gt; 頁面使用元件 // pages/index.vue&lt;template&gt; &lt;div&gt; &lt;TheHeader /&gt; &lt;h1&gt;Home Page&lt;/h1&gt; &lt;/div&gt;&lt;/template&gt; 元件名稱元件名稱規則：路徑前綴（pathPrefix） + 元件名稱 範例：巢狀目錄結構如下 components/|—— home/ |—— CustomButton.vue 使用元件名稱 &lt;HomeCustomButton /&gt; 移除 / 調整路徑前綴如果元件名稱不想加上路徑前綴，在 nuxt.config 加上 pathPrefix: false，使用components/home/Button.vue 元件名稱為 &lt;CustomButton /&gt; // nuxt.config.jsexport default defineNuxtConfig({ components: [ { path: '~/components', pathPrefix: false } ]}); 或是調整前綴名稱，將 components/home/Button.vue 元件名稱調整為 &lt;SpecialCustomButton /&gt; // nuxt.config.jsexport default defineNuxtConfig({ components: [ { path: '~/components', pathPrefix: true, prefix: 'Special' } ]}); 動態元件使用 &lt;component :is=\"componentName\"&gt; 動態渲染元件，搭配 resolveComponent 輔助函式引入元件 範例：元件內容如下 components/|—— BasePrevButton.vue|—— BaseNextButton.vue 頁面上使用動態元件 // pages/index.vue&lt;template&gt; &lt;div&gt; &lt;component :is=\"isPrev ? BasePrevButton : BaseNextButton\" /&gt; &lt;button @click=\"isPrev = !isPrev\"&gt;Toggle Button&lt;/button&gt; &lt;/div&gt;&lt;/template&gt;&lt;script setup&gt;const isPrev = ref(true);const BasePrevButton = resolveComponent('BasePrevButton');const BaseNextButton = resolveComponent('BaseNextButton');&lt;/script&gt; Lazy Loading 延遲載入元件延遲載入就是載入頁面時，不會立即載入元件，等到使用元件時才加以載入，減緩資源消耗，提升網頁載入速度，像是 Notify、Modal、Footer 等元件都適合使用 導入方式很簡單，在使用元件時加上 Lazy 前綴就可以 // pages/index.vue&lt;template&gt; &lt;div&gt; &lt;TheHeader /&gt; &lt;h1&gt;Home Page&lt;/h1&gt; &lt;!-- ... --&gt; &lt;LazyTheFooter /&gt; &lt;/div&gt;&lt;/template&gt; 調整元件渲染時機（server or client）在檔名加上 .client 或是 .server 後綴即可，兩者可以搭配使用： components/|—— Poster.server.vue|—— Poster.client.vue 注意： .server 目前還在實驗階段，需在 nuxt.config 啟用功能 // nuxt.config.jsexport default defineNuxtConfig({ experimental: { componentIslands: true }}) 使用 Poster 元件，執行順序如下： 在 server 端先渲染 Poster.server 接著在 client 端 mouted 生命週期渲染 Poster.client // pages/index.vue&lt;template&gt; &lt;div&gt; &lt;Poster /&gt; &lt;/div&gt;&lt;/template&gt; 要限制元件在 client 端渲染，可以搭配 &lt;ClientOnly&gt; Nuxt 內建元件 // pages/index.vue&lt;template&gt; &lt;div&gt; &lt;ClientOnly&gt; &lt;Poster /&gt; &lt;/ClientOnly&gt; &lt;/div&gt;&lt;/template&gt; 當我們使用的第三方套件定義了&nbsp;window、document&nbsp;等瀏覽器全域變數，直接使用相關元件時會拋錯誤 window is not defined，因為 server 端預渲染時找不到變數，這時候就可以搭配 &lt;ClientOnly&gt; 使用 參考資源： https://nuxt.com/docs/guide/directory-structure/componentshttps://v3.ru.vuejs.org/guide/component-dynamic-async.html","link":"/2023/09/11/nuxt3/nuxt-v3-components/"},{"title":"Nuxt.js 3.x Composables vs Utils 目錄－自訂共用方法","text":"本篇文章同步發表於 2023 iThome 鐵人賽：Nuxt.js 3.x 筆記－打造 SSR 專案 定義在 composables 以及 utils 資料夾的檔案 Nuxt 都會自動引入（auto-imports），兩者都是用來定義複用邏輯的函式，不過使用情境有點不同，接下來分別說明。 Composables &amp; Utils 使用時機比較 composables/：組合式函式，利用 Composition API 來封裝和複用 有狀態邏輯（Stateful Logic）的函式，取代 Options API mixins/ 的功能。我們可以將不同的邏輯抽象成單獨的 composable，並組合在 setup 函式中 utils/：與 composables 做語意上的區隔，用來定義 無狀態邏輯（Stateless Logic）的函式 狀態邏輯說明： 無狀態邏輯函式：例如計算兩個數字相加的函式。當輸入值後，經過函式運算返回值，不會受其他狀態影響。無論何時輸入相同的值，都可以得到相同結果，大部分封裝共用方法屬於此類 有狀態邏輯函式：例如計數器函式，函式會控制變數。觸發函式時，狀態就會改變，每次觸發的結果不會相同 ComposablesOptions API Mixins &amp; Composition API ComposablesNuxt3 的 Composition API composables/ 與 Nuxt2 的 Options API mixins/ 比較： mixins/：當專案邏輯越來越複雜，使用多個 mixins 時，容易發生不易找到參數、方法來源，或是命名衝突的問題，且 Options API 是依照 「生命週期與性質」 拆分程式碼，結構上來說可讀性較低 composables/：Composition API 是依據 「邏輯功能」 拆分程式碼，可讀性較高，且不易造成命名衝突，適用於高複雜邏輯和多功能開發 用法一：具名匯出具名匯出會讀取 函式名稱 // composables/test.jsexport const useCount = () =&gt; { const count = ref(0); const add = () =&gt; { count.value++; }; return { count, add };} 用法二：匿名匯出匿名匯出會讀取 檔名，以此為例命名為 useCount.js 或 use-count.js，組合式函式名稱同為 useCount() // composables/useCount.js or composables/use-count.jsexport default function() { const count = ref(0); const add = () =&gt; { count.value++; }; return { count, add };} 頁面使用組合函式 // pages/index.vue&lt;template&gt; &lt;div&gt; {{ count }} &lt;button type=\"button\" @click=\"add\"&gt;add&lt;/button&gt; &lt;/div&gt;&lt;/template&gt;&lt;script setup&gt;const { count, add } = useCount();&lt;/script&gt; 延伸應用 在 composable 內使用其它 composable 使用 plugin injections // composables/useCount.jsexport const function() { const { x, y } = usePosition(); const { $hello } = useNuxtApp(); // ...} Utils名稱定義方式同 composables/ 用法一：具名匯出具名匯出會讀取 函式名稱 // utils/test.jsexport const toThousands = () =&gt; { if (!num) { return num; } const parts = num.toString().split('.'); parts[0] = parts[0].replace(/\\B(?=(\\d{3})+(?!\\d))/g, ','); return parts.join('.');} 用法二：匿名匯出匿名匯出會讀取 檔名，以此為例命名為 toThousands.js 或 to-thousands.js 編譯後名稱同為 toThousands() // utils/toThousands.js or utils/to-thousands.jsexport default num =&gt; { if (!num) { return num; } const parts = num.toString().split('.'); parts[0] = parts[0].replace(/\\B(?=(\\d{3})+(?!\\d))/g, ','); return parts.join('.');}; 使用 Utils // pages/index.vue&lt;template&gt; &lt;div&gt; $ {{ {{ toThousands(19999) }} }} &lt;/div&gt;&lt;/template&gt; 執行結果： $ 19,999 參考資源： https://nuxt.com/docs/guide/directory-structure/composableshttps://nuxt.com/docs/guide/directory-structure/utilshttps://ithelp.ithome.com.tw/articles/10279321","link":"/2023/07/11/nuxt3/nuxt-v3-composables-vs-utils/"},{"title":"Nuxt.js 3.x Data fetching 串接 API－$fetch、useAsyncData、useFetch","text":"本篇文章同步發表於 2023 iThome 鐵人賽：Nuxt.js 3.x 筆記－打造 SSR 專案 先前在 Nuxt2 介紹如何使用 axios 取得 API 資料（文章連結） Nuxt3 提供了全域可使用的內建函式庫 $fetch 以及 composables useFetch、useAsyncData，不需要在另外安裝套件，三個方法依據時機搭配使用，可以確保整體兼容性與快取效能，且能避免重複請求的問題 Nuxt2 的 asyncData 以及 fetch 方法，在 Nuxt3 調整為 useAsyncData 與 useFetch $fetchNuxt3 使用 ofetch 建立全域使用 $fetch 方法，適合用來處理 透過使用者互動觸發的 API 請求 $fetch 不適合直接定義在 setup function，會導致 API 請求兩次：伺服器端跟用戶端各一次，因為 $fetch 不會將狀態從伺服器端傳輸到用戶端，如果要在 setup function 定義，官方建議使用 useFetch 或是 useAsyncData + $fetch 使用方式： $fetch(url, options) 參數： url：API url options method baseURL body ignoreResponseError：是否忽略 status error retry：發生錯誤時重新請求次數（預設 1，POST、PUT、PATCH、DELETE 預設 0） query Interceptors：攔截器，包含 onRequest、onRequestError、onResponse、onResponseError，見下面說明 範例：將 $fetch 包裝在 submit() 方法內，填寫完表單後，按下送出發出 API 請求 &lt;template&gt; &lt;div&gt; &lt;label for=\"name\"&gt;name&lt;/label&gt; &lt;input type=\"text\" name=\"name\" v-model=\"user.name\"&gt; &lt;label for=\"phone\"&gt;phone&lt;/label&gt; &lt;input type=\"text\" name=\"phone\" v-model=\"user.phone\"&gt; &lt;button type=\"button\" @click=\"submit()\"&gt;submit&lt;/button&gt; &lt;/div&gt;&lt;/template&gt;&lt;script setup&gt;const user = reactive({ name: '', phone: ''});const submit = async () =&gt; { const response = await $fetch('/api/user', { method: 'POST', body: { ...user } }); console.log('success', response);};&lt;/script&gt; 使用攔截器（interceptors）const response = await $fetch('/api/user', { onRequest({ request, options }) { // 設定請求時的 headers options.headers.authorization = '...' }, onRequestError({ request, options, error }) { // 捕捉請求時發生的錯誤 }, onResponse({ request, response, options }) { // 處理請求回覆資料 return response._data; }, onResponseError({ request, response, options }) { // 捕捉請求回覆時發生的錯誤 }}) useAsyncData非同步函式的封裝組合方法，並不能直接發出 API 請求，要搭配 handler 非同步函式使用，在 setup function 直接觸發，於伺服器端發出請求取得資料，並將狀態傳輸到用戶端 使用方式（搭配 $fetch handler）： useAsyncData(key, () =&gt; $fetch(url)) 參數： key：唯一值，確保 API 不會重複請求，如果沒有提供，useAsyncData 會自動產生 handler：回傳一個值的非同步函式 options： lazy：是否在路由載入後才執行非同步函式，預設 false，因此會在函式執行完成，取得資料後才切換畫面 default：工廠函式，用來設定非同步函式請求完成前的預設值，lazy: true 特別適用 server：是否在伺服器端進行請求，預設 true transform：一個函式，用於修改 handler 請求的結果 pick：handler 回傳結果如果為物件，可以選擇需要的 key 組成新物件 watch：監聽響應式資料變更，自動重新請求 immediate：是否立即觸發，預設 true 回傳值： data：非同步函式回傳結果 pending：Boolean 值，用來表示是否還在執行中 refresh / execute：重新執行函式 error：請求失敗的回傳物件 status：表示請求狀態（”idle”,&nbsp;“pending”,&nbsp;“success”,&nbsp;“error”） 範例： &lt;template&gt; &lt;div&gt; {{ user }} &lt;button type=\"button\" @click=\"lastUser()\"&gt;prev&lt;/button&gt; &lt;button type=\"button\" @click=\"nextUser()\"&gt;next&lt;/button&gt; &lt;/div&gt;&lt;/template&gt;&lt;script setup&gt;const id = ref(1);const url = computed(() =&gt; `/api/user/${id.value}`);const { data: user, refresh } = useAsyncData('user', () =&gt; $fetch(url.value));const nextUser = () =&gt; { id.value++; refresh();};const lastUser = () =&gt; { id.value--; refresh();};&lt;/script&gt; useFetch為 useAsyncData 跟 $fetch 包裝後的語法糖，等同於：useAsyncData(key, () =&gt; $fetch(url)) 請求時會依據 url 跟 options 自動產生 key，在 setup function 直接觸發，於伺服器端發出請求取得資料，並將狀態傳輸到用戶端。可以使用 $fetch 的攔截器 onRequest、onRequestError、onResponse、onResponseError 使用方式： useFetch(url, options) 參數：繼承 $fetch 跟 useAsyncData 的選項 回傳值：繼承 useAsyncData 的回傳值 範例： &lt;template&gt; &lt;div&gt; {{ data }} &lt;button type=\"button\" @click=\"refresh()\"&gt;refresh&lt;/button&gt; &lt;/div&gt;&lt;/template&gt;&lt;script setup&gt;const { data, pending, refresh, execute, error, status } = useFetch('/api/users');&lt;/script&gt; 監聽參數變化自動發出請求當參數為響應式時（ref,&nbsp;reactive,&nbsp;computed），useFetch 會自動發出請求 範例：當狀態改變，useFetch 會自動重新觸發，因此我們只需要專注在 id 的變化即可 &lt;template&gt; &lt;div&gt; {{ userInfo }} &lt;button type=\"button\" @click=\"lastUser()\"&gt;last&lt;/button&gt; &lt;button type=\"button\" @click=\"nextUser()\"&gt;next&lt;/button&gt; &lt;/div&gt;&lt;/template&gt;&lt;script setup&gt;const id = ref(1);const url = computed(() =&gt; `/api/user/${id.value}`);const { data: userInfo } = useFetch(url);const lastUser = () =&gt; { id.value--;};const nextUser = () =&gt; { id.value++;};&lt;/script&gt; 比較範例：使用 $fetch 取代 useFetch 前面提到使用 $fetch 請求需透過函式包裝，如以下範例 getData()，以避免重複請求，除了需在生命週期先呼叫 getData()，當 id 更新時也需要手動觸發 getData()，相對的維護跟易讀性較低 &lt;template&gt; &lt;div class=\"m-4\"&gt; {{ userInfo }} &lt;button type=\"button\" @click=\"lastUser()\"&gt;last&lt;/button&gt; &lt;button type=\"button\" @click=\"nextUser()\"&gt;next&lt;/button&gt; &lt;/div&gt;&lt;/template&gt;&lt;script setup&gt;const id = ref(1);const userInfo = ref({});const getData = async () =&gt; { const response = await $fetch(`/api/user/${id.value}`); userInfo.value = response;};onMounted(() =&gt; { getData();});const lastUser = () =&gt; { id.value--; getData();};const nextUser = () =&gt; { id.value++; getData();};&lt;/script&gt; useLazyAsyncData &amp; useLazyFetch等同於 useAsyncData 與 useFetch options 設定 lazy: true 參考資源： https://medium.com/comsystoreply/nuxt-3-usefetch-reactive-vue-at-its-best-14729f6f5be7https://ithelp.ithome.com.tw/articles/10298741","link":"/2023/07/19/nuxt3/nuxt-v3-data-fetching/"},{"title":"Nuxt.js 3.x Universal（SSR）專案部署到 Firebase","text":"本篇文章同步發表於 2023 iThome 鐵人賽：Nuxt.js 3.x 筆記－打造 SSR 專案 專案開發完成後，終於到最後一步「部署」，本篇將說明 Universal 專案部署到 Firebase。Universal 渲染模式需要伺服器才能運作，因此會搭配 Firebase Cloud Functions（Serverless）來協助處理 SSR 的部分。 Universal Rendering 相關說明可以參考 這篇文章 實作分為以下步驟： 申請 Firebase Project 透過 CLI 部署至 Firebase 申請 Firebase Project到 Firebase Console 新增專案 開啟新增的專案，點擊建構 → 加入 Hosting 與 Function（需升級為付費方案，為 Pay as you go 制度，可以限制預算上限） 到此步 Firebase 專案就建立完成，先記著專案 ID，後面部署會使用到 透過 CLI 部署至 Firebase接著回到我們的 Nuxt App STEP1：安裝 CLI首先安裝 Firebase CLI（Command-Line Interface）指令列工具 npm install firebase-tools STEP2：登入 Firebase接著透過指令登入 Firebase firebase login 登入成功後會看到如下畫面 STEP3：初始化 firebase 專案firebase init hosting 接著選擇預部署的 Firebase 專案 ID，也就是前面新增的專案 託管設定依序選擇如下，接著會自動產生 firebase.json 跟 .firebaserc 兩支檔案 注意：必須要刪除上一步驟自動產生的 public/404.html 跟 public/index.html 兩個靜態檔，否則部署後畫面會受影響 STEP4：配置 nuxt.config preset：預設為 node.js server，調整為 firebase，當執行 npm run build 時，會產生符合 Firebase 託管所需的檔案內容 firebase.gen：預設使用第一代 Cloud Functions，這裡調整為二代（一、二代比較） // nuxt.config.jsexport default defineNuxtConfig({ nitro: { preset: 'firebase', firebase: { gen: 2 } }}); STEP5：配置 firebase.json 與 .firebasercfirebaserc如果前面步驟運作順利，預期 .firebaserc 會綁定 Firebase 專案 ID 如下，不需異動 // .firebaserc{ \"projects\": { \"default\": \"&lt;your_project_id&gt;\" }} firebase.json需手動調整，這個步驟很重要，會影響專案編譯結果 functions（Cloud Functions） source：指定 Cloud Functions 程式碼路徑 hosting（Firebase Hosting） site：Firebase 專案 ID public：專案靜態目錄路徑 rewrites：改寫 URL 規則，所有的 URL 請求都會由名為「server」的 Cloud Functions 處理，也就是由伺服器端處理所有請求（SSR） predeploy：部署前預先執行的指令。這一段的設定為：進到編譯後的 .output/server 資料夾，刪除 node_modules 並重新安裝，否則在執行部署時會發生找不到 firebase-functions 套件的錯誤 注意：rm -rf node_modules&nbsp;是 macOS 跟 Linux 的指令，Windows 須調整為&nbsp;rmdir /s /q node_modules // firebase.json{ \"functions\": { \"source\": \".output/server\", \"runtime\": \"nodejs18\" }, \"hosting\": { \"site\": \"&lt;your_project_id&gt;\", \"public\": \".output/public\", \"cleanUrls\": true, \"rewrites\": [ { \"source\": \"**\", \"function\": \"server\" }], \"predeploy\": [ \"cd .output/server &amp;&amp; rm -rf node_modules &amp;&amp; npm install\" ] }} STEP6：編譯與部署首先將專案打包 npm run build 打包後的檔案放在根目錄 .output 資料夾內 .output/|—— public/ |—— ...|—— server/ |—— ...|—— nitro.json 接著部署到 Firebase firebase deploy 看到以下訊息表示部署成功囉！ 在 Firebase 專案可以看到 Cloud Function 名稱預設為「server」 如果發生 funciton 部署失敗問題，可以在 nuxt.config 設定 serverFunctionName 如下 // nuxt.config.jsexport default defineNuxtConfig({ nitro: { preset: 'firebase', firebase: { gen: 2, serverFunctionName: 'server' } }}) 打開 Hosting URL，可以看到我們的網站，也可以透過 Firebase 儀表板來查看發布紀錄與用量 範例檔：本篇程式碼放在 GitHub 提供參考：連結 參考資源： https://nitro.unjs.io/deploy/providers/firebasehttps://firebase.google.com/docs/hosting/quickstarthttps://www.youtube.com/watch?v=AzO-KVMx7lo","link":"/2023/10/08/nuxt3/nuxt-v3-deploy-to-firebase/"},{"title":"Nuxt.js 3.x Nuxt DevTools 提升開發者體驗","text":"為什麼需要 Nuxt DevTools？Nuxt DevTools 是 Nuxt 團隊推出的視覺化開發工具，用來協助我們快速了解 Nuxt 專案的內容，近一步提升開發者體驗（DX，Developer Experience）。 關於開發者體驗（DX）介紹，這裡推薦一篇文章 Nuxt3 提供許多內建功能，例如： 預設使用 Vite 打包工具，支援 hot module replacement（HMR） 引入伺服器引擎 Nitro，讓我們可以將應用程式部署到 Vercel、Netlify、Cloudflare 等託管服務 許多內建功能，像是支援 TypeScript、各種組合式函式、SEO 搜尋引擎優化輔助函式等 auto-imports 自動引入功能 依據檔案結構自動生成路由與 API 路徑 提供許多模組，讓開發者可以快速整合所需的功能，不需另外進行配置 這些功能是 DX 最直接具體的實踐，雖然能讓我們能輕鬆建立 Nuxt3 專案，但也會面臨「資訊透明度不足」的問題。抽象化設計是一把雙面刃，在化繁為簡、避免重工的同時，也會增加額外的學習負擔與除錯困難。 Nuxt DevTools 便是為了解決此問題而設計的視覺化工具，能夠提升 Nuxt 框架和應用程式的透明度、找到效能瓶頸，以及協助我們管理應用和配置。 安裝 Nuxt DevTools注意：Nuxt 版本需為 v3.1.0 以上 自動安裝如果是透過 Nuxt CLI 安裝，預設會一起安裝與啟用 Nuxt DevTools // nuxt.config.jsexport default defineNuxtConfig({ devtools: { enabled: true }}) 手動安裝安裝 nuxt 整合模組 @nuxt/devtools npm i -D @nuxt/devtools 接著在 nuxt.config 配置 // nuxt.config.jsexport default defineNuxtConfig({ modules: [ '@nuxt/devtools' ]}) 要關閉 devtools，設定 enabled: false 即可，devtools 模組相關配置 參考文件 Nuxt Devtools 導覽安裝並啟用 devtools 後，可以在畫面底部看到一顆 icon，點擊後繼續點擊左側 icon 開啟工具面板 Overview可以看到專案 Nuxt 與 Vue 版號，以及頁面、元件、數量、引入的函式、模組、插件數量，也可以直接透過畫面操作升級 Nuxt 版本 Pages顯示頁面路徑與相關資訊。以下為例，當前頁面為 /about，layout 為 default，點擊其他路徑可以切換頁面 Components顯示專案內使用的元件以及來源路徑，後面會標示該元件在本頁的使用次數（ex：x1），點擊路徑會自動在編輯器內開啟檔案 如果使用 VSCode 開發，點擊路徑不會自動開啟檔案，且終端機拋以下錯誤 Could not open TheHeader.vue in the editor. 6:04:57 PMThe editor process exited with an error: spawn code ENOENT. 在 VSCode 執行 install code command in Path 即可解決 點擊右側或是底部的錨點 icon，接著可以直接透過畫面檢查元件，點擊元件會自動在編輯器開啟檔案 元件分為四類： User components：專案內自訂的元件 Runtime components：運行的時候使用的元件 Build-in components：內建元件，像是 &lt;ClientOnly /&gt; Components from libraries：第三方套件或是模組提供的元件，像是 &lt;NuxtWelcome /&gt; 也可以透過右上角 Toggle View 按鈕來切換為圖形視圖，圖形視圖可以更清晰的顯示元件間的關聯與依賴 Imports顯示專案內自動引入（auto-imports）的函式名稱與來源路徑。同 Components，後面會標示該函式在本頁的使用次數（ex：x1），點擊路徑會自動在編輯器內開啟檔案 自動引入函式分為三類： User composables：專案內自訂的函式，像是 Composables 組合式函式或是 Utils 輔助函式 Build-in composables：Nuxt 內建函式，像是 useNuxtApp()、navigateTo() Composables from libraries：第三方套件或是模組提供的函式，像是 @pinia/nuxt 模組的 defineStore() Modules顯示專案內安裝的模組與相關資訊，像是 github repo、官方文件、版本資訊等 也可以直接透過操作面板來安裝模組或是升版 Assets顯示 public/ 目錄內的靜態檔，可以看到詳細的檔案資訊、下載、更新名稱、刪除，也可以透過面板上傳檔案 Runtime Configs顯示專案 App Config 與 Runtime Config 設定，並可透過面板進行編輯 Payload顯示透過 useState、useAsyncData、useFetch 建立的狀態與資料封包，可以由面板手動操作 useAsyncData、useFetch 重新發出請求 Open Graph顯示該頁面的 Meta Tags 配置，以及缺少的 Tags 資訊，協助我們進行 SEO 搜尋引擎優化，並提供在 Twitter、Facebook 和 LinkedIn 等社群的預覽畫面 複製 Code Snippet 程式碼，即可快速補全缺少的 Meta Tags Plugins顯示專案內所有插件，因為插件會專案載入前就執行，因此執行時間會影響整體效能，可以透過右側的執行時間來找出效能瓶頸 Timeline追蹤網頁操作每個事件執行時間，可以協助我們分析並優化網頁效能 Server Routes顯示專案內在 server/ 目錄建立的 API 或是 sitemap 等在伺服器端建立的路由 Hooks協助我們監控瀏覽器端與伺服器端每個 Lifecycle Hook 花費的時間、註冊了多少監聽器，以及被調用的次數，有助於找出效能瓶頸 Lifecycle Hooks 參考 官方文件 Virtual FilesNuxt 提供了一套虛擬文件系統（VFS，Virtual File System），根據我們的目錄結構自動生成虛擬檔案。透過 devtools，不需進到 .nuxt 資料夾，即可查看相關檔案，對於進階 debug 有很大的幫助 Inspect整合 vite-plugin-inspect 套件，讓我們可以檢視各插件或檔案透過 Vite 編譯、轉譯的過程，協助找出潛在風險 參考資源： https://devtools.nuxt.com/https://nuxt.com/blog/introducing-nuxt-devtools","link":"/2023/10/27/nuxt3/nuxt-v3-devtools/"},{"title":"Nuxt.js 3.x 目錄結構 Directory Structure","text":"本篇文章同步發表於 2023 iThome 鐵人賽：Nuxt.js 3.x 筆記－打造 SSR 專案 Nuxt3 定義了完整的目錄規則，讓我們可以輕鬆配置功能，專注在開發上 透過 npx nuxi@latest init &lt;project-name&gt; 安裝專案後，可以看到如下的預設目錄 看起來分類似乎有點不齊全，接下來跟著官方文件一起建立完整的專案目錄 my-app/|—— .nuxt/|—— .output/|—— assets/|—— components/|—— composables/|—— content/|—— layouts/|—— middleware/|—— node_modules/|—— pages/|—— plugins/|—— public/|—— server/ |—— api/ |—— routes/ |—— middleware/|—— utils/|—— .env|—— .gitignore|—— .nuxtignore|—— app.config.ts|—— app.vue|—— nuxt.config.ts|—— package.json|—— tsconfig.json .nuxtNuxt 在編譯過程中生成的暫存資料夾。是 Nuxt 執行編譯和 server 端渲染時使用的重要資源，無法手動調整裡面的內容（每次執行編譯時會覆寫） .output執行生產環境編譯 nuxt build（npm run build）時自動生成的資料夾，跟 .nuxt 資料夾一樣，每次執行編譯時會更新覆寫 assets用來存放像是 CSS、Sass、字體、圖片等需要被 webpack 或是 Vite 編譯的靜態資源（壓縮、最佳化），如不需經過編譯，則存放於 public/ components用來定義 Vue 共用元件，Nuxt 會自動引入，名稱規則為：路徑前綴 + 元件名稱，例如巢狀目錄結構如下 components/|—— base/ |—— about/ |—— Button.vue Button.vue 的元件名稱為 &lt;BaseAboutButton /&gt; composables組合式函式，利用 Composition API 來封裝和複用 有狀態邏輯（Stateful Logic）的函式，取代 Options API mixins 的功能。定義在 composables/ 內的檔案 Nuxt 會自動引入 我們可以將不同的邏輯抽象成單獨的 composable，並組合在 setup 函式中。比起 mixins ，composable 協助我們更好理解組件的結構和功能，並提高程式碼的可讀性 以 composables/useCounter.js 為例 // composables/useCounter.jsexport default function() { const count = ref(0); const increment = () =&gt; { count.value++; }; return { count, increment };} 在元件內使用共用方法 // pages/count.vue&lt;template&gt; &lt;div&gt; &lt;span&gt;{{ count }}&lt;/span&gt; &lt;button type=\"button\" @click=\"increment\"&gt;add&lt;/button&gt; &lt;/div&gt;&lt;/template&gt;&lt;script setup&gt;const { count, increment } = useCounter();&lt;/script&gt; composables 和 utils 比較可以參考 這篇文章 content搭配 Nuxt Content 套件，可以讀取 content/ 目錄，並解析存放於此資料夾內的 .md、.yml、.csv&nbsp;以及&nbsp;.json 檔案，建立一套內容管理系統（CMS），主要功能： 搭配 components 元件渲染内容 使用類似 mongodb 的 API 來 query 文章內容 在 Markdown 文件中使用 Vue components 使用 Shiki 程式碼 highlight 自動渲染內容與路由 簡單來說，Nuxt Content 能夠解析 Markdown 語法文章，做到像 Hexo 一樣的功能，協助我們打造技術部落格 Nuxt Content 相關應用推薦參考 這篇文章 layouts用來存放共用模板，官方文件提到，如果整個專案只有一個模板，建議直接在 app.vue 定義即可 預設模板首先新增預設模板 layouts/default.vue，必須加上 &lt;slot /&gt;，引用的頁面才能插入內容 // layouts/default.vue&lt;template&gt; &lt;div&gt; default layout &lt;slot /&gt; &lt;/div&gt;&lt;/template&gt; 在頁面上使用 layout // app.vue&lt;template&gt; &lt;div&gt; &lt;NuxtLayout&gt; &lt;NuxtPage /&gt; &lt;/NuxtLayout&gt; &lt;/div&gt;&lt;/template&gt; 使用其他模板layouts/|—— default.vue|—— custom.vue 如果我們想在單一元件使用 custom.vue layout，可以用 definePageMeta 覆蓋預設模板 // pages/about.vue&lt;script&gt;definePageMeta({ layout: 'custom'});&lt;/script&gt; middlewareNuxt 內的 路由守衛（Navigation Guards），相當於 Vue Router 內的 beforeEach callback，協助我們在進到頁面前執行一些事件，像是權限檢查 middleware 定義方式： 匿名：直接在單一元件檔內定義 具名：在 middleware/ 定義，並在需要的頁面引入 全域：同具名的定義方式，不過檔名需加上 .global 後綴，在所有頁面切換時自動執行 middleware/|—— auth.ts|—— setup.global.ts 建立一個 middleware // middleware/auth.tsexport default defineNuxtRouteMiddleware((to, from) =&gt; { const auth = useState('auth'); if (!auth.value.isAuth) { return navigateTo('/login'); }}); 在頁面內使用 // pages/about.vue&lt;script setup&gt;definePageMeta({ middleware: [ function (to, from) { // 匿名方式 // 客製 middleware }, 'auth' ]});&lt;/script&gt; pages用來配置主要頁面的資料夾，定義後 Nuxt 會自動整合 Vue Router，依照資料夾以及檔案結構配置路由，例如：pages/work.vue 會被映射到 /work 如果要使用 pages/，app.vue 需加上 &lt;NuxtPage /&gt; 用於顯示定義的頁面 動態路由動態路由使用方括號 [] 包覆（Nuxt2 使用下底線 _） 範例： pages/|—— index.vue|—— products-[category]/ |—— [id].vue 透過 $route 可以取得 category 跟 id 值： &lt;template&gt; &lt;p&gt;{{ $route.params.category }} - {{ $route.params.id }}&lt;/p&gt;&lt;/template&gt; 當我們切到頁面 /products-bag/112345，畫面渲染如下： bag - 112345 Catch-all Route使用 [...slug].vue 匹配該路徑下的所有層級路由，可以用來處理找不到路由的預設頁面 範例： pages/|—— index.vue|—— [...slug].vue 當使用者輸入不存在的頁面，例如：/hello 或是 /hello/claire，會自動轉到 [...slug].vue plugins用來定義插件，plugins/ 內的檔案 Nuxt 會自動引入，如果要限制在 server 或是 client 端使用，檔名需加上 .server 或 .client 後綴 範例：引入 vue3-notification 第三方套件 安裝套件 npm i @kyvg/vue3-notification 建立 plugin plugins/|—— notification.client.ts import Notifications from '@kyvg/vue3-notification';export default defineNuxtPlugin(nuxtApp =&gt; { nuxtApp.vueApp.use(Notifications);}); 頁面上使用 &lt;script&gt;import { useNotification } from '@kyvg/vue3-notification';export default { setup() { const { notify } = useNotification(); onMounted(() =&gt; { notify({ title: \"Authorization\", text: \"You have been logged in!\", }); }); }};&lt;/script&gt; public靜態資源資料夾（同 Nuxt2 的 static/），用來存放不需要被編譯的檔案，像 CSS、 文字或圖片，透過根目錄&nbsp;/ 即可使用 public/ 檔案，檔案如需被編譯，則存放於 assets/ serverNuxt3 搭配新的伺服器引擎 Nitro，讓我們可以在 server 端定義內容，像是建立 API 以及透過 Server Middleware 處理事件 簡單說明 server/ 內的資料夾功能： api：建立帶有 /api 前綴的 API 路徑 routes：建立不帶 /api 前綴的 API 路徑 middleware：在每次發出請求時觸發。跟 router middleware 不同，頁面切換（page navigation）並不會觸發 server middleware utils定義在 utils/ 內的檔案 Nuxt3 會自動引入，官方文件提到 utils/ 資料夾的拆分主要是為了跟 composables/ 做區隔，前面有提到 composables/ 利用 Composition API 來封裝和複用&nbsp;有狀態邏輯（Stateful Logic），而 utils/ 則用來定義&nbsp;無狀態邏輯（Stateless Logic） 以 utils/toThousands.js 為例（將數字帶入千分號） // utils/toThousands.jsexport default num =&gt; { if (!num) { return num; } const parts = num.toString().split('.'); parts[0] = parts[0].replace(/\\B(?=(\\d{3})+(?!\\d))/g, ','); return parts.join('.');}; 在頁面使用 // pages/count.vue&lt;template&gt; &lt;div&gt; $ {{ toThousands(19999) }} &lt;/div&gt;&lt;/template&gt; 編譯結果： $ 19,999 .nuxtignore設定 Nuxt 編譯時忽略根目錄 layouts、pages、components、composables、middleware 內的檔案 # 忽略 layout custom.vuelayouts/custom.vue# 忽略 layout -ignore.vue 結尾的檔案layouts/*-ignore.vue# 忽略 page about.vuepages/about.vue# 忽略 ignore 資料夾內的 page 檔案pages/ignore/*.vue# 忽略 route middleware custom 資料夾內檔案，排除 custom/bar.jsmiddleware/custom/*.js!middleware/custom/bar.js app.config.ts設定全域共用的資料，只能在 client 端取得 官方文件提到，不建議將任何機密資料存放於此 // app.config.tsexport default defineAppConfig({ theme: { color: '#0d6efd' }}) 在頁面使用 // pages/about.vue&lt;script&gt;export default { setup() { const appConfig = useAppConfig(); onMounted(() =&gt; { console.log(appConfig.theme.color); // output: #0d6efd }); }};&lt;/script&gt; app.vue專案進入點，Nuxt3 將 app.vue 移到目錄頁，讓開發者可以只使用 app.vue 來建置網站（例如單頁 Landing Page），而不定義 pages/ 資料夾。 如果要使用 pages/，app.vue 需加上 &lt;NuxtPage /&gt; 用於顯示定義的頁面（功能同 Vue Router &lt;router-view&nbsp;/&gt;） // app.vue&lt;template&gt; &lt;div&gt; &lt;NuxtLayout&gt; &lt;NuxtPage /&gt; &lt;/NuxtLayout&gt; &lt;/div&gt;&lt;/template&gt; nuxt.config.tsNuxt 設定檔，相關設定 參考文件 // nuxt.config.tsexport default defineNuxtConfig({ // My Nuxt config}) tsconfig.json配置 extends 或是覆蓋預設的 TypeScript 設定 如要設定路徑別名，若直接在 tsconfig.json 設定，將會覆寫預設的 alias，建議在 nuxt.config 檔設定，Nuxt 會加到自動生成的 tsconfig // tsconfig.json{ \"extends\": \"./.nuxt/tsconfig.json\" // 自動生成的 tsconfig} 參考資源： https://ithelp.ithome.com.tw/articles/10295432https://nuxt.com/docs/guide/directory-structure/nuxt","link":"/2023/07/07/nuxt3/nuxt-v3-directory-structure/"},{"title":"Nuxt.js 3.x 自訂 Error Page 與錯誤處理","text":"本篇文章同步發表於 2023 iThome 鐵人賽：Nuxt.js 3.x 筆記－打造 SSR 專案 Nuxt 3 提供大量內建功能，包括預設錯誤頁面，可以在隱藏資料夾 .nuxt/dev/index.mjs 看到，我們也可以自訂錯誤頁面，Nuxt 預設錯誤畫面如下： 自訂錯誤頁在專案根目錄新增 error.vue，error page 不具有路由，因此不能使用 definePageMeta 方法 檔案結構如下： |—— app.vue|—— error.vue 錯誤頁會收到一個名為 error 的 props 物件 error 物件內容包含以下參數 url、statusCode、statusMessage、message、description、data，自訂參數可以放在 data 內 // error.vue&lt;template&gt; &lt;div&gt; &lt;h2&gt;{{ error.statusCode }}&lt;/h2&gt; &lt;p&gt;{{ error.message }}&lt;/p&gt; &lt;NuxtLink to=\"/\"&gt;回首頁&lt;/NuxtLink&gt; &lt;/div&gt;&lt;/template&gt;&lt;script setup&gt;const props = defineProps({ error: { type: Object, required: true }});&lt;/script&gt; 錯誤頁面渲染時機當發生致命錯誤（fatal error）時，自動觸發錯誤頁面，如果是非致命錯誤（non-fatal error）只會拋出錯誤訊息，可能觸發錯誤頁的時機如下： Server Side 執行 Nuxt plugins 發生錯誤 編譯 Vue app 到 HTML 發生錯誤 Server API 發生錯誤 Client Side 執行 Nuxt plugins 發生錯誤 app:beforeMount 生命週期發生錯誤 不會被 onErrorCaptured 方法或 vue:error 生命週期捕捉的錯誤 Vue app 初始化與 app:mounted 生命週期發生錯誤 輔助函式透過以下輔助函式來手動觸發錯誤頁面，以及進行錯誤處理 createError同時支援 server-side 與 client-side，用來建立帶有錯誤訊息的物件 server-side：觸發錯誤頁面，視為致命錯誤（fatal error） client-side：拋出非致命錯誤，如要顯示錯誤頁面，需加上 fatal: true // pages/user/[id].vue&lt;script setup&gt;const route = useRoute();const { data } = await useFetch('/api/user/${route.params.id}');if (!data.value) { throw createError({ statusCode: 404, statusMessage: 'Page Not Found', fatal: true });}&lt;/script&gt; showError功能同 createError server-side：需定義在 middleware、plugins 或是 setup() 方法內，觸發錯誤頁面 client-side：觸發錯誤頁面 // pages/user/[id].vue&lt;script setup&gt;const route = useRoute();const { data } = await useFetch('/api/user/${route.params.id}');if (!data.value) { throw showError({ statusCode: 404, statusMessage: 'Page Not Found' });}&lt;/script&gt; clearError用來清除當前處理的錯誤訊息，可以透過 redirect 重新導向到其他頁面 // error.vue&lt;template&gt; &lt;div&gt; &lt;h2&gt;{{ error.statusCode }}&lt;/h2&gt; &lt;p&gt;{{ error.message }}&lt;/p&gt; &lt;button @click=\"handleError\"&gt;回首頁&lt;/button&gt; &lt;/div&gt;&lt;/template&gt;&lt;script setup&gt;const props = defineProps({ error: { type: Object, required: true }});const handleError = () =&gt; clearError({ redirect: '/' });&lt;/script&gt; 參考資源： https://nuxt.com/docs/getting-started/error-handlinghttps://nuxt.com/docs/api/advanced/hooks","link":"/2023/09/07/nuxt3/nuxt-v3-error-page/"},{"title":"Nuxt.js 3.x 導入 I18n 實作多國語系","text":"本篇文章同步發表於 2023 iThome 鐵人賽：Nuxt.js 3.x 筆記－打造 SSR 專案 @nuxtjs/i18n 版本：v8.0.0-rc.3 多國語系讓我們的網站邁向國際市場，本篇將說明如何搭配 Nuxt3 整合模組 @nuxtjs/i18n 進行開發 @nuxtjs/i18n 簡介 整合 Vue I18n 自動產生路由 SEO 搜尋引擎最佳化 Lazy Loading 延遲載入 自動偵測語言並切換 多國語言支援不同域名 套件安裝Nuxt3 需搭配 v8 版本，目前為 rc 版，透過 next tag 安裝 npm install -D @nuxtjs/i18n@next nuxt.config 配置模組// nuxt.config.jsexport default defineNuxtConfig({ modules: [ '@nuxtjs/i18n' ]}) nuxt.config 設定模組選項i18n module 完整選項參考 官方文件，以下範例配置： strategy：定義路由是否加上語系前綴，範例使用 prefix，所有語系都會加上路徑前綴（ex: http://localhost:3000/zh/） langDir：翻譯檔目錄路徑，範例為根目錄下 locales/ 資料夾 locales：語系選項，範例設定繁體中文跟英文，存放於 langDir 目錄下，以下範例檔結構： locales/ |—— en.js |—— zh.jsnuxt.config.js defaultLocale：預設語系 detectBrowserLanguage：是否自動偵測使用者瀏覽器語系 useCookie：設定為 true 將語系儲存於 cookie，避免使用者每次進入網站都重新導向 cookieKey：預設 i18n_redirected redirectOn：設定為 root 根目錄，只在根目錄偵測語系，避免使用者進入網站時被重新導向，以利 SEO // nuxt.config.jsexport default defineNuxtConfig({ i18n: { strategy: 'prefix', langDir: 'locales', locales: [ { code: 'en', iso: 'en-US', file: 'en.js' }, { code: 'zh', iso: 'zh-TW', file: 'zh.js' } ], defaultLocale: 'zh', detectBrowserLanguage: { useCookie: true, cookieKey: 'i18n_redirected', redirectOn: 'root' } }}) 新增語系翻譯檔路徑結構： locales/ |—— en.js |—— zh.js // locales/en.jsexport default { welcome: 'Welcome', backHome: 'Back Home', about: { title: 'About Us', description: 'This is About Page' }}; // locales/zh.jsexport default { welcome: '您好', backHome: '回首頁', about: { title: '關於我們', description: '這是關於我們頁面' }}; 多國語系基本應用 useLocalePath：依據當前語系解析路徑，EX：/about → /zh/about useSwitchLocalePath：用來切換語系 $t：Vue 實體方法，用來翻譯訊息 // pages/about.vue&lt;template&gt; &lt;div class=\"m-4\"&gt; &lt;NuxtLink :to=\"localePath('/')\"&gt;{{ $t('backHome') }}&lt;/NuxtLink&gt; &lt;div&gt; &lt;NuxtLink :to=\"switchLocalePath('en')\"&gt;English&lt;/NuxtLink&gt; &lt;NuxtLink :to=\"switchLocalePath('zh')\"&gt;繁體中文&lt;/NuxtLink&gt; &lt;/div&gt; &lt;h2&gt;{{ $t('welcome') }}&lt;/h2&gt; &lt;h3&gt;{{ $t('about.title') }}&lt;/h3&gt; &lt;p&gt;{{ $t('about.description') }}&lt;/p&gt; &lt;/div&gt;&lt;/template&gt;&lt;script setup&gt;const localePath = useLocalePath();const switchLocalePath = useSwitchLocalePath();&lt;/script&gt; 畫面呈現如下： 單一元件翻譯前面說明如何建立各語系翻譯檔，也可以單獨在元件內透過 &lt;i18n&gt; 定義翻譯資訊 useScope: 'local' 將 t 方法作用域限制於元件內，這麼做可以避免受到全域翻譯檔影響 // pages/about.vue&lt;template&gt; &lt;div class=\"m-4\"&gt; 元件翻譯 &lt;h2&gt;{{ t('welcome') }}&lt;/h2&gt; 全域翻譯 &lt;h2&gt;{{ $t('welcome') }}&lt;/h2&gt; &lt;/div&gt;&lt;/template&gt;&lt;i18n lang=\"yaml\"&gt; en: welcome: 'hello world' zh: welcome: '哈囉世界'&lt;/i18n&gt;&lt;script setup&gt;const { t } = useI18n({ useScope: 'local'});&lt;/script&gt; 全域翻譯檔 // locales/zh.jsexport default { welcome: '您好'}; 畫面呈現如下： 插入動態變數1. 具名變數// pages/about.vue&lt;template&gt; &lt;h1&gt;{{ t('hello', { name: 'Daniel' }) }}&lt;/h1&gt;&lt;/template&gt;&lt;i18n lang=\"yaml\"&gt; en: hello: 'hello {name}' zh: hello: '哈囉 {name}'&lt;/i18n&gt;&lt;script setup&gt;const { t } = useI18n({ useScope: 'local'});&lt;/script&gt; 2. 匿名變數（陣列）// pages/about.vue&lt;template&gt; &lt;h1&gt;{{ t('hello', [ 'Daniel' ]) }}&lt;/h1&gt;&lt;/template&gt;&lt;i18n lang=\"yaml\"&gt; en: hello: 'hello {0}' zh: hello: '哈囉 {0}'&lt;/i18n&gt;// ... &lt;NuxtLinkLocale&gt; 元件等同於 &lt;NuxtLink&gt; 搭配 useLocalePath() Composable，以下兩個寫法編譯後結果相同 &lt;template&gt; &lt;NuxtLinkLocale to=\"/\"&gt;{{ $t('home') }}&lt;/NuxtLinkLocale&gt;&lt;/template&gt; &lt;template&gt; &lt;NuxtLink :to=\"localePath('/')\"&gt;{{ $t('home') }}&lt;/NuxtLink&gt;&lt;/template&gt;&lt;script setup&gt;const localePath = useLocalePath();&lt;/script&gt; SEO 優化透過 useLocaleHead() 優化多國語系的 &lt;head&gt; 設定： useLocaleHead：依據當前語系回傳 head 屬性 &lt;html&gt; 標籤 lang 屬性 hreflang 標籤屬性：告訴搜尋引擎頁面使用的語言，讓使用者在搜尋時，搜尋引擎能提供對應語言給用戶 og:locale 以及 og:locale:alternate 標籤 Canonical URL（標準網址）標籤：告訴搜尋引擎此頁面的主要連結，避免搜尋引擎處理重複內容網頁 addSeoAttributes：是否加上 SEO 屬性 useHead：Nuxt Composable，用來定義完整 &lt;head&gt; 標籤內容 Nuxt3 meta tags 相關配置可以參考 這篇文章 // pages/about.vue&lt;template&gt; &lt;div&gt;...&lt;/div&gt;&lt;/template&gt;&lt;script setup&gt;const i18nHead = useLocaleHead({ addSeoAttributes: true});useHead({ htmlAttrs: { lang: i18nHead.value.htmlAttrs.lang }, link: [ ...(i18nHead.value.link || []) ], meta: [ ...(i18nHead.value.meta || []) ]});&lt;/script&gt; 產生的網頁原始碼： 參考資源： https://v8.i18n.nuxtjs.org/https://vue-i18n.intlify.dev/","link":"/2023/08/29/nuxt3/nuxt-v3-i18n/"},{"title":"Nuxt.js 3.x Layouts 目錄－自訂模板","text":"本篇文章同步發表於 2023 iThome 鐵人賽：Nuxt.js 3.x 筆記－打造 SSR 專案 Layouts 資料夾協助我們定義共用模板，將重複使用的版面提取到模板內全域共用，看起來跟 Components 有點像，那麼 Layouts 跟 Components 怎麼區分？可以將 Layouts 視為包覆在頁面外層的包裹元件，用來定義 Header、Sidebar、Footer 等共用版面或是元件 官方文件提到，如果整個專案只有一個模板，建議直接在&nbsp;app.vue&nbsp;定義即可 預設模板預設模板名稱為 default，新增 layouts/default.vue，並透過 &lt;slot /&gt; 將元件的內容載入 // layouts/default.vue&lt;template&gt; &lt;div&gt; &lt;nav&gt;Header&lt;/nav&gt; &lt;slot /&gt; &lt;div&gt;Footer&lt;/div&gt; &lt;/div&gt;&lt;/template&gt; 或是將 Header、Footer 等共用元件（Components）加入模板 // layouts/default.vue&lt;template&gt; &lt;div&gt; &lt;TheHeader /&gt; &lt;slot /&gt; &lt;TheFooter /&gt; &lt;/div&gt;&lt;/template&gt; 接著在 app.vue 透過 &lt;NuxtLayout&gt; 元件使用模板，預設使用 layouts/default.vue 模板 // app.vue&lt;template&gt; &lt;NuxtLayout&gt; &lt;NuxtPage /&gt; &lt;/NuxtLayout&gt;&lt;/template&gt; 新增首頁 pages/index.vue // pages/index.vue&lt;template&gt; &lt;div&gt; &lt;h3&gt;Home Page&lt;/h3&gt; &lt;/div&gt;&lt;/template&gt; 畫面呈現： 使用其他具名模板layouts|—— default.vue|—— main.vue // layouts/main.vue&lt;template&gt; &lt;div&gt; &lt;h2&gt;Main Layout&lt;/h2&gt; &lt;slot /&gt; &lt;/div&gt;&lt;/template&gt; 1. app.vue 指定全域模板，覆蓋預設模板使用 name props 指定模板 名稱必須使用 kebab-case，例如 Layout 檔名為 customLayout，需使用 name='custom-layout' // app.vue&lt;template&gt; &lt;NuxtLayout name=\"main\"&gt; &lt;NuxtPage /&gt; &lt;/NuxtLayout&gt;&lt;/template&gt; 2. 在單一元件指定模板使用 definePageMeta() 輔助函式指定模板名稱 // pages/index.vue&lt;template&gt; &lt;div&gt;...&lt;/div&gt;&lt;/template&gt;&lt;script setup&gt;definePageMeta({ layout: 'main'});&lt;/script&gt; 3. 在單一元件直接定義 NuxtLayout先將預設模板設為 false，並透過 &lt;NuxtLayout name=\"xxx\"&gt; 定義模板 // pages/index.vue&lt;template&gt; &lt;div&gt; &lt;NuxtLayout name=\"main\"&gt; &lt;h3&gt;Home Page&lt;/h3&gt; &lt;/NuxtLayout&gt; &lt;/div&gt;&lt;/template&gt;&lt;script setup&gt;definePageMeta({ layout: false});&lt;/script&gt; 在單一元件直接使用 &lt;NuxtLayout&gt;，要避免放在 根元素（root element），或是關閉 page 跟 layout 的 transitions 效果 畫面呈現： 動態切換模板透過 setPageLayout() 輔助函式動態切換模板 // pages/index.vue&lt;template&gt; &lt;div&gt; &lt;h3&gt;Home Page&lt;/h3&gt; &lt;button @click=\"setPageLayout('default')\"&gt;default&lt;/button&gt; &lt;button @click=\"setPageLayout('main')\"&gt;main&lt;/button&gt; &lt;/div&gt;&lt;/template&gt; 具名插槽範例：layouts/main.vue 搭配具名插槽 // layouts/main.vue&lt;template&gt; &lt;div&gt; &lt;nav&gt;Header&lt;/nav&gt; &lt;slot name=\"content\" /&gt; &lt;div&gt;Sidebar&lt;/div&gt; &lt;slot name=\"footer\" /&gt; &lt;/div&gt;&lt;/template&gt; 在頁面上使用，需將預設模板設為 false // pages/index.vue&lt;template&gt; &lt;div&gt; &lt;NuxtLayout name=\"main\"&gt; &lt;template #content&gt; &lt;h3&gt;Home Page&lt;/h3&gt; &lt;/template&gt; &lt;template #footer&gt; &lt;h3&gt;Footer&lt;/h3&gt; &lt;/template&gt; &lt;/NuxtLayout&gt; &lt;/div&gt;&lt;/template&gt;&lt;script setup&gt;definePageMeta({ layout: false});&lt;/script&gt; 參考資源： https://nuxt.com/docs/guide/directory-structure/layoutshttps://nuxt.com/docs/examples/features/layoutshttps://medium.com/codex/nuxt3-layouts-276ed64a4a1c","link":"/2023/09/01/nuxt3/nuxt-v3-layouts/"},{"title":"Nuxt.js 3.x 專案架設","text":"本篇文章同步發表於 2023 iThome 鐵人賽：Nuxt.js 3.x 筆記－打造 SSR 專案 Nuxt 版本：v3.7.1 先前寫了一系列 Nuxt.js 2.x 相關文章，在 Vue 3 出了好一段時間後，Nuxt 3 終於在 2022 年底推出了穩定版本，除了支援 TypeScript，更徹底的進行重構，精簡了核心、編譯速度更快，提升開發體驗。 接下來一起來建立一個 Nuxt 3 專案吧！ 首先使用 Nuxt 指令列工具（command line interface）Nuxi 進行安裝，&lt;project-name&gt; 專案名稱可以自訂： npx nuxi@latest init &lt;project-name&gt; 這裡命名為 my-app npx nuxi@latest init my-app 注意：node 版本必須要 v16.0.0 以上才能順利執行，可以透過 node -v 指令來查看當前使用版號 接著選擇使用的套件管理工具，這裡選擇 npm 安裝完成後，接著進入到專案根目錄 cd my-app 安裝相依套件 npm install 於開發環境啟動專案 npm run dev 接著在瀏覽器輸入網址，就可以看到畫面囉 現在打開專案根元件&nbsp;app.vue，&lt;NuxtWelcome /&gt;&nbsp;是 Nuxt 預設的歡迎畫面，可以取代成自己的程式碼，到這裡專案就建置完成啦！ // app.vue&lt;template&gt; &lt;div&gt; &lt;NuxtWelcome /&gt; &lt;/div&gt;&lt;/template&gt; 如果採用 Visual Studio Code 開發，官方文件建議可以安裝 Vue Language Features (Volar) ，另外如果搭配 TypeScript 進行開發，也推薦安裝 TypeScript Vue Plugin (Volar) ，這兩個套件可以協助我們在開發時提示、補足、highlight 程式碼，功能強大 參考文章： https://nuxt.com/docs/getting-started/installation","link":"/2023/06/17/nuxt3/nuxt-v3-installation/"},{"title":"Nuxt.js 3.x 自訂 Loading 效果","text":"本篇文章同步發表於 2023 iThome 鐵人賽：Nuxt.js 3.x 筆記－打造 SSR 專案 Nuxt3 提供了預設進度條元件 &lt;NuxtLoadingIndicator&gt;，在路徑切換時顯示。也可以自訂共用元件來調整觸發時機或樣式。 路由切換（Page Navigation）Loading方法一：Nuxt3 內建元件，在頁面切換時觸發 使用方式： 在 app.vue 或是 layouts 加上 &lt;NuxtLoadingIndicator&gt; Props 選項： color：loading bar 顏色，預設為漸層色 height：loading bar 高度，預設 3（px） duration：loading bar 持續時間，預設 2000（毫秒） throttle：節流時間，會隱藏 loading bar，預設 200（毫秒） // app.vue&lt;template&gt; &lt;div&gt; &lt;NuxtLoadingIndicator :throttle=\"0\" /&gt; &lt;NuxtPage /&gt; &lt;/div&gt;&lt;/template&gt; 注意：Nuxt ≥ 3.1.0 需加上 :throttle=\"0\"，否則受節流時間影響看不到 loading 效果（參考討論串） 方法二：自訂 Loading Indicator建立 Loading 元件，使用參數 isLoading 判斷是否顯示 Loading Indicator，接著透過 Nuxt app runtime hooks 建立攔截器，這裡使用 page:start 以及 page:finish // components/CustomLoadingIndicator.vue&lt;template&gt; &lt;div class=\"loading-indicator\" :class=\"{ 'show': isLoading }\"&gt; Loading... &lt;/div&gt;&lt;/template&gt;&lt;script setup&gt; const nuxtApp = useNuxtApp(); const isLoading = ref(false); nuxtApp.hook('page:start', () =&gt; { isLoading.value = true; }); nuxtApp.hook('page:finish', () =&gt; { setTimeout(() =&gt; { isLoading.value = false; }, 200); });&lt;/script&gt;&lt;style lang=\"scss\" scoped&gt;.loading-indicator { opacity: 0; transition: opacity 0.5s ease-in-out; &amp;.show { opacity: 1; transition: opacity 0.2s ease-in-out; }}&lt;/style&gt; 在 app.vue 加入自訂元件 // app.vue&lt;template&gt; &lt;div&gt; &lt;CustomLoadingIndicator /&gt; &lt;NuxtPage /&gt; &lt;/div&gt;&lt;/template&gt; 效果如下： 資料請求（Data Fetching）Loading使用 useFetch 或 useAsyncData Composables，參數 pending 為布林值，顯示資料是否還在請求狀態，用來判斷是否顯示 Loading Indicator Nuxt3 useFetch 相關知識，可以參考 這篇文章 // pages/about.vue&lt;template&gt; &lt;div&gt; &lt;div v-if=\"pending\"&gt; Loading ... &lt;/div&gt; &lt;div v-else&gt; user: &lt;pre&gt;{{ data }}&lt;pre&gt; &lt;button type=\"button\" @click=\"refresh()\"&gt;refresh&lt;/button&gt; &lt;/div&gt; &lt;/div&gt;&lt;/template&gt;&lt;script setup&gt;const { data, pending, refresh } = useFetch('/api/about');&lt;/script&gt; 效果如下： 參考資源： https://medium.com/@flanker72/nuxt3-complex-solutions-page-loading-indicator-e34b5a86be52https://nuxt.com/docs/api/components/nuxt-loading-indicatorhttps://nuxt.com/docs/getting-started/data-fetching","link":"/2023/08/24/nuxt3/nuxt-v3-loading/"},{"title":"Nuxt.js 3.x Meta Tags and SEO","text":"本篇文章同步發表於 2023 iThome 鐵人賽：Nuxt.js 3.x 筆記－打造 SSR 專案 Nuxt3 搭配 Unhead 套件，讓我們可以在應用程式中動態控制 &lt;head&gt; 標籤，定義 meta 資訊、樣式表、程式碼片段等在網頁中需要的內容，有助於 SEO 搜尋引擎優化 動態控制函式：Composables 組合式函式 useHead() &amp; useHeadSafe() useSeoMeta() &amp; useServerSeoMeta() Components 內建元件 &lt;Title&gt;、&lt;Style&gt;、&lt;Meta&gt;、&lt;Link&gt;、&lt;Body&gt;、&lt;Html&gt;、&lt;Head&gt; Composables：useHead &amp; useHeadSafe能夠定義完整 &lt;head&gt; 內容。 useHeadSafe() 是 useHead() 的包裝函式，對輸入內容進行檢核，能夠避免潛在的安全風險，像是 XSS 攻擊等安全漏洞 &lt;script setup&gt;useHead({ title: 'My Website', htmlAttrs: { lang: 'zh-TW' }, meta: [ { name: 'description', content: 'Hello this is my site.' } ], script: [], link: []})&lt;/script&gt; Composables：useSeoMeta &amp; useServerSeoMeta專門用來定義 meta tags，物件結構簡潔扁平。 如果我們的資料非響應式，可以使用 useServerSeoMeta()，在 server 端預先處理完 meta 相關邏輯，提升網頁效能 &lt;script setup&gt;useSeoMeta({ title: 'My Website', ogTitle: 'My Website', description: 'Hello this is my site.', ogDescription: 'Hello this is my site.', ogImage: 'https://mysite/image.png', twitterCard: 'summary_large_image'})&lt;/script&gt; ComponentsNuxt3 內建 &lt;Title&gt;、&lt;Style&gt;、&lt;Meta&gt;、&lt;Link&gt;、&lt;Body&gt;、&lt;Html&gt;、&lt;Head&gt; 等元件讓我們可以直接在 template 配置 &lt;head&gt; 內容 &lt;template&gt; &lt;div&gt; &lt;Head&gt; &lt;Title&gt;{{ title }}&lt;/Title&gt; &lt;Meta name=\"description\" :content=\"title\" /&gt; &lt;/Head&gt; &lt;/div&gt;&lt;/template&gt;&lt;script setup&gt;const title = 'About Page';&lt;/script&gt; 實作：全域配置方法一：nuxt.confignuxt.config 配置不支援響應式資料，因此官方文件建議在 app.vue 中使用 useHead() 等方法定義 // nuxt.config.jsexport default defineNuxtConfig({ app: { head: { title: 'My Website', htmlAttrs: { lang: 'zh-TW' }, meta: [ { charset: 'utf-8' }, { name: 'viewport', content: 'width=device-width, initial-scale=1, viewport-fit=cover' } ], link: [ { rel: 'icon', type: 'image/x-icon', href: '/favicon.ico' } ] } }}) 方法二：app.vue在 app.vue 中使用 useHead() 等方法定義 &lt;head&gt; 預設值，可以在其他 pages 頁面中定義相同的 meta 屬性覆寫預設值 // app.vue&lt;template&gt; &lt;div&gt; &lt;NuxtPage /&gt; &lt;/div&gt;&lt;/template&gt;&lt;script setup&gt;useHead({ title: 'My Website', meta: [ { name: 'description', content: 'Hello this is my site.' } ]});&lt;/script&gt; 實作：局部配置在頁面上定義，能夠覆蓋在 app.vue 配置的 &lt;head&gt; 預設值，以下範例搭配 useHead() // pages/about.vue&lt;template&gt; &lt;div&gt; ... &lt;/div&gt;&lt;/template&gt;&lt;script setup&gt;useHead({ title: 'About Page', meta: [ { name: 'description', content: 'Hello this is about page.' } ]});&lt;/script&gt; 延伸：透過後端 API 動態取得 meta 內容範例情境：每次進入頁面時請求該頁 meta 資料 使用 useAsyncData() 搭配 $fetch 方法實作，並搭配 useSeoMeta() 進行配置 需先具備 Nuxt3 data fetching 相關知識，可以參考 這篇文章 // pages/about.vue&lt;template&gt; &lt;div&gt; ... &lt;/div&gt;&lt;/template&gt;&lt;script setup&gt;useAsyncData('seo', async () =&gt; { const { title, description, image } = await $fetch('/api/seo/about'); useSeoMeta({ title, ogTitle: title, description, ogDescription: description, ogImage: image });});&lt;/script&gt; 參考資源： https://nuxt.com/docs/getting-started/seo-metahttps://unhead.harlanzw.com/","link":"/2023/07/26/nuxt3/nuxt-v3-meta-tags/"},{"title":"Nuxt.js 3.x Middleware 目錄－監聽路由變化","text":"本篇文章同步發表於 2023 iThome 鐵人賽：Nuxt.js 3.x 筆記－打造 SSR 專案 Middleware 為 Nuxt 內的&nbsp;路由守衛（Navigation Guards），相當於 Vue Router 內的 beforeEach callback，協助我們在進到頁面前進行事件處理（例如權限檢查） Middleware 觸發時機： 頁面初始化：Server Side 跟 Client Side 同時觸發（觸發兩次） 頁面切換：Client Side 觸發 Middleware 定義方式： 具名：在&nbsp;middleware/&nbsp;定義，並在需要的頁面引入 全域：同具名的定義方式，不過檔名需加上&nbsp;.global&nbsp;後綴，在所有頁面切換時自動執行 匿名：直接在單一元件檔內定義 具名 Middleware範例： middleware/|—— auth.js defineNuxtRouteMiddleware() 輔助函示：定義 route middleware navigateTo() 輔助函示：導航到其他頁面 abortNavigation()&nbsp;輔助函示：中斷導航，顯示錯誤資訊以及跳到錯誤頁面 // middleware/auth.jsexport default defineNuxtRouteMiddleware((to, from) =&gt; { const isLoggedIn = true; // 判斷是否登入 const hasPermission = false; // 判斷有無頁面權限 if (!isLoggedIn) { return navigateTo('/login'); } if (!hasPermission) { return abortNavigation({ statusCode: 403 statusMessage: '無頁面權限' }); }}); 在頁面透過 definePageMeta() 輔助函式定義 middleware // pages/about.vue&lt;template&gt; &lt;div&gt;...&lt;/div&gt;&lt;/template&gt;&lt;script setup&gt;definePageMeta({ middleware: [ auth ] // or middleware: 'auth'});&lt;/script&gt; 接下來當我們切到 http:localhost:3000/about，驗證無頁面權限跳轉至錯誤畫面 全域 Middleware全域引入的 Middleware。同具名定義方式，不過檔名需加上&nbsp;.global&nbsp;後綴，在所有頁面切換時自動執行 範例： middleware/|—— auth.global.js 匿名 Middleware在頁面內各別定義 // pages/about.vue&lt;template&gt; &lt;div&gt;...&lt;/div&gt;&lt;/template&gt;&lt;script setup&gt;definePageMeta({ middleware: [ (to, from) =&gt; { // 這裡是匿名 middleware 內容 } ]});&lt;/script&gt; Middleware 執行順序執行順序首先為全域 Middleware，接下來才是頁面定義的 Middleware（依照順序） 範例： middleware/|—— auth.global.js|—— redirect.js // pages/about.vue&lt;template&gt; &lt;div&gt;...&lt;/div&gt;&lt;/template&gt;&lt;script setup&gt;definePageMeta({ middleware: [ (to, from) =&gt; { // ... }, 'redirect' ]});&lt;/script&gt; 執行順序分別為： auth.global.js 自訂匿名 middleware redirect.js 動態加入 Middleware使用 addRouteMiddleware(name, middleware, options) 輔助函式動態加入 Middleware 範例：在 plugins/ 加入 middleware 具名會覆蓋掉定義在 middleware/ 資料夾內同名檔案（auth.js） // plugins/add-middleware.jsexport default defineNuxtPlugin(() =&gt; { addRouteMiddleware('auth', (to, from) =&gt; { // ... });}); 匿名// plugins/add-middleware.jsexport default defineNuxtPlugin(() =&gt; { addRouteMiddleware((to, from) =&gt; { // ... });}); 全域options 加上 { global: true } // plugins/add-middleware.jsexport default defineNuxtPlugin(() =&gt; { addRouteMiddleware('auth', (to, from) =&gt; { // ... }, { global: true } );}); 參考資源： https://nuxt.com/docs/guide/directory-structure/middlewarehttps://nuxt.com/docs/api/utils/define-nuxt-route-middleware","link":"/2023/09/05/nuxt3/nuxt-v3-middleware/"},{"title":"Nuxt.js 3.x Server API 整合 MongoDB 實作，邁向全端第一步","text":"本篇文章同步發表於 2023 iThome 鐵人賽：Nuxt.js 3.x 筆記－打造 SSR 專案 Nuxt3 搭配了新的伺服器引擎 Nitro，讓我們能輕鬆建立 Server API，並在 Nuxt3 專案內使用。Nitro 的優點包含跨平台支援 Node.js 與瀏覽器、支援 HMR、自動生成 API 路由等。 實務上 API 開發常會搭配資料庫連接，本篇將說明如何結合 MongoDB，實作後端 API 開發與前端串接，讓我們的 Nuxt 專案具備全端功能。 本文重點在 Nuxt 與 MongoDB 整合，需先具備以下知識： Nuxt Server API，可以參考 這篇文章 Nuxt $fetch 方法，可以參考&nbsp;這篇文章 MongoDB 應用（本文僅簡單說明） 開始前先簡單介紹一下 MongoDB 跟 Mongoose MongoDBMongoDB 是一個 NoSQL 資料庫，以 BSON（Binary JSON）格式儲存，適合彈性和變化性高的資料儲存，一個 Database 是由一個或多個 Collection 組成，一個 Collection 則是由一個或多個 Document 組成，每一筆資料為一個 Document，裡面可以有多個欄位 Field MongooseMongoose 是 MongoDB 的 ODM（Object Data Modeling）套件，在 Node.js 透過 MongoDB driver 跟資料庫溝通，執行 CRUD（新增、刪除、更新、查詢）操作 實作分為以下步驟 MongoDB 前置環境準備 安裝 Mongoose 建立 Database 透過 Mongoose 連接 Database 建立 Model 與 Collection 建立 Server API 前端串接 API：實作新增 Step1：MongoDB 前置環境準備 MongoDB 安裝 Compass 安裝：mongoDB 的 GUI Step2：安裝 Mongoose在專案內執行指令安裝 npm i -D mongoose Step3：透過 Mongoose 連接 Database新增 server/index.js 透過 mongoose.connect(URI) 連接 database URI 格式：mongodb://[username:password@][host][:port]/dbName，dbName 資料庫名稱自訂 // server/index.jsimport mongoose from 'mongoose';export default async () =&gt; { try { await mongoose.connect('mongodb://localhost:27017/nuxt_app'); console.log('DB connection established'); } catch (err) { console.error('DB connection failed', err); }}; URI 通常會定義為 env 變數，在根目錄新增 .env // .envMONGODB_URI=\"mongodb://localhost:27017/nuxt_app\" 透過 process.env.MONGODB_URI 取得變數 mongoose.connect(process.env.MONGODB_URI); 將 server/index.js 註冊為 Server Plugins，在伺服器初始化時執行資料庫連接 // nuxt.config.jsexport default defineNuxtConfig({ nitro: { plugins: [ '@/server/index' ] }}); Step4：建立 Model 與 Collection範例： 新增 server/models/userModel.js 定義模型 建立 Schema，透過 Schema 規範 Document 資料內容、型別、預設值等 建立 Model 模型，連接資料庫 Collection 與上一步的 Schema。當建立的模型資料庫沒有相對應 Collection，Mongoose 會自動建立 // server/models/userModel.jsimport mongoose from 'mongoose';// 建立 Schemaconst userSchema = new mongoose.Schema({ name: { type: 'string', required: true }, email: { type: 'string', required: true, unique: true }}, { versionKey: false});// 建立 Modelconst User = mongoose.model('User', userSchema);export default User; mongoose.model() 第一個參數為 Collection 名稱、第二個參數為 Schema。其中第一個餐褲 Collection 名稱為大寫開頭單數，會對應到資料庫內小寫開頭複數 Collection mongoose.model('User', userSchema); 對應到 Collection 名稱為 users 執行編譯後，這時候開啟 Compass，應該可以看到 nuxt_app Database 跟 users Collection，接下來就可以對資料庫進行操作囉 Step5：建立 Server API建立一支 POST API server/api/user.post.js 使用&nbsp;unjs/h3&nbsp;提供 readBody()&nbsp;輔助函式，取得 request body 內容 透過 Model 對 Collection 進行溝通與操作，使用 Ｍongoose create() 方法新增一筆資料 // server/api/user.post.jsimport User from '@/server/models/userModel';export default defineEventHandler(async event =&gt; { try { const { name, email } = await readBody(event); await User.create({ name, email }); const user = await User.findOne({ email }); return user; } catch (error) { return createError(error); }}); Step6：前端串接 API終於來到最後一步啦！ 在頁面上使用 Nuxt3 $fetch 方法發送請求，新增一筆資料 // pages/index.vue&lt;template&gt; &lt;div&gt; &lt;label&gt;name&lt;/label&gt; &lt;input type=\"text\" v-model=\"user.name\" /&gt; &lt;label&gt;email&lt;/label&gt; &lt;input type=\"email\" v-model=\"user.email\" /&gt; &lt;button @click=\"addUser()\"&gt;Add User&lt;/button&gt; &lt;/div&gt;&lt;/template&gt;&lt;script setup&gt;const user = ref({ name: '', email: ''});const addUser = async () =&gt; { const response = await $fetch('/api/user', { method: 'POST', body: { ...user.value } }); console.log(response);};&lt;/script&gt; 回到 Compass 確認一下，如果有看到一筆資料，就代表串接成功囉！ 參考資源： https://medium.com/@flanker72/nuxt3-complex-solutions-database-integration-8df941f0fb82https://www.mongodb.com/","link":"/2023/09/22/nuxt3/nuxt-v3-mongodb-integration/"},{"title":"Nuxt.js 3.x Pages 目錄－自動生成路由","text":"本篇文章同步發表於 2023 iThome 鐵人賽：Nuxt.js 3.x 筆記－打造 SSR 專案 Pages 資料夾用來新增頁面，當我們在 Pages 資料夾建立檔案，Nuxt 會根據資料夾以及檔案結構自動生成基於 Vue Router 的路由，讓我們能更有效率的開發和管理 app.vue專案進入點，Nuxt3 將&nbsp;app.vue&nbsp;移到目錄頁（Nuxt2 無法編輯 app.vue），因此也可以只用&nbsp;app.vue&nbsp;單一頁面來建置網站（例如單頁 Landing Page），而不定義&nbsp;pages/，在此情況下 Vue Router 不會被載入。 如要使用&nbsp;pages/，app.vue&nbsp;需加上&nbsp;&lt;NuxtPage&gt;&nbsp;用於顯示頁面內容（功能同 Vue.js 的&nbsp;&lt;router-view&gt;） // app.vue&lt;template&gt; &lt;div&gt; &lt;NuxtPage /&gt; &lt;/div&gt;&lt;/template&gt; 新增 Pages首先建立首頁 pages/index.vue // pages/index.vue&lt;template&gt; &lt;div&gt; &lt;h1&gt;Home Page&lt;/h1&gt; &lt;/div&gt;&lt;/template&gt; 執行 npm run dev 編譯後，在瀏覽器開啟 http://localhost:3000，可以看到 Nuxt 已經幫我們定義路由 自動產生的路由結構： { \"routes\": [ { \"path\": \"/\", \"component\": \"pages/index.vue\" } ]} 注意：一個頁面只能存在一個根元素（root element），路由才能正常在頁面間切換（html 註解也視為一個元素）以下為錯誤示範： &lt;template&gt; &lt;!-- 註解也視為一個元素，因此頁面無法正常渲染 --&gt; &lt;h1&gt;Home page&lt;/h1&gt;&lt;/template&gt; &lt;template&gt; &lt;h1&gt;Home page&lt;/h1&gt; &lt;p&gt;兩個根元素，頁面無法正常渲染&lt;/p&gt;&lt;/template&gt; 動態路由Nuxt2 使用下底線 _ 定義動態路由，Nuxt3 調整為使用方括號 [] 範例： pages/|—— index.vue|—— product-[category]/ |—— [id].vue 透過 $route 或是 useRoute 組合函式取得路由參數，useRoute 內容參考 官方文件 // pages/product-[category]/[id].vue&lt;template&gt; &lt;div&gt; &lt;h3&gt;{{ $route.params.category }}&lt;/h3&gt; &lt;p&gt;{{ $route.params.id }}&lt;/p&gt; &lt;/div&gt;&lt;/template&gt;&lt;script setup&gt;const route = useRoute();console.log(route.params.category);console.log(route.params.id);&lt;/script&gt; 瀏覽器輸入頁面 http://localhost:3000/product-apple/112345，畫面渲染如下 Catch-all 捕捉路徑下所有路由透過 […slug].vue 將動態路由解構，來捕捉在此路徑下未被定義的頁面 範例： pages/|—— index.vue|—— [...slug].vue|—— about.vue // pages/[…slug].vue&lt;template&gt; &lt;div&gt; &lt;h3&gt;Page Not Found&lt;/h3&gt; &lt;p&gt;{{ $route.params.slug }}&lt;/p&gt; &lt;/div&gt;&lt;/template&gt; 當我們輸入未被定義的頁面 /hello/world，顯示 […slug].vue 畫面如下 透過 […slug].vue，我們可以簡單地捕捉特定路徑下不存在的頁面，全域的錯誤頁面（不只捕捉 404 錯誤），則由 app.vue 同層的 error.vue 處理 error.vue 自訂方式可以參考 這篇文章 巢狀路由（嵌套路由）在頁面插入 &lt;NuxtPage&gt;，嵌套下一層路由 範例：子頁面 /parent/child-a、/parent/child-b 共享上層路由（/parent）畫面 檔案結構（parent/ 資料夾與 parent.vue 命名必須相同）： pages/|—— parent/ |—— child-a.vue |—— child-b.vue|—— parent.vue 自動產生的路由結構： { \"routes\": [ { path: '/parent', component: '~/pages/parent.vue', name: 'parent', children: [ { path: 'child', component: '~/pages/parent/child-a.vue', name: 'parent-child-a' }, { path: 'child', component: '~/pages/parent/child-b.vue', name: 'parent-child-b' } ] } ]} parent.vue 必須加上 &lt;NuxtPage&gt;，用來嵌套子頁面內容 // pages/parent.vue&lt;template&gt; &lt;div&gt; // 共用 Sidebar &lt;div class=\"sidebar\"&gt; &lt;NuxtLink to=\"/parent/child-a\"&gt;child-a&lt;/NuxtLink&gt; &lt;NuxtLink to=\"/parent/child-b\"&gt;child-b&lt;/NuxtLink&gt; &lt;/div&gt; // 用來顯示子頁面內容 &lt;NuxtPage /&gt; &lt;/div&gt;&lt;/template&gt; 如果父層路由 /parent 有自己的獨立畫面，在 parent/ 資料夾新增 index.vue（也會共享 parent.vue 畫面） pages/|—— parent/ |—— ... |—— index.vue|—— parent.vue // pages/parent/index.vue&lt;template&gt; &lt;div&gt; &lt;h2&gt;Parent Content&lt;/h2&gt; &lt;/div&gt;&lt;/template&gt; 若希望使用者進入 /parent 路由時導向到 /parent/child-a，可以在 /parent/index.vue 透過 navigateTo() 輔助函式設定自動導向 // pages/parent/index.vue&lt;template&gt; &lt;div&gt;Parent Content&lt;/div&gt;&lt;/template&gt;&lt;script setup&gt;navigateTo('/parent/child-a', , { redirectCode: 301 });&lt;/script&gt; NuxtLink 路由連結透過 &lt;NuxtLink&gt; 元件進行頁面導航，Nuxt3 的 &lt;NuxtLink&gt; 整合了 Vue Router &lt;RouterLink&gt; 跟 HTML &lt;a&gt; 標籤，能夠智能判斷內部或外部連結，並加以優化（加入預設屬性） &lt;template&gt; &lt;div&gt; // 內部連結 &lt;NuxtLink to=\"/hello\"&gt;Internal&lt;/NuxtLink&gt; // 外部連結 &lt;NuxtLink to=\"https://mywebsite.com\"&gt;External&lt;/NuxtLink&gt; &lt;/div&gt;&lt;/template&gt; 編譯後結果，外部連結自動加上 rel 屬性 // 內部連結&lt;a href=\"/hello\"&gt;Internal&lt;/a&gt;// 外部連結&lt;a href=\"https://mywebsite.com\" rel=\"noopener noreferrer\"&gt;External&lt;/a&gt; 也可以透過 props 自定義屬性，屬性選項參考 官方文件 範例： target=\"_blank\"：另開新分頁 external=\"false\"：設定為內部連結 no-rel：將 rel 屬性移除 &lt;template&gt; &lt;div&gt; &lt;NuxtLink to=\"https://mywebsite.com\" target=\"_blank\" external=\"false\" no-rel&gt; External &lt;/NuxtLink&gt; &lt;/div&gt;&lt;/template&gt; 參考資源： https://nuxt.com/docs/guide/directory-structure/pageshttps://nuxt.com/docs/getting-started/routinghttps://medium.com/unalai/認識-vue-router-嵌套路由-nested-routes-8168f5395941","link":"/2023/08/18/nuxt3/nuxt-v3-pages/"},{"title":"Nuxt.js 3.x Plugins 目錄－擴充插件＋自訂指令","text":"本篇文章同步發表於 2023 iThome 鐵人賽：Nuxt.js 3.x 筆記－打造 SSR 專案 Plugins 目錄協助我們在 Nuxt 擴充套件功能。前端開發常會搭配 第三方套件（package）使用，如表單驗證、圖片輪播、提示訊息等，這些套件通常已經被開發者設計好並經過測試，可以直接安裝使用，節省專案開發時間。 建立 Pluginsplugins/ 資料夾內第一層檔案（資料夾內第一層），Nuxt3 會自動載入（auto-imports），不需要在 nuxt.config 各別註冊 plugins/|—— myPlugin.js // 自動引入|—— supportingFile/ |—— index.js // 不會自動引入 Plugin 只提供 nuxtApp 唯一參數，nuxtApp 為一個物件（相關屬性 參考文件） // plugins/myPlugin.jsexport default defineNuxtPlugin(nuxtApp =&gt; { // ...}) 載入順序調整載入順序當 plugin 依賴另一個 plugin 時可以使用此功能，將被依賴的 plugin 優先載入 範例： 01.myPlugin.js 會優先載入，因此 02.testPlugin.js 能夠使用 01.myPlugin.js 注入的內容 plugins/|—— 01.myPlugin.js|—— 02.testPlugin.js 檔案名稱的排序是根據字串排序（alphabetical）而不是數字，10.xxx.js 排序會在 2.xxx.js 前，因此上述範例需加上 「0」 前綴 設定同時載入plugins/ 預設會依序載入，如果希望同時載入，只要在 plugin 內加上 parallel: true，下一順位 plugin 就會跟這個 plugin 同時載入 在特殊使用情境下，plugin 也可以透過物件格式來定義 // plugins/asyncPlugin.jsexport default defineNuxtPlugin({ name: 'async-plugin', parallel: true, async setup (nuxtApp) { // 這裡的功能等同於一般函式定義的 plugin }}) 在 Plugin 內使用 Composables（組合式函式）// plugins/myPlugin.jsexport default defineNuxtPlugin(nuxtApp =&gt; { const counter = useCounter();}) 需注意，在 Plugins 使用 Composables 有一些限制： 若 composable 依賴於稍後載入的另一個 plugin，可能無法正常運作 若 composable 依賴 Vue 生命週期，由於 composable 綁定的是使用他的元件實體，但 plugin 只會綁定在 nuxtApp 實例，可能無法正常運作 Provide 注入全域變數注入全域變數到 nuxtApp，提供兩種定義方式： export default defineNuxtPlugin(nuxtApp =&gt; { // 方法一 nuxtApp.provide('hello', (msg: string) =&gt; `Hello ${msg} !`); // 方法二 return { provide: { hello: (msg: string) =&gt; `Hello ${msg} !` } };}) 功能同 Nuxt2 inject 寫法： inject('hello', msg =&gt; Hello ${msg} !) 接著就可以在頁面透過 useNuxtApp() 函式取得定義在 nuxtApp 的全域變數 $hello // pages/hello.vue&lt;template&gt; &lt;div&gt; {{ $hello('World') }} &lt;/div&gt;&lt;/template&gt;&lt;script setup&gt;const { $hello } = useNuxtApp();&lt;/script&gt; 搭配第三方套件以 https://github.com/kyvg/vue3-notification （提示訊息彈跳視窗）為例 安裝套件npm i @kyvg/vue3-notification 建立 Plugin 透過 nuxtApp.vueApp.use() 在 Vue.js 註冊全域 plugin 並搭配前面提到的 nuxtApp.provide() 在 Nuxt 註冊全域變數或方法 // plugins/notification.jsimport Notifications, { useNotification } from '@kyvg/vue3-notification';const { notify } = useNotification();export default defineNuxtPlugin(nuxtApp =&gt; { nuxtApp.vueApp.use(Notifications); return { provide: { notify } };}); 使用提示訊息執行注入在 Nuxt 的全域變數 $notify，顯示提示畫面 // pages/index.vue&lt;template&gt; &lt;div&gt; &lt;notifications /&gt; &lt;/div&gt;&lt;/template&gt;&lt;script setup&gt;export default { const { $notify } = useNuxtApp(); onMounted(() =&gt; { $notify({ type: 'success', title: 'Notification Title' text: 'Notification Text' }); });};&lt;/script&gt; Custom Directives 自訂指令Vue 自訂指令說明可以參考 這篇文章 除了 Vue 內建的系列指令，像是&nbsp;v-model,&nbsp;v-for,&nbsp;v-show&nbsp;等，我們也可以使用 Vue directives 自訂指令，將 DOM 元素和元件進行動態綁定，並對其進行操作 // plugins/focus.jsexport default defineNuxtPlugin(nuxtApp =&gt; { nuxtApp.vueApp.directive('focus', { mounted(el) { el.focus(); } });}); 使用自訂指令 // pages/index.vue&lt;template&gt; &lt;div&gt; &lt;label&gt;name&lt;/label&gt; &lt;input type=\"text\" v-focus /&gt; &lt;label&gt;password&lt;/label&gt; &lt;input type=\"password\" /&gt; &lt;/div&gt;&lt;/template&gt; 調整載入時機（server or client）在檔名加上&nbsp;.client&nbsp;或是&nbsp;.server&nbsp;後綴即可 plugins/|—— myPlugin.client.js|—— testPlugin.server.js 當我們使用的第三方套件定義了&nbsp;window、document&nbsp;等瀏覽器全域變數，直接定義 plugin，執行時可能會拋錯誤&nbsp;window is not defined，因為 server 端預渲染時找不到變數，這時候就可以加上 .client 後綴來限制載入時機 參考資源： https://nuxt.com/docs/guide/directory-structure/plugins#plugins-directoryhttps://ithelp.ithome.com.tw/articles/10299002","link":"/2023/07/10/nuxt3/nuxt-v3-plugins/"},{"title":"Nuxt.js 3.x Server 目錄－建立 API","text":"本篇文章同步發表於 2023 iThome 鐵人賽：Nuxt.js 3.x 筆記－打造 SSR 專案 Nuxt3 搭配了新的伺服器引擎 Nitro，讓我們能輕鬆在 Nuxt 專內建立 Server API。Nitro 的優點包含跨平台支援 Node.js 與瀏覽器、支援 HMR、自動生成 API 路由等，讓 Nuxt 具備全端功能，接下來一起進行實作吧。 建立 API 在 server/ 目錄建立 API，Nuxt 會依據資料夾結構自動生成 API 路徑 使用 defineEventHandler() 建立事件處理器 範例檔案結構： server/|—— api/ |—— hello.js|—— routes/ |—— hello.js 放置於 /server/api 下的檔案，依據檔案名稱產生 /api 前綴路徑（/api/hello），如果不想加上 /api 前綴，將檔案放置於 /server/routes 即可 不論副檔名為 .js、.ts，均依據檔案名稱產生 API 路徑 範例：新增 /api/hello API // server/api/hello.jsexport default defineEventHandler(() =&gt; 'Hello World!'); 接著在瀏覽器開啟頁面 http://localhost:3000/api/hello HTTP MethodsServer API 預設請求方法為 get，如果要調整其他方法 post、patch、delete，加在檔名後綴即可 server/|—— api/ |—— user.post.js |—— user.delete.js 範例：新增 /api/user API，並使用 post 方法 Nitro 搭配 unjs/h3 來建立 Server API，readBody() 為 unjs/h3 提供的 utilites，用來取得 request body，其他 utilites 可以參考 官方文件 // server/api/user.post.jsexport default defineEventHandler(async event =&gt; { const body = await readBody(event); return { ...body };}); 在頁面使用 Nuxt3 useFetch 方法發出請求（useFetch 參考文章） // pages/index.vue&lt;template&gt; &lt;div&gt; &lt;div&gt;name: {{ user.name }}&lt;/div&gt; &lt;div&gt;age: {{ user.age }}&lt;/div&gt; &lt;/div&gt;&lt;/template&gt;&lt;script setup&gt;const { data: user } = useFetch('/api/user', { method: 'post', body: { name: 'Daniel', age: 18 }});&lt;/script&gt; 畫面如下： 捕捉所有路由（Catch-all Route）透過檔名 […] 來捕捉未被定義的 API 路徑（fallback route） 範例檔案結構： server/|—— api/ |—— hello.js |—— [...].js 透過 createError() 方法來處理錯誤 // server/api/[...].jsexport default defineEventHandler(() =&gt; { throw createError({ statusCode: 404, statusMessage: 'API Path Not Found' })}); 當我們向未定義的路由發出請求，例如 /api/nothing // pages/index.vue&lt;template&gt; &lt;div&gt; error: &lt;pre&gt;{{ error.data }}&lt;/pre&gt; &lt;/div&gt;&lt;/template&gt;&lt;script setup&gt;const { error } = useFetch('/api/nothing');&lt;/script&gt; 顯示錯誤訊息如下 實作 API 請求以下範例搭配靜態資料串接 Nuxt3 整合 MongoDB 請參考 這篇文章 Step1：建立靜態資料首先在 public/users.json 建立資料（範例資料來源：jsonplaceholder） // public/users.json[ { \"id\": 1, \"name\": \"Leanne Graham\", \"username\": \"Bret\", \"email\": \"Sincere@april.biz\", \"phone\": \"1-770-736-8031\" }, { \"id\": 2, \"name\": \"Ervin Howell\", \"username\": \"Antonette\", \"email\": \"Shanna@melissa.tv\", \"phone\": \"010-692-6593\" }] Step2：建立 API新增 server/api/user/[id].js 使用方括號 [] 表示動態參數 使用 getRouterParam() 方法取得參數 // server/api/user/[id].jsimport users from '@/public/users.json';export default defineEventHandler(event =&gt; { const id = getRouterParam(event, 'id'); return users.find(user =&gt; user.id === parseInt(id)) || {};}); Step3：發出請求新增 pages/user/[id].vue 方括號 [] 表示動態路由 使用 useRoute() 方法取得路由參數 透過 useFetch() 方法發出請求 // pages/user/[id].vue&lt;template&gt; &lt;div&gt; &lt;div&gt;name: {{ user.name }}&lt;/div&gt; &lt;div&gt;email: {{ user.email }}&lt;/div&gt; &lt;div&gt;phone: {{ user.phone }}&lt;/div&gt; &lt;/div&gt;&lt;/template&gt;&lt;script setup&gt; const route = useRoute(); const { data: user } = useFetch(`/api/user/${route.params.id}`);&lt;/script&gt; 接下來在瀏覽器輸入 http://localhost:3000/user/1 參考資源： https://nuxt.com/docs/guide/concepts/server-enginehttps://nuxt.com/docs/guide/directory-structure/serverhttps://masteringnuxt.com/blog/server-routes-in-nuxt-3","link":"/2023/09/04/nuxt3/nuxt-v3-server/"},{"title":"Nuxt.js 3.x 替網站增加 Sitemap 網站地圖","text":"本篇文章同步發表於 2023 iThome 鐵人賽：Nuxt.js 3.x 筆記－打造 SSR 專案 Sitemap 是一種用來提供網站資訊的檔案，記錄網站內的網頁、圖片等，主要功用為協助搜尋引擎快速了解我們的網頁。 新網站上線後，雖然搜尋引擎爬蟲會自動讀取網站內容並收錄，不過當網站規模較大、架構較複雜、彼此間連結性較低，可能需要花較長的時間才能完整收錄，透過 Sitemap，直接告訴搜尋引擎網頁資訊，能有效加快網頁收錄的速度。 接下來說明如何在 Nuxt3 專案內加入 Sitemap 網站地圖： 套件安裝安裝 Nuxt3 整合模組 nuxt-simple-sitemap，本篇搭配版本 v.3.3.2 npm i -D nuxt-simple-sitemap nuxt.config 配置模組// nuxt.config.jsexport default defineNuxtConfig({ modules: [ 'nuxt-simple-sitemap' ]}); 標準網址定義Canonical URL（標準網址）定義對於 SEO 很重要，用來告訴搜尋引擎標準的網址，解決重複內容網頁問題（ex：www.example.com&nbsp;以及&nbsp;example.com） 標準網址對 SEO 到底有多重要？這裡推薦一篇 文章 // nuxt.config.jsexport default defineNuxtConfig({ site: { url: 'http://example.com' }}); 建立 Sitemap假設專案 pages/ 頁面結構如下 pages/|—— index.vue|—— hello.vue|—— about.vue|—— user/ |—— [id].vue|—— post/ |—— [id].vue 執行 nuxt dev 編譯後，瀏覽器輸入 http://localhost:3000/sitemap.xml，可以看到靜態路徑自動被加入 Sitemap 點選 /sitemap.xml?cancical，可以看到 URL 調整為前面定義的標準網址 自動加入的靜態頁預設沒有帶上 priority 與 changefreq 參數，需在設定檔 defaults 加入 // nuxt.config.jsexport default defineNuxtConfig({ sitemap: { defaults: { changefreq: 'daily', priority: 0.8 } }}); sitemap configure 相關參數與預設值，請參考 官方文件 Sitemap 加入動態路徑靜態路徑執行編譯時會自動產生，動態路徑則需要結合後端 API 取得 需先具備 Nuxt3 data fetching 相關觀念，可以參考 這篇文章 Step1：新增 _sitemap-urls.js預設路徑結構如下： server/|—— api/ |—— _sitemap-urls.js 預設路徑為 server/api/_sitemap-urls.js，可以透過 dynamicUrlsApiEndpoint 參數調整路徑 // nuxt.config.jsexport default defineNuxtConfig({ sitemap: { dynamicUrlsApiEndpoint: '/_sitemap' }}); Step2：透過 API 取得動態路由範例： 假設 API 如下 // server/api/users.jsexport default defineEventHandler(() =&gt; { return [ '/user/1', '/user/2' ];}); 在 server/api/_sitemap-urls.js 發出請求並回傳 URL 內容 Nuxt3 $fetch 方法，可以參考&nbsp;這篇文章 // server/api/_sitemap-urls.jsexport default defineEventHandler(async () =&gt; { const [ users, posts ] = await Promise.all([ $fetch('/api/users'), $fetch('/api/posts') ]); return [ ...users, ...posts ].map(url =&gt; { return { loc: url, lastmod: new Date() }; });}); 執行 nuxt dev 編譯後，可以看到動態路由也被加入 Sitemap Sitemap 整合 I18n搭配 Nuxt3 I18n 整合模組 @nuxtjs/i18n 開發，nuxt-simple-sitemap 會自動整合，產出各語系 sitemap 檔 @nuxtjs/i18n 套件安裝參考 這篇文章 範例：語系分為英文與繁中 預設會產出一個 index sitemap（ex：sitemap_index.xml）作為各語系 sitemap 索引 點擊查看英文版 sitemap http://localhost:3000/en-sitemap.xml 如果想合併語系檔，將 sitemaps 設為 false 即可 // nuxt.config.jsexport default defineNuxtConfig({ sitemap: { sitemaps: false }}); 看到這裡，或許有人會納悶為什麼 sitemap 缺少了重要的 hreflang 語系標籤，其實hreflang 是存在的，上面看到的只是閱覽用的 XSL 檔，要查看原始的 sitemap.xml，請見下一段說明 調整 Sitemap UI前面看到的 sitemap 只是方面我們閱覽用的 XSL 檔，搜尋引擎真實讀取到的 sitemap.xml 是沒有 CSS 樣式的檔案 查看原始 Sitemap如果想確認原始 sitemap.xml，將 xsl 設為 false // nuxt.config.jsexport default defineNuxtConfig({ sitemap: { xsl: false }}); sitemap 如果有 &lt;xhtml:link /&gt; 屬性，像是多國語系搭配 hreflang 標籤，瀏覽器畫面渲染會異常，如下圖所示。這只是瀏覽器渲染問題，並不影響 Sitemap 本身功能，搜尋引擎爬蟲一樣可以正常讀取，詳細說明可以參考 討論串 調整欄位顯示內容透過 xslColumns 調整欄位 // nuxt.config.jsexport default defineNuxtConfig({ sitemap: { xslColumns: [ { label: 'URL', width: '25%' }, // URL 欄位必填 { label: 'Last Modified', select: 'sitemap:lastmod', width: '25%' }, { label: 'Change Frequency', select: 'sitemap:changefreq', width: '25%' }, { label: 'Priority', select: 'sitemap:priority', width: '12.5%' }, { label: 'Hreflangs', select: 'count(xhtml:link)', width: '12.5%' } ] }}); Hreflangs 屬性，必須要搭配 nuxt-simple-sitemap v3.3.2 以上版本才能使用 來看一下調整後的畫面 參考資源： https://nuxtseo.com/https://nuxt.com/docs/getting-started/deployment#selective-pre-renderinghttps://stackblitz.com/edit/nuxt-starter-umyso3?file=nuxt.config.ts","link":"/2023/09/18/nuxt3/nuxt-v3-sitemap/"},{"title":"Nuxt.js 3.x 狀態管理 State Management (3)－Pinia Plugin Persistedstate","text":"本篇文章同步發表於 2023 iThome 鐵人賽：Nuxt.js 3.x 筆記－打造 SSR 專案 前一篇 說明了在 Nuxt3 搭配 Pinia 狀態管理工具全域共享狀態，本篇將介紹 pinia-plugin-persistedstate 套件，用來將 Store 狀態儲存於瀏覽器中，避免狀態被還原 Pinia Plugin Persistedstatepinia-plugin-persistedstate 用來將 Store 狀態保存於使用者的瀏覽器中，以下兩個情境推薦使用： 使用者下次再瀏覽畫面時，需保存先前操作的狀態 避免頁面重新整理時，狀態被還原 套件安裝搭配 Nuxt 整合模組 @pinia-plugin-persistedstate/nuxt 進行安裝： npm install -D @pinia-plugin-persistedstate/nuxt pinia-plugin-persistedstate 必須搭配 Pinia 使用 nuxt.config 配置// nuxt.config.jsexport default defineNuxtConfig({ modules: [ '@pinia/nuxt', '@pinia-plugin-persistedstate/nuxt' ]}) Store 開啟狀態保存Option Store將 persist 參數設定為 true // store/index.jsexport const useMainStore = defineStore('main', { state: () =&gt; ({ counter: 0 }), getters: { doubleCounter() { return this.counter * 2; } }, actions: { increment() { this.counter++; } }, persist: true}); Setup StoredefineStore 傳入參數 { persist: true } // store/index.jsexport const useMainStore = defineStore( 'main', () =&gt; { const counter = ref(0); const doubleCounter = computed(() =&gt; counter.value * 2); const increment = () =&gt; { counter.value++; }; return { counter, doubleCounter, increment }; }, { persist: true }); 選項配置預設配置： 儲存於 cookie 預設 key 為 store.$id 使用 JSON.stringify() 與 JSON.parse() 進行序列化 / 反序列化 預設整個 state 都會被保存 Key 型別：string預設值：store.$id 以下為例，預設 key 為 main，調整為 my-custom-key // store/index.jsexport const useMainStore = defineStore('main', () =&gt; { // ... }, { persist: { key: 'my-custom-key' } }); 在儲存庫可以看到調整後的 key 值 storage 預設值：cookie選項：localStorage、sessionStorage、cookie 使用自動引入的 persistedState 變數進行配置 // store/index.jsexport const useMainStore = defineStore('main', () =&gt; { // ... }, { persist: { storage: persistedState.localStorage } }); 因 storage 只存在瀏覽器端，如果未搭配 persistedState 定義，在 ssr 會出現錯誤，也可以透過判斷式定義： { persist: { storage: process.client ? localStorage : null }} cookiesWithOptions()用來設定 cookie，選項同 Nuxt Composable useCookie，storage 需為 cookie 才能使用 // store/index.jsexport const useMainStore = defineStore('main', () =&gt; { // ... }, { persist: { storage: persistedState.cookiesWithOptions({ sameSite: 'strict' }) } }); paths 型別：string[]預設值：undefined 預設整個 state 都會被保存在 storage。如果想指定參數，使用 paths 進行調整 // store/index.jsexport const useMainStore = defineStore('main', () =&gt; { const counter = ref(0); const user = ref({ name: 'Daniel', age: 18 }); }, { persist: { paths: [ 'user.name' ] } }); serializer 預設值：JSON.stringify、JSON.parse 指定序列化方法（必須包含 serialize、deserialize），以下範例調整為壓縮檔 // store/index.jsimport { parse, stringify } from 'zipson';export const useMainStore = defineStore('main', () =&gt; { // ... }, { persist: { serializer: { serialize: stringify, deserialize: parse } } }); debug 型別：boolean預設值：false 設定為 true，當發生任何錯誤，都會使用 conosle.error 印出 全域選項配置在 nuxt.config 使用 piniaPersistedstate 全域調整選項 // nuxt.config.jsexport default defineNuxtConfig({ modules: [ '@pinia/nuxt', '@pinia-plugin-persistedstate/nuxt' ], piniaPersistedstate: { storage: 'cookie', cookieOptions: { sameSite: 'strict' } }}) 參考資源： https://prazdevs.github.io/pinia-plugin-persistedstate/","link":"/2023/08/16/nuxt3/nuxt-v3-state-management-persistedstate/"},{"title":"Nuxt.js 3.x 狀態管理 State Management (2)－Pinia","text":"本篇文章同步發表於 2023 iThome 鐵人賽：Nuxt.js 3.x 筆記－打造 SSR 專案 專案開發過程中常會有狀態共享的需求。父子元件間資料傳遞可以使用 Props 和 $emit，或是 Provide 和 Inject（參考文章），先前在 Nuxt2 介紹了 VueX 管理工具搭配 vuex-persistedstate 保存狀態（參考文章），接下來說明如何在 Nuxt3 利用更便利高效的方式管理共享狀態。 狀態管理預計分為以下三篇說明，本篇將介紹 Pinia： 1. useState：Nuxt Composable 連結2. Pinia：Vue.js 狀態管理工具3. pinia-plugin-persistedstate：維持 Store 狀態 連結 PiniaPinia 是 Vue 官方推薦使用的狀態管理工具，支援 Vue2 跟 Vue3，可以理解為 VueX 的接班人 Pinia vs VueX： 移除 mutations，統一透過 action 操作 state 支援 Typescript，不需要 types 來包裝 不需引入各種 magic strings，直接引入函式即可 不需要動態引入模組，預設為自動 import 移除巢狀 modules，提供更扁平的結構，store 間也可相互使用 移除 namespaced modules，所有模組都已自動定義 Pinia 其他優點： 支援 Devtools Hot module replacement（HMR） 支援 Plugins 支援 Server Side Render 套件安裝搭配 Nuxt 整合模組 @pinia/nuxt 進行安裝： npm install pinia @pinia/nuxt 使用 npm 安裝時如果報錯 ERESOLVE could not resolve，在 package.json 加入以下內容，重新安裝即可 // package.json\"overrides\": { \"vue\": \"latest\"} nuxt.config 配置如果不想全域引入 defineStore，也可以在頁面各別引入：import { defineStore } from 'pinia' // nuxt.config.jsexport default defineNuxtConfig({ modules: [ '@pinia/nuxt' ], pinia: { // 想要各別引入可以移除這段 autoImports: [ 'defineStore' ] }}) 定義 Store在 store 資料夾建立檔案，範例 store/index.js Option Store先以 Option Stores 進行說明，比較直觀好理解 state：功能同 data getters：功能同 computed actions：功能同 methods // store/index.jsexport const useMainStore = defineStore('main', { state: () =&gt; ({ counter: 0 }), getters: { doubleCounter() { return this.counter * 2; } }, actions: { increment() { this.counter++ } }}) Setup Store接著將以上內容改寫為 Composition API ref()：用來定義 state 屬性 computed()：定義 getters function()：定義 actions // store/index.jsexport const useMainStore = defineStore('main', () =&gt; { const counter = ref(0); const doubleCounter = computed(() =&gt; counter.value * 2) const increment = () =&gt; { counter.value++ } return { counter, doubleCounter, increment }}) 使用 Store// pages/count.vue&lt;template&gt; &lt;div&gt; {{ mainStore.counter }} {{ mainStore.doubleCounter }} &lt;button @click=\"mainStore.increment()\"&gt;increment&lt;/button&gt; &lt;/div&gt;&lt;/template&gt;&lt;script setup&gt;import { useMainStore } from '@/store/index';const mainStore = useMainStore();&lt;/script&gt; 使用 Plugins Provide 全域注入 Store// plugins/pinia.jsimport { useMainStore } from '@/store';export default defineNuxtPlugin(({ $pinia }) =&gt; { return { provide: { store: useMainStore($pinia) } };}); 使用 $store 取得狀態 // pages/count.vue&lt;template&gt; &lt;div&gt; {{ $store.counter }} {{ $store.doubleCounter }} &lt;button @click=\"$store.increment()\"&gt;increment&lt;/button&gt; &lt;/div&gt;&lt;/template&gt;&lt;script setup&gt;const { $store } = useNuxtApp();&lt;/script&gt; 還原狀態Option Store使用 $reset() 還原狀態 // pages/index.vue&lt;template&gt; &lt;div&gt; {{ $store.counter }} &lt;button @click=\"reset()\"&gt;reset&lt;/button&gt; &lt;/div&gt;&lt;/template&gt;&lt;script setup&gt;const { $store } = useNuxtApp();const reset = () =&gt; { $store.$reset();};&lt;/script&gt; Setup Store必須自訂 reset 方法 // store/index.jsexport const useMainStore = defineStore('main', () =&gt; { const counter = ref(0); const reset = () =&gt; { counter.value = 0; } return { counter, reset }}) 參考資源： https://nuxt.com/docs/getting-started/state-managementhttps://pinia.vuejs.org/ssr/nuxt.html#nuxt-jshttps://nuxt.com/docs/migration/configuration#vuexhttps://blog.twjoin.com/vue-state-management-介紹-pinia-9f8695110cd7","link":"/2023/08/15/nuxt3/nuxt-v3-state-management-pinia/"},{"title":"Nuxt.js 3.x 狀態管理 State Management (1)－useState","text":"本篇文章同步發表於 2023 iThome 鐵人賽：Nuxt.js 3.x 筆記－打造 SSR 專案 專案開發過程中常會有狀態共享的需求。父子元件間資料傳遞可以使用 Props 和 $emit，或是 Provide 和 Inject（參考文章），先前在 Nuxt2 介紹了 VueX 管理工具搭配 vuex-persistedstate 保存狀態（參考文章），接下來說明如何在 Nuxt3 利用更便利高效的方式管理共享狀態。 狀態管理預計分為以下三篇說明，本篇將介紹 useState： 1. useState：Nuxt Composable2. Pinia：Vue.js 狀態管理工具 連結3. pinia-plugin-persistedstate：維持 Store 狀態 連結 useStateuseState 是 Nuxt3 提供的 Composable，適合用來建立響應式、伺服器端友善（SSR-friendly）的共享狀態 會特別提到 SSR-friendly，要先理解 Nuxt Universal 渲染模式（server-side ＋ client-side），由伺服器端預先載入 HTML，並傳給瀏覽器，接著由瀏覽器載入完整的 Javascript 並執行，至此網頁才具有互動性。因此，若在頁面上定義響應式動態資料如下： &lt;template&gt; &lt;div&gt; {{ count }} &lt;/div&gt;&lt;/template&gt;&lt;script setup&gt;const count = ref(Math.round(Math.random() * 1000));&lt;/script&gt; 瀏覽器會拋出警告：Hydration text content mismatch原因是在伺服器端預先渲染出來的 count，跟瀏覽器後來執行 JS 運算出來的結果不同 useState 參數： key：唯一值，避免重複取得資料（前面提到的 Hydration 問題），如果沒帶入，useState 會自動生成 init：回傳初始值的函式，會回傳一個 ref 物件 T：使用 TypeScript 型別 useState&lt;T&gt;(key: string, init?: () =&gt; T | Ref&lt;T&gt;): Ref&lt;T&gt; useState 共享狀態// pages/index.vue&lt;template&gt; &lt;div&gt; {{ counter }} &lt;/div&gt;&lt;/template&gt;&lt;script setup&gt;const counter = useState('counter', () =&gt; Math.round(Math.random() * 1000));&lt;/script&gt; 其他頁面使用 useState('counter') 可以同步取得／更新狀態 // pages/count.vue&lt;template&gt; &lt;div&gt; {{ counter }} &lt;button @click=\"counter++\"&gt;+&lt;/button&gt; &lt;button @click=\"counter--\"&gt;-&lt;/button&gt; &lt;/div&gt;&lt;/template&gt;&lt;script setup&gt;const counter = useState('counter', () =&gt; Math.round(Math.random() * 1000));&lt;/script&gt; 注意：若直接使用 const counter = useState('counter') 取值，而 useState('counter') 尚未被賦值，可能會發生錯誤，可以使用以下方法定義預設值 useState 搭配 Composables 全域共享狀態將狀態定義在 Composables，可以定義預設值，並在頁面間共享狀態 名稱自訂，範例使用 composables/state.js // composables/state.jsexport const useCounter = () =&gt; useState('counter', () =&gt; Math.round(Math.random() * 1000)); 頁面使用 useCounter() 取值（等同於 useState('counter')），並可更新狀態 // pages/count.vue&lt;template&gt; &lt;div&gt; {{ counter }} &lt;button @click=\"counter++\"&gt;+&lt;/button&gt; &lt;button @click=\"counter--\"&gt;-&lt;/button&gt; &lt;/div&gt;&lt;/template&gt;&lt;script setup&gt;const counter = useCounter();&lt;/script&gt; clearNuxtState 清除狀態使用 clearNuxtState(key) 清除當前儲存的狀態 // pages/index.vue&lt;template&gt; &lt;div&gt; {{ counter }} &lt;button @click=\"clearCounter()\"&gt;clear&lt;/button&gt; &lt;/div&gt;&lt;/template&gt;&lt;script setup&gt;const counter = useCounter();const clearCounter = () =&gt; { clearNuxtState('counter');};&lt;/script&gt; 參考資源： https://nuxt.com/docs/getting-started/state-managementhttps://ithelp.ithome.com.tw/articles/10302323","link":"/2023/08/14/nuxt3/nuxt-v3-state-management-usestate/"},{"title":"Nuxt.js 3.x 將靜態網站部署到 GitHub Pages","text":"本篇文章同步發表於 2023 iThome 鐵人賽：Nuxt.js 3.x 筆記－打造 SSR 專案 專案開發完成後，終於到最後一步「部署」，本篇使用靜態網站生成（SSG），搭配 GitHub Pages 託管靜態網頁內容。 Static Site Generation（SSG）靜態網站生成在編譯時產生靜態 HTML 頁面。靜態部署適合內容固定、不需資料庫、不含伺服器端動態渲染的網站（例如公司形象網站或是個人部落格），雖然不像 Universal Rendering 一樣彈性，不過靜態網站很適合搭配 CDN 緩存。 實作部署Step1：建立 GitHub Repository在 Github 建立一個儲存庫 &lt;username&gt;.github.io/&lt;repository&gt;（連結） &lt;username&gt;：自己的使用者名稱 &lt;repository&gt;：自訂專案名，本篇範例命名為 nuxt3-generate Step2：上傳專案至 GitHub接著看到以下指引畫面，回到專案，依照指令上傳至 GitHub Step3：安裝 gh-pages專案安裝 gh-pages 套件至 devDependencies npm i -D gh-pages Step4：nuxt.config 配置 baseURL：因部署上 GitHub 網址會加上 /&lt;repository&gt;/，因此須調整為 /&lt;repository&gt;/process.env.NODE_ENV 為 Node.js 環境變數，執行 npm run dev 開發模式下啟動專案，process.env.NODE_ENV 值為 “development”，在生產模式啟動專案，則為 “production” buildAssetsDir：assets/ 編譯後的目錄名稱，預設為 /_nuxt/，Github Pages 預設使用 Jekyll 靜態網站生成工具，Jekyll 會自動忽略所有下底線（_）前綴的資料夾與檔案，因此將 _nuxt 調整為其他名稱 // nuxt.config.jsexport default defineNuxtConfig({ app: { baseURL: process.env.NODE_ENV === 'production' ? '/nuxt3-generate/' : '/', buildAssetsDir: '/static/' }} Step5：加上 public/.nojekyll 檔案上一步有提到，Jekyll 會自動忽略所有下底線前綴的資料夾與檔案，因此專案部署到 GitHub 後，會因 _payload.json 讀取不到，拋出 404 錯誤。在根目錄 public/ 資料夾加上 .nojekyll 空白檔案，用來告訴 GitHub 當前網站並不是基於 Jekyll 建置 Step6：加入 gh-pages 指令package.json scripts 加入以下指令，以下指令會將編譯完成的 .output/public 靜態內容部署至 GitHub Pages \"deploy\": \"gh-pages --dotfiles -d .output/public\" Step7：執行部署執行以下指令，產生靜態檔 npm run generate 編譯完成後，專案根目錄會產生一個 .output 資料夾 public 為靜態資源檔，定義在 public/ 與 assets/ 的檔案都會被打包在這 assets/ 編譯後的檔案又會被包在 static/，對應前面設定的 buildAssetsDir 目錄名稱 每個靜態頁會各自編譯成 _payload.json 與 index.html .output/|—— public/ |—— static/ |—— bg.7e80f349.png |—— index.3fc7cdc4.js |—— index.9c7e60ac.css |—— about/ |—— _payload.json |—— index.html |—— _payload.json |—— index.html |—— favicon.ico |—— ...|—— nitro.json 接著執行部署到 GitHub Pages npm run deploy 部署完成後，回到 GitHub 切到 gh-pages 分支，順利的話，在瀏覽器輸入網址 https://&lt;username&gt;.github.io/&lt;repository&gt;/ 就可以看到首頁畫面囉～ 範例檔 程式碼：連結 頁面：連結 加入動態路由頁面執行 npm run generate 時，Nitro 爬蟲會先抓取靜態頁面，以及有被連結到的動態路由，沒有被連結到的動態路由必須手動配置 範例：動態路由結構如下 pages/｜—— user/ ｜—— [id].vue 在 nuxt.config 手動配置預渲染路由，也可以透過 ignore/ 排除路由 // nuxt.config.jsdefineNuxtConfig({ nitro: { prerender: { routes: ['/user/1', '/user/2'], ignore: ['/dynamic'] } }}); 執行 npm run generate 編譯後，在 .output 可以看到 /user/1、/user/2 也預先編譯為靜態頁 .output/|—— public/ |—— user/ |—— 1/ |—— _payload.json |—— index.html |—— 2/ |—— _payload.json |—— index.html |—— ... 延伸：自訂網域除了使用 GitHub 提供的免費域名，也可以購買自己的網域，先前寫過一篇文章提供參考：GitHub Pages 自訂域名與 HTTPS 設定 參考資源： https://nuxt.com/docs/getting-started/deploymenthttps://github.com/lucpotage/nuxt-github-pages","link":"/2023/10/03/nuxt3/nuxt-v3-static-site-generation/"},{"title":"Nuxt.js 3.x 搭配 CSS Framework－以 Bootstrap 5 為例","text":"本篇文章同步發表於 2023 iThome 鐵人賽：Nuxt.js 3.x 筆記－打造 SSR 專案 Bootstrap 版本：v5.3.1Sass 版本：v1.63.6 在 Nuxt 專案中，我們可以自由選擇 CSS 預處理器、CSS 框架或是 UI Library 來定義樣式。在 CSS 框架百家爭鳴的時代，這幾年熱門的 Tailwind CSS、基於 Vue.js 開發的 Quasar、或是搭配 Vue3 開發的 Element Plus 都能快速上手，協助我們打造精美的網站。 由於工作上較常使用 Bootstrap 協作，本篇將以 Bootstrap 5 搭配 SCSS 進行說明。 Bootstrap 5 簡介 Bootstrap 有豐富的 Sass 變數、mixins、網格系統、元件、JS 插件，Bootstrap 5 與先前版本最大的不同，除了將 jQuery 從相依項目中移除，也新增 Utilities API（基於 Sass Maps 生成 Utilities Class），可以更簡易的管理或擴充樣式，不需手刻太多 CSS 即可完成多元、複雜的畫面。 套件安裝npm install bootstrapnpm install sass 使用 Bootstrap 樣式搭配自訂樣式在 assets/ 靜態資源目錄定義 SCSS，範例 assets/scss/app.scss，需注意 Bootstrap 樣式與自訂樣式引入順序： 不建議直接引入整包 bootstrap components bootstrap/scss/bootstrap ，選擇需要的樣式引入即可，避免 CSS 檔案過大，造成系統負擔 // assets/scss/app.scss/** 1. 引入 functions，才能操控 color, svg, calc... */@import \"bootstrap/scss/functions\";/** 2. 自訂變數置於 bootstrap variables 前，覆蓋 bootstrap 變數 */@import \"./color\";@import \"./variables\";/** 3. 引入 variables, mixins, root */@import \"bootstrap/scss/variables\";@import \"bootstrap/scss/variables-dark\";@import 'bootstrap/scss/maps';@import \"bootstrap/scss/mixins\";@import \"bootstrap/scss/root\";/** 4. 引入 utilities */@import \"~bootstrap/scss/utilities\";/** 5. 自訂、擴充、調整 utilities */@import \"./utilities\";/** 6. 引入需要的 bootstrap components */@import \"bootstrap/scss/reboot\";@import \"bootstrap/scss/type\";@import \"bootstrap/scss/containers\";@import \"bootstrap/scss/grid\";@import \"bootstrap/scss/tables\";@import \"bootstrap/scss/forms\";@import \"bootstrap/scss/buttons\";@import \"bootstrap/scss/helpers\";/** ... *//** 7. 使用 utilities 需引入 utilities api（將 sass map 轉換為 utility classes） */@import \"bootstrap/scss/utilities/api\";/** 8. 客製樣式置於最後，覆蓋前面的樣式 */@import \"./style\"; 自訂樣式檔案結構： assets/|—— scss/ |—— app.scss |—— _color.scss |—— _variables.scss |—— _style.scss 自訂、擴充、調整 utilities： 透過 map-merge 合併 bootstrap utilities，詳細定義方式參考 官方文件 // assets/scss/utilities.scss$utilities: map-merge( $utilities, ( \"cursor\": ( property: cursor, class: cursor, responsive: true, values: auto pointer grab ) )); 配置全域共用 CSS接著在 nuxt.config 配置全域共用 CSS，接下來整個專案 HTML 都能使用編譯後的樣式 // nuxt.config.jsexport default defineNuxtConfig({ css: [ '@/assets/scss/app.scss' ], postcss: { // CSS 屬性加上瀏覽器相容性前綴 plugins: { autoprefixer: true } }}) Nuxt 專案已內建 postcss，加上 autoprefixer: true 會自動為屬性加上瀏覽器相容性前綴範例定義以下樣式： .container { display: flex;} 編譯後的 CSS： .container { display: -webkit-box; display: -ms-flexbox; display: flex;} 定義全域共用 Sass / SCSS 變數（搭配 Vite）如果想在 .vue 檔內的 &lt;style&gt; 直接使用 Sass / SCSS 變數，需搭配 preprocessorOptions 進行配置 // nuxt.config.jsexport default defineNuxtConfig({ vite: { css: { preprocessorOptions: { scss: { additionalData: ` @import \"@/assets/scss/_color.scss\"; @import \"@/assets/scss/_variables.scss\"; ` } } } }}); // assets/scss/_color.scss$primary: #49240F;$secondary: #E4A79D; 接著就可以在 SCF（單一元件檔）使用 SCSS 變數 // pages/hello.vue&lt;template&gt; &lt;div&gt; &lt;h1&gt;Hello World&lt;/h1&gt; &lt;/div&gt;&lt;/template&gt;&lt;style lang=\"scss\" scoped&gt;h1 { color: $primary;}&lt;/style&gt; 加上 scoped，將樣式作用域限制在元件內，避免造成全域污染，如果希望樣式可以渲染到子元件，透過 :deep() 定義如下 :deep(h3) { color: $primary;} 使用 Bootstrap Plugins在 plugins/ 目錄註冊 Bootstrap JavaScript Plugins 新增 plugins/bootstrap.client.js 注意：Nuxt 會自動引入（auto imports）plugins，bootstrap plugins 要限制在 client 端使用，否則會拋錯 document is not defined ，檔名需加上 .client 後綴 透過 Provide 定義全局變數，將需要的 Bootstrap Plugins 注入到 NuxtApp // plugins/bootstrap.client.jsimport * as bootstrap from 'bootstrap';const { Modal, Collapse } = bootstrap;export default defineNuxtPlugin(_nuxtApp =&gt; { return { provide: { bootstrap: { modal: element =&gt; new Modal(element), collapse: element =&gt; new Collapse(element) } } };}); 使用 Modal Plugins // pages/about.vue&lt;template&gt; &lt;div&gt; &lt;div class=\"modal fade\" tabindex=\"-1\" ref=\"modalRef\"&gt; &lt;div class=\"modal-dialog\"&gt; &lt;div class=\"modal-content\"&gt; &lt;div class=\"modal-header\"&gt; ... &lt;/div&gt; &lt;div class=\"modal-body\"&gt; ... &lt;/div&gt; &lt;div class=\"modal-footer\"&gt; &lt;button type=\"button\" data-bs-dismiss=\"modal\"&gt;close&lt;/button&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;button type=\"button\" class=\"btn btn-success\" @click=\"showModal\"&gt; 點我看 Modal &lt;/button&gt; &lt;/div&gt;&lt;/template&gt;&lt;script setup&gt;const { $bootstrap } = useNuxtApp();const modalRef = ref(null);let modal;const showModal = () =&gt; { modal.show();};onMounted(() =&gt; { modal = $bootstrap.modal(modalRef.value);});onBeforeUnmount(() =&gt; { // 加上 dispose，避免切換頁面時或是 HMR 看到殘留畫面 modal.dispose();});&lt;/script&gt; 動態樣式動態樣式定義方式同 Vue3，在 CSS 使用 v-bind function // pages/hello.vue&lt;template&gt; &lt;div&gt; &lt;h1&gt;hello&lt;/h1&gt; &lt;h2&gt;world&lt;/h2&gt; &lt;button @click=\"theme.color = 'red'\"&gt;change color&lt;/button&gt; &lt;/div&gt;&lt;/template&gt;&lt;script setup&gt;const theme = ref({ color: 'green'});&lt;/script&gt;&lt;style lang=\"scss\" scoped&gt;h1, h2 { color: v-bind('theme.color');}&lt;/style&gt; 參考資源： https://nuxt.com/docs/getting-started/stylinghttps://vite.nuxtjs.org/misc/common-issues#styleresourceshttps://getbootstrap.com/","link":"/2023/08/25/nuxt3/nuxt-v3-styling/"},{"title":"Nuxt.js 3.x Stylelint SCSS 程式碼檢查與自動排版","text":"本篇文章同步發表於 2023 iThome 鐵人賽：Nuxt.js 3.x 筆記－打造 SSR 專案 Stylelint 是一套用於規範 CSS 和 CSS 預處理器（SCSS、Less 等）程式碼的工具，幫助我們維持程式碼的品質和風格。Stylelint 進行檢查時，會根據指定的規則來發現潛在的錯誤、不一致的風格和不推薦的模式。 以 *.vue 檔為例，檔案內包含三種主要的程式碼：&lt;template&gt;、&lt;script&gt; 和 &lt;style&gt;： &lt;template&gt;：Vue.js 模板語法，用以定義 HTML，例如插槽 {{ }}、條件判斷和迴圈等。雖然這不是嚴格的 JavaScript 語法，但 ESLint 也提供了相關規則對模板語法進行檢查 &lt;script&gt;：JavaScript 區塊，由 ESLint 進行程式碼檢查 &lt;style&gt;：CSS 區塊，用於定義元件樣式，由 Stylelint 進行程式碼檢查 ESLint 搭配 Stylelint，讓專案保持良好的 Coding Style。本篇將說明如何在 Nuxt3 專案搭配 Stylelint 工具。 ESLint JavaScript 程式碼檢查工具參考 這篇文章 套件安裝整合套件 @nuxtjs/stylelint-module：Nuxt 搭配 Stylelint 的整合模組 @nuxtjs/stylelint-module 提供了在 Nuxt 使用 Stylelint 的整合模組，但並未包含 Stylelint、相關配置以及 PostCSS 相關套件，需手動安裝相依套件 相依套件 stylelint：實際執行 CSS 程式碼檢查的工具 stylelint-config-standard-vue：stylelint 規則配置，用於檢查文件中 &lt;style&gt; 區塊的 CSS stylelint-config-standard-scss：stylelint 規則配置，基於 stylelint-config-standard 的擴充，用於檢查 SCSS 程式碼 stylelint-order：stylelint 插件，規範 CSS 屬性的排序順序 postcss、postcss-scss、postcss-html：擴展 CSS 和 SCSS 的後處理器工具 npm install -D @nuxtjs/stylelint-module \\ stylelint \\ stylelint-config-standard-vue \\ stylelint-config-standard-scss \\ stylelint-order \\ postcss postcss-scss postcss-html nuxt.config 配置stylelint 配置選項參考 官方文件 // nuxt.config.jsexport default defineNuxtConfig({ modules: [ ... '@nuxtjs/stylelint-module' ], stylelint: { lintOnStart: false, // 專案啟動時不自動檢查所有相關檔案 chokidar: true // 監聽文件異動進行檢核（文件未列出此選項） }}) .stylelintrc.js 設定檔配置目錄新增 .stylelintrc.js，配置如下： extends：擴展 stylelint 配置 overrides：定義特定文件或文件類型覆蓋配置，會覆寫 rules 定義的全域規則 plugins：配置 stylelint 插件 rules：定義全域 stylelint 規則，選項參考 官方文件 // .stylelintrc.jsmodule.exports = { extends: [ 'stylelint-config-standard-scss', 'stylelint-config-standard-vue/scss' ], plugins: [ 'stylelint-order' ], overrides: [ { files: [ '*.scss', '**/*.scss' ], // 指定 .scss 檔 rules: { 'scss/no-global-function-names': null // 關閉此規則 } } ], rules: { // ... 'unit-allowed-list': [ 'em', 'rem', 'deg', 'px' ], // 可使用的單位 'order/properties-order': [ // 設定排序順序（plugins 必須先定義 stylelint-order） 'position', 'top', 'bottom', 'right', 'left', 'display', 'align-items', 'justify-content', 'float', 'clear', 'overflow', 'overflow-x', 'overflow-y', 'margin', 'margin-top', 'margin-right', 'margin-bogttom', 'margin-left', 'padding', 'padding-top', 'padding-right', 'padding-bottom', 'padding-left', 'width', 'min-width', 'max-width', 'height', 'min-height', 'max-height', 'font-size', 'font-family', 'font-weight', 'text-align', 'text-justify', 'text-indent', 'text-overflow', 'text-decoration', 'white-space', 'color', 'background', 'background-position', 'background-repeat', 'background-size', 'background-color', 'background-clip', 'border', 'border-style', 'border-width', 'border-color', 'border-top-style', 'border-top-width', 'border-top-color', 'border-right-style', 'border-right-width', 'border-right-color', 'border-bottom-style', 'border-bottom-width', 'border-bottom-color', 'border-left-style', 'border-left-width', 'border-left-color', 'border-radius', 'opacity', 'filter', 'list-style', 'outline', 'visibility', 'z-index', 'box-shadow', 'text-shadow', 'resize', 'transition' ] }} VSCode 配置程式碼格式化1. 安裝擴充首先需在 VSCode 安裝擴充：Stylelint 2. 設定自動格式化在專案根目錄新增 .vscode/settings.json |——.vscode/ |—— settings.json|——my-app/ |—— .nuxt/ |—— .stylelintrc.js |—— app.vue |—— ... 接著配置如下： editor.codeActionsOnSave：儲存文件時執行的程式碼操作（Code Actions） stylelint.validate：設定需驗證的文件類型 { \"editor.codeActionsOnSave\": { \"source.fixAll\": false, \"source.fixAll.stylelint\": true }, \"stylelint.validate\": [ \"css\", \"scss\", \"vue\" ]} 設定完成後，可能需要重啟專案才能成功運作，接著在儲存檔案時，Stylelint 就會協助我們自動排版囉！ 參考資源： https://github.com/ota-meshi/stylelint-config-standard-vuehttps://github.com/nuxt-modules/stylelinthttps://ithelp.ithome.com.tw/articles/10297223?sc=pt#_=_https://paper-hsiao.medium.com/stylelint-幫助你整理-css-的好幫手-b708adab430e","link":"/2023/08/04/nuxt3/nuxt-v3-stylelint/"},{"title":"Nuxt.js 3.x 套件應用－Swiper 製作輪播動畫","text":"本篇文章同步發表於 2023 iThome 鐵人賽：Nuxt.js 3.x 筆記－打造 SSR 專案 nuxt-swiper 版本：v1.2.0 網站開發常使用到輪播功能，Swiper 是一款基於 Javascript 開發、功能完整、實用性高的輪播套件，接下來說明在 Nuxt3 專案搭配 nuxt-swiper 實作 Nuxt2 搭配 Swiper 請參考 這篇文章 套件安裝使用 Nuxt 整合模組 nuxt-swiper 進行安裝（基於 Swiper Vue） npm install nuxt-swiper nuxt.config 配置swiper 配置選項： prefix：元件名稱前綴，預設為 Swiper styleLang：style 語言，預設為 css modules：引入的模組，預設為全部引入，模組選項參考 官方文件 // nuxt.config.jsexport default defineNuxtConfig({ modules: [ 'nuxt-swiper' ], swiper: { modules: ['navigation', 'pagination', 'effect-creative' ] }}) 建立輪播動畫在頁面上使用元件，範例頁面 pages/swiper.vue 自動引入元件：&lt;Swiper&gt;、&lt;SwiperSlide&gt; （名稱依照前面設定的 prefix） 自動引入模組：依照前面設定的 modules，這裡為 &lt;SwiperNavigation&gt; 以及 &lt;SwiperPagination&gt; props 傳入屬性：屬性選項參考 Swiper 官方文件 // pages/swiper.vue&lt;template&gt; &lt;div&gt; &lt;Swiper :modules=\"[ SwiperNavigation, SwiperEffectCreative ]\" :slides-per-view=\"1\" :space-between=\"16\" :loop=\"true\"&gt; &lt;SwiperSlide&gt;Slide 1&lt;/SwiperSlide&gt; &lt;SwiperSlide&gt;Slide 2&lt;/SwiperSlide&gt; &lt;SwiperSlide&gt;Slide 3&lt;/SwiperSlide&gt; &lt;SwiperSlide&gt;Slide 4&lt;/SwiperSlide&gt; &lt;/Swiper&gt; &lt;/div&gt;&lt;/template&gt; 或是將屬性包裝成物件，透過 v-bind 傳入，配置選項較複雜時，能提升模板可讀性 // pages/swiper.vue&lt;template&gt; &lt;div&gt; &lt;Swiper v-bind=\"swiperConfig\"&gt; &lt;SwiperSlide&gt;Slide 1&lt;/SwiperSlide&gt; &lt;SwiperSlide&gt;Slide 2&lt;/SwiperSlide&gt; &lt;SwiperSlide&gt;Slide 3&lt;/SwiperSlide&gt; &lt;SwiperSlide&gt;Slide 4&lt;/SwiperSlide&gt; &lt;/Swiper&gt; &lt;/div&gt;&lt;/template&gt;&lt;script setup&gt;const swiperConfig = { modules: [ SwiperNavigation, SwiperEffectCreative ], slidesPerView: 1, spaceBetween: 16, loop: true, breakpoints: { 545: { slidesPerView: 2 }, 1080: { slidesPerView: 3 }, 1280: { slidesPerView: 4 } }};&lt;/script&gt; Swiper 事件事件選項參考 官方文件 // pages/swiper.vue&lt;template&gt; &lt;div&gt; &lt;Swiper @slide-change=\"slideChange()\"&gt; ... &lt;/Swiper&gt; &lt;/div&gt;&lt;/template&gt;&lt;script setup&gt;const slideChange = () =&gt; { console.log('slideChange');};&lt;/script&gt; Swiper 樣式使用 Swiper 預設樣式（樣式選擇） // import Swiper 與模組樣式import 'swiper/css';import 'swiper/css/navigation';import 'swiper/css/pagination'; useSwiper 實作控制按鈕使用 Swiper Vue useSwiper hook，來取得 Swiper 實體，呼叫相關方法（ex: slidePrev()） // components/SwiperController.vue&lt;template&gt; &lt;button @click=\"direction === 'prev' ? swiper.slidePrev() : swiper.slideNext()\"&gt; {{ direction }} &lt;/button&gt;&lt;/template&gt;&lt;script setup&gt;const props = defineProps({ direction: { type: String, default: '', validator: value =&gt; { return [ 'prev', 'next' ].includes(value); } }});const swiper = useSwiper();&lt;/script&gt; // pages/swiper.vue&lt;template&gt; &lt;div&gt; &lt;Swiper&gt; &lt;SwiperSlide&gt;Slide 1&lt;/SwiperSlide&gt; &lt;SwiperSlide&gt;Slide 2&lt;/SwiperSlide&gt; &lt;SwiperSlide&gt;Slide 3&lt;/SwiperSlide&gt; &lt;SwiperSlide&gt;Slide 4&lt;/SwiperSlide&gt; &lt;SwiperController direction=\"prev\" /&gt; &lt;SwiperController direction=\"next\" /&gt; &lt;/Swiper&gt; &lt;/div&gt;&lt;/template&gt; 參考資源： https://github.com/cpreston321/nuxt-swiper#readmehttps://swiperjs.com/vue","link":"/2023/08/16/nuxt3/nuxt-v3-swiper/"},{"title":"Nuxt.js 3.x ESLint 程式碼規範與自動排版－搭配 TypeScript","text":"本篇文章同步發表於 2023 iThome 鐵人賽：Nuxt.js 3.x 筆記－打造 SSR 專案 Nuxt 3 完整支援 TypeScript 開發，TypeScript 相關設定在專案根目錄 tsconfig.json，本篇將說明： 安裝 ESLint 程式碼檢核工具（JavaScript／TypeScript） TypeScript 型別檢查 VScode 安裝 Volar Extension VSCode 配置程式碼格式化 ESLint（ECMAScript Lint）ESLint 是一個開源的 JavaScript / TypeScript 程式碼規範工具，用於檢查和尋找程式碼中的問題、錯誤，例如未使用的變數、未定義的變數、重複的程式碼、錯誤的語法等。 透過 ESLint，我們可以根據專案需求和團隊規範，定義適合的程式碼檢查規則，例如縮排、換行、引號使用等，並整合到開發流程中，以提高程式碼品質、減少錯誤，並確保一致的程式碼風格。 開發者常用的規範有 Google、Airbnb、JavaScript Standard Style 等，本篇使用 Nuxt3 官方搭配的 ESLint 進行說明。 CSS／SCSS 程式碼檢核需搭配 Stylelint，可以參考 這篇文章 1. 套件安裝使用 nuxt 整合模組 @nuxtjs/eslint-config-typescript devDependencies npm install --save-dev @nuxtjs/eslint-config-typescript eslint 2. 配置 .eslintrc.js 設定檔在專案根目錄新增 .eslintrc.js，配置如下： rules：根據專案需求自訂規範，選項及預設值可以參考 官方文件 // .eslintrc.jsmodule.exports = { root: true, extends: [ '@nuxtjs/eslint-config-typescript' ], parserOptions: { parser: '@typescript-eslint/parser' }, rules: { // 自訂規則 quotes: ['error', 'single'], // 使用單引號 'no-console': 'warn' // 使用 console 時警告提示 }} 根據 官方文件 說明，@nuxtjs/eslint-config-typescript 擴充設定完成後，ESLint 預設會使用 @typescript-eslint/parser 作為語法分析器，不需設定，不過需留意 parserOptions.parser 選項不能被其他設定覆寫 3. 執行 lint 檢查在 package.json scripts 配置 lint 指令 \"lint\": \"eslint --ext .ts,.js,.vue .\" 執行 npm run lint 查看檢核結果 TypeScript 型別檢查TypeScript 相較於 Javascript 最大優點是靜態型別定義和檢查。Nuxt 基於效能考量，在執行 nuxi dev 或 nuxi build 時不會自動檢查型別，可以透過以下方式進行型別檢核： 首先在 app.vue 加上一段程式碼： // app.vue&lt;template&gt; &lt;div&gt; &lt;NuxtWelcome /&gt; &lt;/div&gt;&lt;/template&gt;&lt;script lang=\"ts\" setup&gt;const num: number = '123';&lt;/script&gt; 方法一：手動執行型別檢查透過 nuxi 指令來執行 vue-tsc 檢查型別 npx nuxi typecheck 顯示錯誤提示如下 方法二：自動執行型別檢查直接安裝 vue-tsc 以及 typescript devDependencies npm install --save-dev vue-tsc typescript 在 nuxt.config 啟用 typescript.typeCheck // nuxt.config.jsexport default defineNuxtConfig({ typescript: { typeCheck: true }}); 之後在執行 nuxi dev 或 nuxi build 都會自動檢核型別 VSCode 安裝 Volar ExtensionVolar 是一個針對 Vue.js 開發的擴充套件，在編輯器中提供了更好的型別支援、錯誤檢測和自動補全功能，讓我們可以在編譯前預先發現錯誤，有助於提升開發效率和程式碼品質，Nuxt 官方也建議安裝。 TypeScript Vue Plugin (Volar)： 針對 TypeScript 在 Vue 項目中的支援，提供了強大的 TypeScript 支援，包括類型推斷、定義跳轉、重構支援等功能 Vue Language Features (Volar)： 主要提供了 Vue 項目的語言支援，包括模板的類型檢查、即時錯誤檢測、自動完成等功能 安裝完成後，可以看到編輯器出現提示訊息： VSCode 配置自動排版許多開發者習慣整合 ESLint 與 Prettier 開發，不過根據 Nuxt3 官方文件 說明，因兩者容易產生衝突，且 ESLint 可以配置自動格式化，因此不建議安裝 Prettier。 透過在 IDE（整合開發環境）進行設定，就可以執行程式碼格式化。 官方提到，未來或許還是會兼容 Prettier，詳請參考 討論串 1. 新增 settings.json在專案根目錄新增 .vscode/settings.json 檔 |—— .vscode/ |—— settings.json|—— my-app/ |—— .nuxt/ |—— app.vue |—— ... 2. 啟用自動修正和格式化功能// .vscode/settings.json{ \"editor.codeActionsOnSave\": { \"source.fixAll\": false, \"source.fixAll.eslint\": true }} 設定完成後，需要重啟專案才能成功運作，接著在儲存檔案時，ESLint 就可以幫我們自動排版囉！ 參考資源： https://github.com/nuxt/eslint-config#readmehttps://typescript.nuxtjs.org/guide/lint/https://nuxt.com/docs/guide/concepts/typescript#typescript","link":"/2023/06/30/nuxt3/nuxt-v3-typescript-and-eslint/"},{"title":"Nuxt.js 3.x 套件應用－VeeValidate v4.x 表單驗證","text":"本篇文章同步發表於 2023 iThome 鐵人賽：Nuxt.js 3.x 筆記－打造 SSR 專案 Nuxt2 vee-validate 請參考 這篇文章 vee-validate 是使用於 Vue.js 的輕量表單驗證套件，僅需在表單上加入簡易語法就能進行驗證 Vue.js v3.x 需搭配 vee-validate v4.x step1：vee-validate 套件安裝使用 Nuxt 整合套件 @vee-validate/nuxt npm i @vee-validate/nuxt step2：nuxt.config 配置// nuxt.config.tsexport default defineNuxtConfig({ // ... modules: [ '@vee-validate/nuxt', ], veeValidate: { // 啟用 auto imports autoImports: true, // 更換 components 名稱 componentNames: { Form: 'VeeForm', Field: 'VeeField', FieldArray: 'VeeFieldArray', ErrorMessage: 'VeeErrorMessage', } }}); step3：@vee-validate/rules 驗證規則擴充我們可以在 vee-validate 自訂驗證規則，或是搭配預設規則，若要使用預設規則，步驟如下 安裝驗證規則套件： npm i @vee-validate/rules 新增 plugins/vee-validate.client.js，擴充所有規則： // vee-validate.client.jsimport { defineRule } from 'vee-validate';import allRules from '@vee-validate/rules';// 迴圈依序加入規則Object.keys(allRules).forEach(rule =&gt; { defineRule(rule, allRules[rule]);});// 必須定義，用來封裝 pluginexport default defineNuxtPlugin(_nuxtApp =&gt; {}); step4：@vee-validate/i18n 語系設定安裝 i18n 套件： npm i @vee-validate/i18n 新增 plugins/vee-validate.client.js，進行語系調整： // vee-validate.client.jsimport { configure } from 'vee-validate';import { localize, setLocale } from '@vee-validate/i18n';import zhTW from '@vee-validate/i18n/dist/locale/zh_TW.json';// 配置訊息configure({ generateMessage: localize({ zh_TW: zhTW })});setLocale('zh_TW');// 必須定義，用來封裝 pluginexport default defineNuxtPlugin(_nuxtApp =&gt; {}); step5：表單驗證 觸發 submit 時，會自動傳出表單內容，因此欄位不需要另外綁定 v-model &lt;VeeForm /&gt; 元件 submit listener 觸發時會自動調用 event.preventDefault() rules 個別設定驗證項目，可以自訂規則或使用預設規則。若使用 @vee-validate/rules 搭配多個規則，用 | 做區隔 &lt;template&gt; &lt;VeeForm @submit=\"submit\"&gt; &lt;VeeField name=\"email\" type=\"email\" rules=\"required|email\" /&gt; &lt;VeeErrorMessage name=\"email\" /&gt; &lt;VeeField name=\"password\" type=\"password\" :rules=\"checkPassword\" /&gt; &lt;VeeErrorMessage name=\"password\" /&gt; &lt;button type=\"submit\"&gt;submit&lt;/button&gt; &lt;/VeeForm&gt;&lt;/template&gt;&lt;script setup&gt;const checkPassword = value =&gt; { if (...) { return false; } return true;}const submit = value =&gt; { console.log('submit', value);};&lt;/script&gt; 1. 驗證成功前禁止送出表單利用 &lt;VeeForm /&gt; 的 meta.valid 屬性來檢查是否驗證成功 &lt;VeeForm @submit=\"submit\" v-slot=\"{ meta }\"&gt; ... &lt;button type=\"submit\" :disabled=\"!meta.valid\"&gt;submit&lt;/button&gt;&lt;/VeeForm&gt; 2. 表單送出完成／失敗前禁止重複觸發利用 &lt;VeeForm /&gt; 的 meta.isSubmitting 屬性判斷 submit handler 是否在執行中 &lt;template&gt; &lt;VeeForm @submit=\"submit\" v-slot=\"{ isSubmitting }\"&gt; ... &lt;button type=\"submit\" :disabled=\"isSubmitting\"&gt; &lt;span class=\"spinner\" v-show=\"isSubmitting\"&gt;&lt;/span&gt; submit &lt;/button&gt; &lt;/VeeForm&gt;&lt;/template&gt;&lt;script setup&gt;const submit = value =&gt; { return new Promise(resolve =&gt; { setTimeout(() =&gt; { console.log('sumbit', value); resolve(); }, 2000); });};&lt;/script&gt; 3. schema 統一管理規則除了透過 rules 設定驗證規則，也可以直接在表單外層透過 validation-schema props 統一定義規則 &lt;template&gt; &lt;VeeForm @submit=\"submit\" :validation-schema=\"schema\"&gt; &lt;VeeField name=\"email\" type=\"email\" /&gt; &lt;VeeErrorMessage name=\"email\" /&gt; &lt;VeeField name=\"password\" type=\"password\" /&gt; &lt;VeeErrorMessage name=\"password\" /&gt; &lt;button type=\"submit\"&gt;submit&lt;/button&gt; &lt;/VeeForm&gt;&lt;/template&gt;&lt;script setup&gt;const schema = { email: 'required|email', password: 'required|min:8'};&lt;/script&gt; 4. 帶入預設值setValues(fields) ：帶入整個表單資料，自動觸發驗證 &lt;template&gt; &lt;VeeForm @submit=\"submit\" ref=\"veeForm\"&gt; &lt;VeeField name=\"email\" type=\"email\" /&gt; &lt;VeeErrorMessage name=\"email\" /&gt; &lt;VeeField name=\"password\" type=\"password\" /&gt; &lt;VeeErrorMessage name=\"password\" /&gt; &lt;button type=\"submit\"&gt;submit&lt;/button&gt; &lt;/VeeForm&gt;&lt;/template&gt;&lt;script setup&gt;const veeForm = ref(null);onMounted(() =&gt; { const form = { email: 'test@myweb.com', password: '12344321' }; veeForm.value.setValues(form);});&lt;/script&gt; setFieldValue(field, value) ：帶入單欄資料，觸發此欄驗證 &lt;template&gt; &lt;VeeForm @submit=\"submit\" ref=\"veeForm\"&gt; &lt;VeeField name=\"email\" type=\"email\" /&gt; &lt;VeeErrorMessage name=\"email\" /&gt; &lt;button type=\"submit\"&gt;submit&lt;/button&gt; &lt;/VeeForm&gt;&lt;/template&gt;&lt;script setup&gt;const veeForm = ref(null);onMounted(() =&gt; { veeForm.value.setFieldValue('email', 'test@myweb.com');});&lt;/script&gt; 5. 調整驗證觸發行為 validateOnBlur：離開焦點時觸發，預設 true validateOnChange：欄位在 change 事件觸發，預設 true validateOnInput：輸入內容時觸發，預設 false validateOnModelUpdate：update:modelValue&nbsp;(v-model) 事件觸發，預設 true 全域調整： // vee-validate.client.jsimport { configure } from 'vee-validate';configure({ validateOnInput: true});export default defineNuxtPlugin(_nuxtApp =&gt; {}); 局部調整： &lt;Field name=\"email\" :validateOnBlur=\"false\" :validateOnChange=\"false\" :validateOnInput=\"false\" /&gt; 6. 清除表單利用 &lt;VeeForm /&gt; 的 resetForm 方法來清除表單 &lt;VeeForm @submit=\"submit\" v-slot=\"{ resetForm }\"&gt; ... &lt;button type=\"buttom\" @click=\"resetForm\"&gt;clear&lt;/button&gt;&lt;/VeeForm&gt; 7. Checkbox ／Radio&lt;VeeField v-slot=\"{ field }\" name=\"gender\" type=\"radio\" value=\"male\"&gt; &lt;label&gt; &lt;input type=\"radio\" name=\"gender\" v-bind=\"field\" value=\"male\" /&gt; male &lt;/label&gt;&lt;/VeeField&gt;&lt;VeeField v-slot=\"{ field }\" name=\"gender\" type=\"radio\" value=\"female\"&gt; &lt;label&gt; &lt;input type=\"radio\" name=\"gender\" v-bind=\"field\" value=\"female\" /&gt; female &lt;/label&gt;&lt;/VeeField&gt; 參考資源： https://vee-validate.logaretm.com/v4/","link":"/2023/07/24/nuxt3/nuxt-v3-vee-validate/"},{"title":"Nuxt.js vs Vue.js，淺談 SPA 與 SSR","text":"本篇文章同步發表於 2023 iThome 鐵人賽：Nuxt.js 3.x 筆記－打造 SSR 專案 提到 Nuxt.js，必須先從 Vue.js 說起，Vue.js 為專注在視圖層（View）的 Javascript 框架，為 SPA（Single Page Application）單頁應用程式，搜尋引擎爬蟲未能抓取到渲染後的 HTML 內容，因此 SEO（Search Engine Optimization）表現趨近於零。 而 Nuxt.js 是基於 Vue.js 的框架，為通用渲染模式（Universal Rendering），結合了 SSR（Server Side Render）及 CSR（Client Side Render），搜尋引擎爬蟲可以取得 HTML 內容，大幅提升 SEO 表現。 SPA / CSR vs MPA / SSR SPA（Single Page Application）單頁式應用使用 CSR（Client Side Render）用戶端渲染模式。整個網站應用只有單一 HTML 頁面，一但頁面被載入進來後，就不會再進行該頁面請求（Form Request），而是透過 AJAX&nbsp;從後端請求資料，並透過 Javascript 動態更新與渲染網頁內容。 採 CSR（Client Side Render）用戶端渲染模式。 優點：使用者體驗佳，因每次切換頁面時只有部分畫面更新，不會重新載入整個頁面 缺點：搜尋引擎爬蟲未能抓取到渲染後的 HTML 內容，因此 SEO（Search Engine Optimization）表現趨近於零 MPA（Multi Page Application）多頁式應用使用 SSR（Server Side Render）伺服器端渲染模式。在頁面載入前即渲染，每次跳轉頁面，瀏覽器都會重新向伺服器發送頁面請求，由伺服器回傳頁面的 HTML 內容。 優點：在伺服器上生成完整的 HTML 頁面，首次內容繪製（FCP，First Contentful Paint）速度快，且搜尋引擎爬蟲可以取得完整 HTML 內容，SEO 表現佳 缺點：使用者體驗較差，因每次切換頁面都要重新刷新頁面，且對伺服器負擔較大 Universal Rendering通用渲染，Nuxt.js 使用的渲染模式，同時支援 SSR 與 CSR 技術，初次進到頁面時採用 SSR 模式，在伺服器中產生完整 HTML 內容，回傳給瀏覽器端。後續動態切換頁面時，則採用 CSR 模式，結合了 SSR 與 SPA 的優點，除了使用者體驗佳，同時保有良好的 SEO 表現。 圖片參考：Nuxt 官網 流程： 伺服器端產生靜態 HTML，回傳給瀏覽器端 瀏覽器端載入 JavaScript 並執行 Hydration 混合渲染完成，使用者可以開始與網頁互動 Hydration 混合渲染： 在用戶端使用 JavaScript，讓伺服器端產生的靜態 HTML 加上 Event Handlers（事件處理器），讓使用者能與網頁進行互動的技術，Nuxt.js 跟 React 框架 Next.js 即使用此技術 Nuxt3 簡介 使用 Vue3 開發 完整 SSR 支援，也可以選用 CSR 模式 自動定義路由（使用 Vue-Router），不需手動配置 支援 webpack 5 與 Vite 開發（預設搭配 Vite） 完整支援 TypeScript 定義在 composables、components、plugins 的檔案，Nuxt 會自動引入（Auto-imports） 內建支援 SSR 的 AJAX 請求方法（$fetch、useFetch、useAsyncData） Nuxt or VueVue.js SPA 架構使用者體驗佳，如果專案為後台系統，或是不需要 SEO，選擇 Vue.js 開發相對單純。 Nuxt.js 是基於 Vue.js 開發的框架，適合已經有 Vue.js 或其他 JavaScript 框架使用經驗的開發者，如果專案需要良好的 SEO 表現，推坑 Nuxt.js，安裝方式簡單、自動化繁瑣的步驟，提供很不錯的開發體驗。 參考資源： https://nuxt.com/docs/guide/concepts/rendering#universal-renderinghttps://shubo.io/rendering-patterns/https://ithelp.ithome.com.tw/articles/10262891","link":"/2023/08/22/nuxt3/nuxt-vs-vue/"},{"title":"TypeScript 學習筆記：基本介紹與型別","text":"眾所皆知 JavaScript 是弱型別（Weak Typing）的語言，因此常會發生賦值錯誤導致編譯出錯，TypeScript 可視為進階版 JavaScript，提供靜態型別定義和檢查，目標是讓開發者在編寫 JavaScript 時擁有更好的開發體驗和更高的程式碼可讀性，提升專案穩定度。 基本說明 TypeScript 是基於 JavaScript 的超集合（SuperSet），提供型別系統（Type System），能夠在開發時宣告型別 必須編譯成 JavaScript 檔案，瀏覽器、後端框架、Node.js 環境…才能閱讀 類型的定義可以減少 bug，能在編譯前預先檢查，避免許多運算錯誤 TypeScript 只會進行靜態檢查，編譯時即使報錯，還是會產生編譯結果，仍然可以使用編譯後的 JavaScript 檔 環境建置與相關指令 安裝 TypeScript：npm install -g typescript 進入專案資料夾，輸入 tsc —-init 建立 tsconfig.json 設定 rootDir ＆outDir 路徑 開啟 inlineSourceMap: true tsc：將指令路徑 rootDir 內所有 .ts 檔編譯為 .js 檔存放於 outDir tsc fileName.ts ：將指定路徑 rootDir 內 fileName.ts 檔編譯為 fileName.js tsc —-watch：進行動態監聽 原始資料型別（Primitive Data Types） String 字串型別：const str: string = 'hello' Number 數字型別，包括整數和浮點數：const num: number = 1000 Boolean 布林型別：const boo: boolean = true Null：const n: null = null Undefined：const un: undefined = undefined Symbol：ES6 新型別，是一個唯一且不可變的值，使用 Symbol() 函數來建立一個 Symbol 值，可以參考 這篇文章 物件型別（Object Types） Object 物件型別 const obj: Object = { name: 'Claire', age: 18 }const obj2: { name: string, age: number } = { name: 'Claire', age: 18 } Array 陣列型別 使用型別搭配中括號 [] 表示法 const arr: number[] = [ 111, 222 ];const arr2: string[][] = [ [ 'a' ], [ 'b' ] ]; 或是陣列泛型（Array Generic）Array&lt;type&gt; 表示法 const arr3: Array&lt;boolean&gt; = [ true, false ]; Function 函式型別 function hello(a: string, b: string) { return a + b;}function hello2(a: number, b: number): number { return a + b;}// hover提示：function hello3(a: number, b: boolean, c: string): numberfunction hello3(a: number, b: boolean, c: string) { return 10000000;}// hover提示：function hello4(name: string, age?: number): number | undefinedfunction hello4(name: string, age?: number) { return age;} 『選填』的參數如果沒加上判斷會拋錯，因參數有可能為 undefined ，見以下範例 function hello4(name: string, age?: number) { return age + 1; // 'age' is possibly 'undefined'.} 須加上判斷條件，改寫如下 function hello4(name: string, age?: number) { if (age === undefined) { return 1; } return age + 1;} TypeScript 特有型別 Any 任意型別，等同於不定義型別，可以賦值給任何型別 let anyVar: any = true;anyVar = 18;anyVar = 'hello';let str: string;str = anyVar; Unknown：類似 any 型別，但 any 可以賦值給任何型別，unknown 只能賦值給 any 和自己 let unknownVar: unknown = true;unknownVar = 18;unknownVar = 'hello';let str: string;str = unknownVar; // Type 'unknown' is not assignable to type 'string'let anyVar: any;anyVar = unknownVar; Never：函式發生無窮迴圈，或是出現例外狀況拋錯誤 function throwError(): never { throw new Error('error');} Void 空值：通常用於表示函式沒有回傳值 function hello(a: string, b: string): void { alert(a + b);}// hover提示：function hello2(a: number, b: number): voidfunction hello2(a: number, b: number) { console.log(a + b);} 瀏覽器 DOM 與 BOM 型別 HTMLElement：所有 HTML 元素的基本型別，包含 &lt;div&gt;、&lt;p&gt;、&lt;span&gt; … HTMLInputElement：代表 &lt;input&gt; 元素 HTMLTextAreaElement：代表 &lt;textarea&gt; 元素 HTMLAnchorElement：代表 &lt;a&gt; 元素 HTMLFormElement：代表 &lt;form&gt; 元素 HTMLSelectElement：代表 &lt;select&gt; 元素 HTMLFormElement：代表 &lt;form&gt; 元素 HTMLTableElement：代表 &lt;table&gt; 元素 MouseEvent：代表滑鼠事件 KeyboardEvent：代表鍵盤事件 inputEvent：代表輸入事件 FocusEvent：代表焦點事件 參考資源： https://willh.gitbook.io/typescript-tutorial/basics/primitive-data-types https://www.youtube.com/watch?v=GinkGJZBHIY","link":"/2023/03/21/typescript/ts-about-types/"},{"title":"TypeScript 學習筆記：進階應用","text":"Type Inference 型別推論如果沒有明確的指定型別，TypeScript 會依照『型別推論』的規則推斷出型別 // 自動判定 string 型別let num = 'hello';num = 777;// Type 'number' is not assignable to type 'string'. 如果定義的時候沒有賦值，會被推斷為 any 型別 // 自動判定 any 型別let something;something = 777;something = '777'; Union Types 聯合型別使用 | 符號來表示多種可能的型別 let price: number | string;price = 1000;price = '1000';price = true; // Type 'boolean' is not assignable to type 'string | number' Type 型別別名type A = number | string;type B = (param: string) =&gt; string;let a1: A;a1 = 999;a1 = '999';a1 = false; // Type 'boolean' is not assignable to type 'A' Interface 介面定義物件或陣列的型別，跟上面 type 功能類似，差別在 interface 可以『擴充』 屬性介紹 可選屬性：範例 isMale?: boolean 任意屬性：範例 [ propName: string ]: any 唯讀屬性：使用 readonly 定義唯讀屬性，若初始化後再次賦值會報錯 interface User { readonly id: number; name: string; isMale?: boolean; [ propName: string ]: any;}// 擴充interface User { age: number}const obj: User = { id: 1, name: 'Claire', age: 18, isMale: false}obj.id = 2; // Cannot assign to 'id' because it is a read-only property 也可以用來表示陣列 interface Users { [ index: number ]: string}const users: Users = [ 'Daniel', 'Claire', 'Andy', 'Avery' ]; 或是定義函式 interface SearchUser { (arr: string[], name: string): boolean}const searchName: SearchUser = function(arr: string[], name: string) { return arr.includes(name);}console.log(searchName([ 'Daniel', 'Claire' ], 'Daniel')); // output: true Tuple 元組型別定義陣列元素數量、型別 let tuple: [ number, string, boolean ] = [ 1, 'a', true ];let tuple2: [ string, string ][] = [ [ 'a', 'b' ] ]; Enum 列舉型別用於定義一組命名常數的方法 enum Alert { success, warning, danger } 列舉項目預設會從 0 開始遞增賦值，列舉 key 跟值會反向對映 console.log(Alert.success); // output: 0console.log(Alert[1]); // output: warning 也可以手動賦值 enum Alert { success = 1, warning = 0, danger = -1}console.log(Alert.success); // output: 1console.log(Alert[1]); // output: successconsole.log(Alert);// output:// {// 1: 'success',// 0: 'warning',// -1: 'danger',// success: 1,// warning: 0,// danger: -1// } 或使用非數字，必須使用斷言來略過型別檢查 enum Alert { success = 'green' as any, warning = 'yellow' as any, danger = 'red' as any}console.log(Alert.green); // output: success Generics 泛型在函式或是 class 後面加上 &lt;T&gt; 或是 &lt;Type&gt; 表示動態型別（名稱自訂），於調用時將型別傳入，讓型別更加靈活 function print&lt;T&gt;(data: T) { console.log(data);}print&lt;number&gt;(999); // output: 999print&lt;string&gt;('1000'); // output: '1000'class Print&lt;T&gt; { data: T constructor(d: T) { this.data = d; }}const p = new Print&lt;number&gt;(1000);const p2 = new Print&lt;boolean&gt;(true);console.log('p', p); // output: Print { data: 1000 }console.log('p2', p2); // output: Print { data: true } Type Assertion 型別斷言手動指定型別，並不會影響型別轉換 範例一： const user = { name: 'Claire', age: 20, gender: 'female'}function userInfo(param: string) { return user[param]; // Element implicitly has an 'any' type because expression of type 'string' can't be used to index type '{ name: string; age: number; gender: string; }'.} 因 param 有可能不存在 user key 值，因此拋錯，可以加上斷言如下 function userInfo(param: string) { return user[param as keyof typeof user];} 範例二： function toBoolean(something: string | number): boolean { return something; // Type 'string | number' is not assignable to type 'boolean'.} 直接調整成 as boolean 依舊會拋錯 function toBoolean(something: string | number): boolean { return something as boolean; // Conversion of type 'string | number' to type 'boolean' may be a mistake because neither type sufficiently overlaps with the other. If this was intentional, convert the expression to 'unknown' first.} 因為 something 預先被定義為 string | number，跟 boolean 沒有關聯，必須先斷言成 unknown function toBoolean(something: string | number): boolean { return something as unknown as boolean;}console.log(toBoolean(123)); // output: 123 前面提到斷言不會進行型別轉型，因此結果並不會變成 boolean ES6 Class 與建構函式如果對 ES6 Class 尚不熟悉，可以參考 這篇文章 TypeScript Class 修飾符 public：公有的，可以在任何地方使用，預設屬性跟方法皆為 public private：私有的，不能在類別的外部調用（ex: new 實體或是 extends 繼承） protected：受保護的，extends 繼承可以調用，但 new 實體不能調用 public &amp; protected 只存在於 typescript，通常使用於開法階段（避免共同開發時異動到程式碼），編譯成 javascript 後沒什麼作用，因 js 不存在這兩個類型 class Live { public roomName: string private id: string protected name: string constructor(roomName1: string, id1: string, name1: string) { console.log('建立直播中...'); this.roomName = roomName1; this.id = id1; this.name = name1; }}const live = new Live('no.1', '00001', 'Daniel');console.log(live); // output: Live { roomName: 'no.1', id: '00001', name: 'Daniel' } 如果需要使用私有變數，可以改用 javascript 的變數前綴 # class Live2 { // js 私有變數 #name constructor(name: string) { this.#name = name; }}const live2 = new Live2('Daniel');console.log(live2); // output: Live2 {} Class &amp; Interface 因類別可以繼承其他類別，有時類別間有共同的特性，可以提取出來作為介面共用（對類別的一部分行為進行抽象），並用 implements 來實現 interface Eat { eat(): string;}class Animal { name: string; constructor(name: string) { this.name = name; }}class Person extends Animal implements Eat { constructor(name: string) { super(name); this.name = name; } eat() { return `${this.name} is eating food`; }}const daniel = new Person('Daniel');console.log(daniel.eat()); // output: Daniel is eating food 可以一次實現多個介面 class Person implements Eat, Sleep { ...} 也可以介面繼承介面 interface Animal { eat(): string;}interface Dog extends Animal { bark(): string;}const Coco: Dog = { eat() { return 'eating'; } bark() { return 'barking'; }} 參考資源： https://medium.com/enjoy-life-enjoy-coding/javascript-es6-中最容易誤會的語法糖-class-基本用法-23e4a4a5e8ed https://www.youtube.com/watch?v=GinkGJZBHIY","link":"/2023/03/22/typescript/ts-advance/"},{"title":"TypeScript 學習筆記：Interface V.S. Type","text":"Interface 和 Type 是用來定義型別的兩種語法，那麼兩者又有什麼區別呢？ Interface 介面 主要用於定義 「物件型別」 不能直接宣告基本型別、元組、列舉與聯合型別 可以重複宣告，支援擴展與合併 擴展（Extends）假設我們定義了一個 Person 介面 interface Person { name: string; age: number;} 接著定義一個新介面，並透過 extends 擴充 Person interface User extends Person { id: number; createdAt: string;} 使用 User 介面的資料，就必須包含 name、age、id、createdAt 參數 const user: User = { name: 'Daniel', age: 18, id: 123, createdAt: '2024-01-22'} 合併（Merging）介面可以被重複宣告，以下範例最後結果會是兩者合併 interface Vehicle { id: number; brand: string;}interface Vehicle { color: string; isElectric: boolean;}const car: Vehicle { id: 123, brand: 'audi', color: 'white'; isElectric: false} Type Aliases 型別別名 用來賦予型別一個新的名稱 可以直接宣告基本型別、元組、列舉、聯合型別、物件以及複雜型別 不可以重複宣告，不支援擴展，但可以透過 &amp; 交集來組合型別 宣告型別別名 基本型別 type Num = number;const num: Num = 123; 元組 type Arr = [ string, number ];const arr: Arr = [ 'Daniel', 18 ]; 聯合型別 type UserId = number | string;const userId: UserId = 123;userId = '123'; 列舉 enum ColorChart { Red = 'red', Blue = 'blue', Green = 'green'}type Color = ColorChart;const color: Color = ColorChart.Red; 物件 type Obj = { id: number, name: string}const obj: Obj = { id: 111, name: 'Daniel'} Mapped Types type Person = { name: string, age: number, address: string};// 將 Person 型別中各屬性調整為可選type PartialPerson = { [K in keyof Person]?: Person[K];}; 交集（Intersection）與聯集（Union）透過交集（&amp;）或聯集（|）來組合型別 type DataA = { a: number};type DataB = { b: string};type Combined = DataA &amp; DataB; // Intersectiontype Either = DataA | DataB; // Union 不能重複宣告重複宣告會拋錯 type Vehicle = { id: number, brand: string}type Vehicle = { // Duplicate identifier 'Vehicle' color: string, isElectric: boolean} Interface &amp; Type 使用時機 Type 可以直接定義原始型別、元組、列舉、聯合型別、函式、物件等 Interface 只能定義物件 物件並且可以被擴充，使用 Interface 可讀性較高，extends 語意上也較直觀 開發第三方套件，型別定義使用 Interface，使用者能彈性的擴充屬性 參考資源： https://hackmd.io/@hexschool/rJiN4vCuphttps://stackoverflow.com/questions/37233735/interfaces-vs-types-in-typescripthttps://blog.logrocket.com/types-vs-interfaces-typescript/","link":"/2024/01/23/typescript/ts-interface-vs-type/"},{"title":"TypeScript 學習筆記：tsconfig.json 編譯設定","text":"tsconfig.json 為 TypeScript 編譯器的設定檔，用來配置 TypeScript 編譯器的行為，簡單說明設定檔內容 環境安裝產生 tsconfig.json 檔案 tsc --init 設定說明compilerOptions物件，定義編譯器的行為 屬性 介紹 預設值 可帶入值 target 欲編譯的 JavaScript 版本 es2016 ES3、ES5、ES6/ES2015、ES2016、ES2017、ES2018、ES2019、ES2020、ES2021 或 ESNext lib 編譯器可以使用的標準庫 空值 ES5、ES6、ES2015、ES2016、ES2017、ES2018、ES2019、ES2020、ES2021、ESNext、DOM、DOM.Iterable、WebWorker、ScriptHost… jsx 支援使用 JSX 語法 preserve preserve、react、react-jsx module 生成的模組格式 commonjs monJS、AMD、SystemJS、UMD、ES6、ES2015 或 ESNext rootDir 編譯時的根目錄 空值 絕對路徑、相對路徑 outDir 編譯後檔案存放位置 空值 絕對路徑、相對路徑 baseUrl 模組解析的根目錄 . 絕對路徑、相對路徑 paths 定義模組的路徑別名 空物件 物件 allowJs 是否允許編譯 JavaScript 文件 false boolean checkJs 是否檢查 JavaScript 文件型別 false boolean declaration 是否生成相對應的裝飾（.d.ts）文件 false boolean sourceMap 是否生成相對應的 .map 文件 false boolean outFile 編譯生成的 JavaScript 代碼合併到一個文件中 空值 絕對路徑、相對路徑 removeComments 是否移除註解 false boolean noEmit 是否不生成編譯後的 JavaScript 文件 false boolean strict 是否啟用所有嚴格類型檢查模式，等於noImplicitAny、noImplicitThis、alwaysStrict、strictBindCallApply、strictNullChecks、strictFunctionTypes 和 strictPropertyInitialization的設定為true false boolean noImplicitAny 是否禁止 any 型別 false boolean noImplicitThis 是否禁止 this 關鍵字隱式型別為 any false boolean alwaysStrict 是否在輸出文件中包含 ‘use strict’ false boolean strictBindCallApply 是否在函數 bind、call、apply 的調用中檢查參數的類型符合函數的期望類型 false boolean strictNullChecks 是否開啟嚴格的空值檢查（null 和 undefined） false boolean strictFunctionTypes 函數類型參數的參數和返回值是否精確匹配 false boolean strictPropertyInitialization 類成員是否進行初始化 false boolean experimentalDecorators 是否使用實驗性裝飾器語法 false boolean emitDecoratorMetadata 如果有使用裝飾器，是否要生成裝飾器數據 false boolean jsxFactory 指定使用的 JSX 工廠函數（TS 4.1+） 空值 自訂 noLib 編譯後的代碼是否排除 TypeScript 標準庫的所有宣告文件 false boolean esModuleInterop 是否兼容 CommonJS module false boolean preserveSymlinks 是否保留符號連接 false boolean skipLibCheck 是否跳過標準庫檢查 false boolean noEmitOnError 編譯出錯是否停止編譯檔案 false boolean files指定欲編譯 TypeScript 檔案，陣列，沒有定義此屬性預設為根目錄下所有 .ts 及 .tsx 檔案，可以使用絕對路徑、相對路徑 { \"files\": [ \"./src/index.ts\" ]} include &amp; exclude陣列，include 指定欲編譯 TypeScript 檔案，exclude 指定不要被編譯 TypeScript 檔案 可以輸入編譯的檔案、資料夾或者通配符模式（wildcard character） { \"include\": [ \"./src/test\" ], \"exclude\": [ \"./src/test/about.ts\" ]} files、include、exclude 優先權：files &gt; include &gt; exclude files 優先度最高，files 指定的檔案不會被 exclude 排除 include 包含的檔案，可以透過 exclude 進行過濾 同時寫 files 跟 include，相符的檔案與資料夾都會被編譯 extends字串，使用其他 tsconfig.json 檔案作為基礎，並覆寫或是擴充設定，可以使用絕對路徑、相對路徑 { \"extends\": \"./base.json\"} 參考資源： https://ithelp.ithome.com.tw/articles/10216636","link":"/2023/03/25/typescript/ts-tsconfig-json/"},{"title":"TypeScript 學習筆記：常用 Utility Types","text":"TypeScript Utility Types 是一組內建的型別工具，用於操作和組合現有型別，以產生新的型別。這些工具可以讓開發者更容易地處理和操作 TypeScript 型別，提高程式碼的可讀性和可維護性。 以下介紹幾個常用的 Utility Types： Record&lt;Keys, Type&gt;interface CatInfo { age: number; breed: string;}type CatName = 'miffy' | 'boris' | 'mordred';const cats: Record&lt;CatName, CatInfo&gt; = { miffy: { age: 10, breed: 'Persian' }, boris: { age: 5, breed: 'Maine Coon' }, mordred: { age: 16, breed: 'British Shorthair' }} Pick&lt;Type, Keys&gt;參數選擇 interface Todo { title: string; description: string; isCompleted: boolean;}type TodoPreview = Pick&lt;Todo, 'title' | 'isCompleted'&gt;const todo: TodoPreview = { title: 'title', isCompleted: true} Omit&lt;Type, Keys&gt;參數排除 interface Todo { title: string; description: string; isCompleted: boolean; createdAt: number;}type TodoPreview = Omit&lt;Todo, 'description'&gt;const todo: TodoPreview = { title: 'title', isCompleted: true, createdAt: 20230301} 參考資源： https://www.typescriptlang.org/docs/handbook/utility-types.html https://www.youtube.com/watch?v=GinkGJZBHIY","link":"/2023/03/23/typescript/ts-utility-types/"},{"title":"Vue.js Props, $emit, Provide, Inject 父子元件資料傳遞","text":"版本：Vue 3.2.x Props &amp; $emit父子元件間溝通的重要管道，因每個元件的作用範圍皆應獨立，因此不應在子元件內直接修改父元件的資料，否則會難以除錯，造成維護上困難。 假設頁面層級如下 Root.vue |—— Child.vue Props父層傳遞到子層 透過 v-bind:父元件參數名稱=\"子元件參數名稱\"，將資料傳遞到子元件 // views/Root.vue&lt;template&gt; &lt;Child :message=\"messageToChild\" /&gt;&lt;/template&gt;&lt;script&gt;export default { name: 'Root', data() { return { messageToChild: '早安您好' } }}&lt;/script&gt; 子層接收父層資料 透過 props 接收由父層傳遞來的資料 type：指定型別，如果接受多個型別，可以使用陣列（EX：type: [ String, Number ]） required：是否必填，預設 false default：預設值，如果指定型別為物件或陣列，需使用函式定義（EX：default: () =&gt; {}） // components/Child.vue&lt;template&gt; &lt;input type=\"text\" :value=\"message\" /&gt;&lt;/template&gt;&lt;script&gt;export default { name: 'Child', props: { message: { type: String, required: true, default: '' } }}&lt;/script&gt; $emit前面提到，子元件無法直接修改父層的資料，會報錯誤如下 [Vue warn]: Avoid mutating a prop directly since the value will be overwritten whenever the parent component re-renders. Instead, use a data or computed property based on the prop’s value. 如果要修改父層傳回的值，需透過 $emit 觸發父層事件，簡單來說是通知父層元件更新值，不能直接由子元件更新。 子層觸發父層事件 this.$emit(/* event name */ 'update-message', /* value */ value) 第一個參數：父層事件名稱，命名必須用連字符（EX: ‘update-message’），不能使用駝峰（EX: ‘updateMessage’），否則會失效 第二個參數：傳遞給父層的值 // components/Child.vue&lt;template&gt; &lt;input type=\"text\" :value=\"message\" @input=\"updateMessage($event.target.value)\" /&gt;&lt;/template&gt;&lt;script&gt;export default { name: 'Child', props: { message: { type: String, required: true, default: '' } }, methods: { updateMessage(value) { this.$emit('update-message', value); } }}&lt;/script&gt; 父層事件觸發資料更新 透過 v-on:$emit事件名稱=\"父層函式\" ，藉由子元件觸發事件，來接受回傳值 // views/Root.vue&lt;template&gt; &lt;Child :message=\"messageToChild\" @update-message=\"updateMessage\" /&gt;&lt;/template&gt;&lt;script&gt;export default { name: 'Root', data() { return { messageToChild: '早安您好' } }, methods: { updateMessage(value) { this.messageToChild = value; } }}&lt;/script&gt; 以上例說明： 當子元件觸發 v-on:update-message 事件 進而觸發 updateMessage 函式 接收子元件回傳的 value 更新 messageToChild 內容 再透過 props 更新子元件接收值 藉由以上循環達成雙向綁定。 Vue 3.x：透過 v-model 指令簡化語法除了上述的寫法外，也可以透過 v-model 來縮寫 子元件：$emit 事件命名規則為 update:參數名稱 // components/Child.vue&lt;template&gt; &lt;input type=\"text\" :value=\"message\" @input=\"updateMessage($event.target.value)\" /&gt;&lt;/template&gt;&lt;script&gt;export default { name: 'Child', props: { message: { type: String, required: true, default: '' } }, methods: { updateMessage(value) { this.$emit('update:message', value); } }}&lt;/script&gt; 父元件：合併 :message 跟 @update:message，直接使用 v-model 語法糖 v-model:參數名稱 // views/Root.vue&lt;template&gt; &lt;Child v-model:message=\"updateMessage\" /&gt;&lt;/template&gt;&lt;script&gt;export default { name: 'Root', data() { return { messageToChild: '早安您好' } }}&lt;/script&gt; Vue 2.x：透過 .sync 修飾符簡化語法Vue 2.x 元件間雙向綁定不支援 v-model:參數名稱 這樣的寫法，是透過 .sync 修飾符 子元件：寫法同上 Vue 3.x，不贅述 父元件：使用 v-bind:參數名稱.sync // views/Root.vue&lt;template&gt; &lt;Child :message.sync=\"updateMessage\" /&gt;&lt;/template&gt;&lt;script&gt;export default { name: 'Root', data() { return { messageToChild: '早安您好' } }}&lt;/script&gt; Provide &amp; Inject假設頁面層級如下 Root.vue |—— Header.vue |—— DeepChild.vue 要從 傳遞資料到 ，我們必須要 props 傳遞兩層才能順利將資料傳入，當層級越來越多，要再往下傳遞就更困難了… &lt;Root&gt; -&gt; &lt;Header&gt; -&gt; &lt;DeepChild&gt; 這時候透過 provide 跟 inject，父元件作為所有子元件的依賴提供者（dependency provider），跨過中間組件，快速達成跨階層元件資料傳遞： &lt;Root&gt; -&gt; &lt;DeepChild&gt; Provide父元件透過 provide 定義要往下傳送的參數 // &lt;Root&gt;&lt;template&gt; ...&lt;/template&gt;&lt;script&gt;export default { name: 'Root', provide() { return { message: this.message } }, data() { return { message: '傳給元件的訊息' } }}&lt;/script&gt; App-level Provide全域傳遞參數 // main.jsimport { createApp } from 'vue';const app = createApp({});app.provide(/* key */ 'message', /* value */ '傳給元件的訊息'); Inject子元件透過 inject，可以注入來自所有上層傳遞的內容（以 為例，可以接收 、、 傳出的內容） // &lt;DeepChild&gt;&lt;template&gt; &lt;div&gt;{{ message }}&lt;/div&gt;&lt;/template&gt;&lt;script&gt;export default { name: 'DeepChild', inject: [ 'message' ]}&lt;/script&gt; 參考文章： https://book.vue.tw/CH2/2-2-communications.html https://vuejs.org/guide/components/provide-inject.html","link":"/2023/01/13/vue/vue-communications/"},{"title":"Vue.js Custom Directives 自訂指令","text":"版本：Vue 3.2.x 除了 Vue 內建的系列指令，像是 v-model, v-for, v-show 等，我們也可以使用 Vue directives 自訂指令，將 DOM 元素和元件進行動態綁定，並對其進行操作，提高程式碼的可複用性 結構 呼叫 v-自訂名稱 指令來綁定 DOM 元素 透過類似元件的生命週期鉤子（Lifecycle Hooks）來定義指令（EX：mounted, updated…），並觸發更新 範例註冊指令EX：指令名稱 v-focus &lt;input type=\"text\" v-model=\"text\" v-focus /&gt; 1. 全域註冊 import { createApp } from 'vue';import App from './App.vue';const app = createApp(App);app.directive('focus', { mounted(el) { el.focus(); }});app.mount('#app'); 2. 區域註冊 &lt;template&gt; &lt;input type=\"text\" v-model=\"text\" v-focus /&gt;&lt;/template&gt;&lt;script&gt;const focus = { mounted: (el) =&gt; el.focus()}export default { name: 'Home', directives: { focus }, data() { return { text: '' } }}&lt;/script&gt; 指令傳值 / 帶入參數 / 修飾符&lt;template&gt; &lt;input type=\"text\" v-model=\"text\" v-focus:[bindingArg].bar=\"bindingVal\" /&gt;&lt;/template&gt;&lt;script&gt;export default { name: 'Home', data() { return { text: '', bindingArg: 'foo', bindingVal: 'disabled' } }}&lt;/script&gt; 可以在 directive 函式 binding 取得內容（binding 物件屬性） ...app.directive('focus', { mounted(el, binding) { el.focus(); console.log(binding); }});... 結果如下 { arg: 'foo', // 傳給指令的參數 instance: Proxy{ ... }, // 使用指令的元件實體 dir: { mounted: ƒ, updated: ƒ } // 指令定義內容 modifiers: { bar: true }, // 修飾符 value: 'disabled', // 當前值 oldValue: undefined // 前一次的值} 實際應用&lt;template&gt; &lt;form @submit.prevent=\"submitForm()\" v-form=\"tel\"&gt; &lt;input type=\"tel\" v-model=\"tel\" placeholder=\"請輸入手機（10碼）\" /&gt; &lt;button type=\"submit\" id=\"submit\" disabled&gt;送出表單&lt;/button&gt; &lt;/form&gt;&lt;/template&gt;&lt;script&gt;export default { name: 'Home', data() { return { tel: '' } }}&lt;/script&gt; import { createApp } from 'vue';import App from './App.vue';const app = createApp(App);app.directive('form', { mounted(el) { el.querySelector('input').focus(); }, updated(el, binding) { if (binding.value.length === 10) { el.querySelector('#submit').disabled = false; } else { el.querySelector('#submit').disabled = true; } }});app.mount('#app'); 範例程式碼： See the Pen Vue.js Custom Directives 自訂指令 by Claire Chang (@claire-chang-the-bashful) on CodePen. 參考文章： https://vuejs.org/guide/reusability/custom-directives.html","link":"/2023/01/16/vue/vue-custom-directives/"},{"title":"Vue.js Recursive Component 遞迴元件實作巢狀選單","text":"版本：Vue 3.2.x Vue.js 的元件內除了可以包覆其他元件，也可以將「自己」作為「子元件」使用，稱為遞迴元件（Recursive Component），巢狀的資料渲染，像是多層導覽列或是組織圖，都可以使用遞迴元件實作。 說到遞迴元件，必須先了解遞迴函式（Recursive Function）。 遞迴函式（Recursive Function）簡單來說是在函式中呼叫「自己」的行為，遞回函式必須包含： 結束遞迴的基本情況（base case） 延續遞迴的遞迴情況（recursive case） 假設有一筆多層選單內容如下 const menuList = { id: 0, name: '首頁', sub: [ { id: 1, name: '關於我們', sub: [ { id: 11, name: '公司介紹', sub: [] } ] }, { id: 2, name: '產品介紹', sub: [ { id: 21, name: '保濕系列', sub: [] }, { id: 22, name: '抗老系列', sub: [] } ] }, { id: 3, name: '線上購物', sub: [] } ]} 當我們想從中找出一筆資料（EX：id: 22） 一般函式 如果是一般函式，選單有幾層就要寫幾次判斷式，程式碼冗長難以維護 function findItem(list, id) { if (list.id === id) { console.log(list.name); } else { list.sub.filter(item =&gt; { if (item.id === id) { console.log(item.name); } else { ... } }); }}findItem(menuList, 22); // '抗老系列' 遞迴函式 透過遞迴函式，程式碼簡潔許多 function findItem(list, id) { if (list.id === id) { // base case console.log(list.name); return; } list.sub.filter(item =&gt; this.findItem(item, id)); // recursive case}findItem(menuList, 22); // '抗老系列' 遞迴函式必須要寫終止條件，否則會有無窮迴圈（infinite loop）的情況發生，程式碼無法結束，導致 ‘max stack size exceeded’ 錯誤 遞迴元件（Recursive Component）使用前面的 menuList 作為範例，元件結構如下： -| components/---| TheMenu/-----| index.vue-----| MenuItem.vue 建立父元件 元件內包覆子元件，並透過 props 進行資料傳遞 // components/TheMenu/index.vue&lt;template&gt; &lt;ul&gt; &lt;MenuItem :menu=\"menuList\" /&gt; &lt;/ul&gt;&lt;/template&gt;&lt;script&gt;export default { name: 'Menu', components: { MenuItem: () =&gt; import('./components/TheMenu/MenuItem.vue') }, data() { return { menuList: { ... } // 同上面範例 }; }}&lt;/script&gt; 建立子元件 在子元件裡面呼叫本身，將 MenuItem 當作子元件使用，就可以實現遞迴元件，遞迴停止的條件是內容渲染完畢的時候 元件必須加上 name 屬性，才可以在元件內使用「自己」 // components/TheMenu/MenuItem.vue&lt;template&gt; &lt;li&gt; &lt;button type=\"button\" @click=\"toggleMenu\"&gt;{{ menu.name }}&lt;/button&gt; &lt;ul v-if=\"menu.sub.length\" v-show=\"isOpen\"&gt; &lt;MenuItem v-for=\"item in menu.sub\" :key=\"item.id\" :menu=\"item\" /&gt; &lt;/ul&gt; &lt;/li&gt;&lt;/template&gt;&lt;script&gt;export default { name: 'MenuItem', props: { menu: { type: Object, default: () =&gt; {} } }, data() { return { isOpen: false }; }, methods: { toggleMenu() { this.isOpen = !this.isOpen; } }}&lt;/script&gt; 元件應用 // views/Home.vue&lt;template&gt; &lt;TheMenu&gt;&lt;/TheMenu&gt;&lt;/template&gt;&lt;script&gt;export default { name: 'Home', components: { TheMenu: () =&gt; import('./components/TheMenu/index.vue') }}&lt;/script&gt; 結果呈現如下 See the Pen Vue.js Recursive Component 遞迴元件實作巢狀選單 by Claire Chang (@claire-chang-the-bashful) on CodePen. 參考文章： https://medium.com/@paulyang1234/使用-vue-recursive-component-實現樹狀菜單-f1128e566cba https://medium.com/js-dojo/7-vue-patterns-that-you-should-be-using-more-often-b13cde4d2ae6","link":"/2023/01/10/vue/vue-recursive-component/"},{"title":"什麼是 DNS，跟 Name Server 又有什麼關聯？","text":"網域名稱（Domain Name）要了解 DNS，首先必須知道域名的結構。域名用於識別和定位網路上特定資源的可讀性字串，通常由以下部分組成，以「點」分隔： 頂級網域（Top-level domain，TLD）：頂級網域是域名結構中的最高層次，用於表示域名的類別或類型。常見包括 com、org、net、edu、gov 等，還有國家和地區的頂級網域，例如 tw、jp、uk。以 www.example.com 為例，「com」就是頂級網域。 次級網域（Second-level domain）：次級網域位於頂級網域之下的一級域名，用於識別組織、公司、個人等。以 www.example.com 為例，「example」就是次級網域。 主機網域（Host domain）：主機網域位於次級網域之下的域名部分，用於指定特定網站、服務或主機的名稱。以 www.example.com 為例，「www」為主機網域。 完整網域名稱（Fully Qualified Domain Name，簡稱 FQDN）：包含所有層級的域名，從頂級網域到主機網域。www.example.com 就是完整網域名稱。 DNS 網域名稱系統（Domain Name System）DNS 用於將人類可讀的域名（ex：www.example.com）轉換為對應的 IP 位址（ex: 93.184.216.34），讓使用者只需要記得域名，而不需要背下由數字組成的 IP 位址，就好像我們在稱呼一個人的時候，通常會叫對方的名字（網域名稱），而不是身份證字號（IP），DNS 相當重要，少了它網際網路基本上就會癱瘓。 因網際網路只認得 IP 位址，當使用者輸入網域名稱，瀏覽器會先去離他最近的 DNS Server 透過網域名稱查詢相對應的伺服器 IP，並回傳 IP 位址給瀏覽器，瀏覽器再透過 IP 跟網路伺服器建立連線，並取得網頁內容。 利用終端機查詢域名 IP：ex: 輸入 ping www.example.com，得到 IP 位址 93.184.216.34 NS 名稱伺服器（Name Server）名稱伺服器是 DNS 中一個重要元素，主要功能： 域名解析：當使用者在瀏覽器中輸入一個域名，瀏覽器將向名稱伺服器發出查詢，名稱伺服器開始將域名轉換為與之相關聯的 IP 地址。這個過程被稱為域名解析。名稱伺服器存儲著該域名的 DNS 記錄（A 記錄、CNAME 記錄等）。 分散資料儲存：一個網域至少要有兩組名稱伺服器，DNS 系統使用分散的名稱伺服器架構。當一個名稱伺服器無法回覆查詢時，其他名稱伺服器可以接手處理。 域名管理：一旦變更名稱伺服器也會變更管理 DNS 的地方。舉例來說，假如我們在 GoDaddy 購買網域，並使用預設的名稱伺服器，那麼 DNS 區域檔案就在 GoDaddy 內，但是當網域變更為 Cloudflare 名稱伺服器，那麼 DNS 區域檔案就位在 Cloudflare。 常見 DNS 區域檔案類型： SOA 記錄（Start of Authority）：區域檔案中的第一個記錄，指定該區域的管理者和其他基本設定，包含主要名稱服務器（Primary Name Server）和負責人電子郵件地址（Responsible Person Email Address）等。 A 記錄（Address，IPv4 地址）：是用於名稱解析的重要記錄，將網域名稱對應到 IPv4 的 32 位元位址。 AAAA 記錄（IPv6 地址）：將網域名稱對應到 IPv6 的 32 位元位址。 CNAME 記錄（Canonical Name，別名）：用於將某個網域或子網域指向到某個 A 記錄上，這樣，當我們需要將一個域名指向另一個域名或主機，就不需要再為新的別名建立一個 A 記錄。 例如：要將 www.example.com 指向 example.com，可以在 www.example.com 的 CNAME 記錄中指定 example.com，當使用者輸入 www.example.com 時，DNS 將解析並回傳 example.com 的相應 A 記錄，從而將流量導向到正確的主機。 NS 記錄（Name Server）：指定該區域使用的名稱服務器（Name Server），定義了負責提供該區域 DNS 解析的名稱服務器的伺服器名稱。 SRV 記錄（Service Record，服務）：用於指定特定服務的伺服器位置和連接資訊，包含了服務的協議、服務名稱、域名、優先級、權重、埠和目標（伺服器）等。 MX 記錄（Mail Exchanger，郵件交換）：指定特定域名電子郵件導向至郵件伺服器，所有要送往伺服器的郵件都要經過 MX 轉送。需設定該伺服器郵件傳遞時的優先次序，值越低表示有越高的處理優先權。 TXT 記錄（文字）：記錄任意文字訊息，可用於驗證域名所有權、提供人類可讀的訊息等。 DNS&nbsp;如何運作呢？ 當使用者在網頁瀏覽器中輸入網域名稱 www.example.com，瀏覽器會先查看本地 DNS 暫存（DNS Cache），這是先前訪問過該網站保存的紀錄，如果有紀錄就直接進入該網站，若無則繼續以下步驟 傳輸到網際網路，DNS 遞迴解析伺服器（DNS Resolver）接收該網域名稱查詢請求 遞迴解析器查詢 根名稱伺服器（Root Name Server）的 IP 位址，並向根網域發出請求 根名稱伺服器回傳儲存其網域資訊的 頂級網域名稱伺服器（TLD Name Server）的 IP 位址給遞迴解析器。搜尋 www.example.com 時會指向 .com TLD 遞迴解析器向 .com TLD 發出請求 TLD 名稱伺服器回傳使用該網域的名稱伺服器 IP 位址給遞迴解析器 遞迴解析器向該 權威名稱伺服器（Authoritative Name Server）發出請求 名稱伺服回傳 www.example.com 的 IP 位址給遞迴解析器 遞迴解析器回傳正確的 IP 位址給瀏覽器 瀏覽器帶著 IP 去訪問網站 位於該 IP 的 Web 伺服器回傳網頁內容給瀏覽器 由上述可以得知，網頁載入涉及 4 個 DNS 伺服器： DNS 遞迴解析伺服器（DNS Resolver） 根名稱伺服器（Root Name Server） 頂級網域名稱伺服器（TLD Name Server） 權威名稱伺服器（Authoritative Name Server） 參考資源： https://www.cloudflare.com/zh-tw/learning/dns/what-is-dns/ https://tw.godaddy.com/help/what-is-dns-665 https://its-okay.medium.com/搞懂-ip-fqdn-dns-name-server-鼠年全馬鐵人挑戰-05-aa60f45496fb","link":"/2023/06/27/web/dns-and-name-server/"},{"title":"GitHub Pages 自訂域名與 HTTPS 設定（GoDaddy + Cloudflare）","text":"2022 年底開始在 GitHub 經營了個人部落格，使用免費域名一段時間後，覺得 SEO（搜尋引擎優化）的成效不如預期，因此決定購買自己的網域，來提升部落格的專業度和可信度。 以下介紹： Step 1、購買網域名稱：使用 GoDaddy Step 2、DNS 網域託管：使用 Cloudflare Step 3、Cloudflare DNS 設定 Step 4、GitHub 設定網域 Step 5、替網站加上 Https、設定 SSL 加密 想了解 DNS 運作的流程，可以參考 這篇文章 Step 1、購買網域名稱 至 GoDaddy 註冊會員，並選購域名。GoDaddy 會列出名稱相似的可選域名： 付款完成後，可至 whois 查詢，查詢網域是否購買成功，未被選購的網域，查詢後會顯示 No Found ，以下為網域已被使用的查詢結果 Domain Name: clairechang.tw Domain Status: clientRenewProhibited,clientUpdateProhibited,clientDeleteProhibited,clientTransferProhibited Registrant: (Redacted for privacy) Administrative Contact: (Redacted for privacy) Technical Contact: (Redacted for privacy) Record expires on 2025-06-25 12:03:28 (UTC+8) Record created on 2023-06-25 12:03:28 (UTC+8) Domain servers in listed order: carlane.ns.cloudflare.com kellen.ns.cloudflare.com Registration Service Provider: GoDaddyRegistration Service URL: http://www.GoDaddy.com/Provided by Registry Services, LLC. Registry Gateway ServicesInformation Updated: 2023-06-28 05:06:23 需注意：由於我購買的頂級域名是 tw，由台灣網路資訊中心（TWNIC）負責管理和監督，因此透過 whois 查詢後，註冊人資料有被隱藏及保護（Registrant、Administrative Contact、Technical Contact），如果購買的域名，隱私資料未隱藏，建議購買「全方位網域保護」，否則註冊資料將會被完全公開 Step 2、DNS 網域託管將域名的 DNS 管理權限交給第三方的服務提供商 Cloudflare。 其實 GoDaddy 也有提供 DNS 服務，那為什麼要使用 Cloudflare 呢？因為 Cloudflare 除了 DNS 代管，還提供 WAF（網絡防火牆，Web Application Firewall）、CDN（內容傳遞網絡，Content Delivery Network）服務、DDoS 攻擊防護等，提升網路安全與效能優化。 至 Cloudflare 註冊帳號，並新增網站，輸入剛才在 GoDaddy 購買的網域 選擇方案：選擇免費即可，若之後有需求可再升級 接著看到 DNS 紀錄，這裡先跳過，Step 3 會進行設定 變更名稱伺服器：此步驟為重點，首先會看到指示需到網域註冊商（也就是 GoDaddy）移除他的名稱伺服器，並調整為 Cloudflare 的名稱伺服器 回到 GoDaddy 進行調整，選擇「變更名稱伺服器」，並調整為 Cloudflare 的伺服器 回到 Cloudflare 確認是否託管成功，需要一段時間，成功後會看到以下訊息 Step 3、Cloudflare DNS 設定 點開 DNS 設定，可以看到從 GoDaddy 抓回來的預設值，我們要將網域指向 GitHub Pages，先透過 GitHub 文件 找到以下四組 IP 185.199.108.153185.199.109.153185.199.110.153185.199.111.153 接著到 Cloudflare DNS 進行設定，先刪除預設 Type 為 A 的設定，並加入這四組 GitHub IP 到 A 紀錄 Step 4、GitHub 設定網域 到 GitHub 專案儲存庫，點擊 Settings → Pages → Custom domain，將網域貼上 設定成功後，回到專案首頁，可以看到自動新增了一支 CNAME 檔案，內容為剛才輸入的網域名稱 Step 5、替網站加上 Https、設定 SSL 加密 回到 Cloudflare，增加一組規則，使用 301 轉址將網域 HTTP url 自動轉址到 HTTPS，確保整個網站的訪問都是安全的 Cloudflare 預設的 SSL/TLS 為「彈性模式」，改為「完整模式」，這樣流量在瀏覽器跟 Cloudflare Proxy 間，以及 Cloudflare Proxy 與網站伺服器間，都是使用 SSL/TLS 加密，提升網頁安全 最後，點開網域若能順利看到畫面，就大功告成囉！ 參考資源： https://medium.com/pm的生產力工具箱/如何替-github-pages-設定個人網域與-cloudflare-ssl-設定-1e61b9ff0909 https://www.renokai.tw/2022/09/deploy-website/ https://israynotarray.com/other/20221206/2011045213/ https://gist.github.com/cvan/8630f847f579f90e0c014dc5199c337b","link":"/2023/06/28/web/github-pages-with-custom-domain/"},{"title":"WebRTC 學習筆記 (3) 錄製／下載影音串流","text":"本篇雖未涉及 WebRTC API 的應用，但 WebRTC 實作上常會搭配影音錄製與下載功能，因此將此篇文章歸類為系列文之一 錄製影音串流MediaStream Recording API MediaRecorder(stream) 可用於在瀏覽器中捕捉媒體串流並將其錄製為影音檔，通常會搭配 MediaDevices API getUserMedia() Promise 函式取得媒體串流 const createStream = async () =&gt; { const constraints = { audio: true, video: true }; // 取得裝置的影音串流 const stream = await navigator.mediaDevices.getUserMedia(constraints); return stream;};const startRecord = async () =&gt; { const stream = await createStream(); const options = { audioBitsPerSecond: 128000, videoBitsPerSecond: 2500000, mimeType: 'video/webm' }; // 建立 MediaRecorder 物件 const recorder = new MediaRecorder(stream, options); // 開始錄製 recorder.start();};startRecord(); 呼叫 MediaRecorder.start() 時，如果沒有傳入參數，會在停止錄製時才回傳一個 Blob 檔，如果希望能拆分 chuck 檔案，可以在 start(timeslice) 代入時間參數： // 每秒回傳一次錄製的串流MediaRecorder.start(1000); MediaRecorder API 相關方法和事件： MediaRecorder.start() 開始錄製媒體 MediaRecorder.stop() 停止錄製媒體 MediaRecorder.pause() 暫停錄製媒體 MediaRecorder.resume() 重新開始錄製媒體 MediaRecorder.ondataavailable 錄製期間產生新的媒體資料（Blob 檔）時觸發 MediaRecorder.onstop 媒體錄製完成並停止時觸發 下載影音串流搭配 ondataavailable 以及 onstop 進行監聽 前面提到的 MediaRecorder.start(timeslice) 方法傳入的時間參數，會影響 ondataavailable 觸發時機，假設 timeslice = 1000，每秒鐘會觸發一次 ondataavailable，並回傳這段時間（每秒）錄製的內容，若沒有傳入參數，會在停止錄製時才觸發，並回傳期間錄製的所有內容 步驟拆解： 透過 ondataavailable 取得錄製的 Blob chuck，並儲存變數內 透過 onstop 監聽錄製停止 執行檔案下載 const recordedChunks = [];recorder.start(1000);setTimeout(() =&gt; { recorder.stop();}, 5000);// 1. 取得錄製的 Blob chuck，並儲存變數內recorder.ondataavailable = (event) =&gt; { if (event.data.size &gt; 0) { recordedChunks.push(event.data); }};// 2. 監聽錄製停止recorder.onstop = () =&gt; { download();};// 3. 執行檔案下載const download = () =&gt; { const blob = new Blob(recordedChunks, { type: 'video/webm' }); const url = URL.createObjectURL(blob); const a = document.createElement('a'); document.body.appendChild(a); a.style = 'display: none'; a.href = url; a.download = 'test.webm'; a.click(); window.URL.revokeObjectURL(url);}; URL.createObjectURL() 用來將 File 或是 Blob 物件轉成一個 url，利用這個 url 來處理檔案下載，下載完畢後再使用 URL.revokeObjectURL() 釋放 url 錄製與下載完整範例 See the Pen Download and Record Videos by Claire Chang (@claire-chang-the-bashful) on CodePen. 參考資源： https://developer.mozilla.org/en-US/docs/Web/API/MediaStream_Recording_API https://medium.com/@kf99916/html5-神奇的-object-url-不用後端-前端便能產生獲取指定物件的網址-6df283d58505","link":"/2023/05/03/webrtc/media-stream-record-and-download/"},{"title":"WebRTC 學習筆記 (4) 實作多方視訊聊天室","text":"本篇是視訊聊天室的進階版本，必須先掌握 一對一視訊聊天室 介紹的相關知識，才能更快理解本篇的實作內容～ 視訊情境多個裝置 A、B、C …… 想要進行多方視訊聊天，可以隨時進入聊天室，不需要特定的順序 流程解析多方視訊可以透過 RTCPeerConnection() 建立多個連線來達成。跟一對一的連線類似，多方視訊中的每個 P2P 連線 發送端（Offer）與 接收端（Answer）都需要分別建立一個 RTCPeerConnection() 物件，每個物件分別管理一個連線，並透過 Signaling Server 交換 ICE 和 SDP 以建立連線。 連線建立後，每個裝置可以將自己的影像和聲音傳送到其他裝置的 RTCPeerConnection() 中，以達成多方視訊的效果。此外，也可以透過使用媒體伺服器（如 SFU 或 MCU）來進一步優化多方視訊的效能和品質。 在一對一視訊情境，有明確的發送端與接收端，以 A、B 為例： 裝置 A 發送 Offer SDP，並設定為本地 SDP（setLocalDescription） 裝置 B 收到 Offer SDP，並設定為遠端 SDP（setRemoteDescription） 裝置 B 發送 Answer SDP，並設定為本地 SDP（setLocalDescription） 裝置 A 收到 Answer SDP，並設定為遠端 SDP（setRemoteDescription） 那麽在多方視訊情況，該怎麼定義發送端與接收端呢？ 每個新加入聊天室的裝置，向已加入聊天室的所有裝置發送 Offer SDP，而其他裝置收到 Offer SDP 後，再向該裝置發送 Answer SDP，完成媒體協商並建立 P2P 連接。 以 A、B、C 為例： 裝置 A 加入聊天室 裝置 B 加入聊天室，向 A 發送 Offer SDP 裝置 A 收到 B 的 Offer SDP，向 B 發送 Answer SDP 裝置 B 收到 A 的 Answer SDP 裝置 C 加入聊天室，向 A、B 發送 Offer SDP 裝置 A、B 收到 C 的 Offer SDP，向 C 發送 Answer SDP 裝置 C 收到 A、B 的 Answer SDP 試著思考看看：當有三台裝置進行視訊連線，總共會產生幾個 RTCPeerConnection() 物件呢？ 視訊實作範例頁面：https://webrtc-socket.herokuapp.com/chat 分為 Server（Signaling Server）以及 Client（視訊聊天室）進行 檔案結構如下： server.jschat.htmlchat.js 重點說明：由於每個 P2P 連線的發送端與接收端都需要各別建立 RTCPeerConnection()，因此會使用 Socket.IO 為每個連線產生的唯一識別碼 socket.id 作為身份識別 Server（server.js）套件安裝（NPM） Node.js 框架 Express Websocket 套件 Socket.io 套件引入／啟動伺服器const express = require('express');const app = express();const http = require('http');const socket = require('socket.io');const server = http.createServer(app).listen('3000'); 連接 Client 頁面（轉換為絕對路徑 __dirname）// html 路徑轉換app.get('/chat', function(req, res) { res.sendfile(`${__dirname}/chat.html`);});// js 路徑轉換app.get(/(.*)\\.(jpg|gif|png|ico|css|js|txt)/i, function(req, res) { res.sendfile(`${__dirname}/${req.params[0]}.${req.params[1]}`);}); 加入 Socket.ioSocket.io API 說明：io.in(room).emit('joined')：向所有裝置發送訊息（包含自己）socket.to(room).emit('joined')：向所有裝置發送訊息（不包含自己）socket.to(id).emit('joined')：向特定裝置發送訊息 const io = socket(server);io.on('connection', (socket) =&gt; { console.log('connection'); // 裝置加入聊天室 socket.on('join', (room) =&gt; { console.log('join'); socket.join(room); // 取得加入聊天室裝置的 socket.id const members = Array.from(socket.adapter.rooms.get(room)); // 向所有裝置告知有新裝置加入（包含自己） io.in(room).emit('joined', socket.id, members); }); // 轉傳 Offer socket.on('offer', (room, desc, remoteId, localId) =&gt; { socket.to(localId).emit('offer', desc, remoteId); }); // 轉傳 Answer socket.on('answer', (room, desc, remoteId, localId) =&gt; { socket.to(localId).emit('answer', desc, remoteId); }); // 交換 ice candidate socket.on('ice_candidate', (room, data, remoteId, localId) =&gt; { socket.to(localId).emit('ice_candidate', data, remoteId); }); // 裝置離開聊天室 socket.on('disconnect_socket', () =&gt; { console.log('disconnect'); socket.disconnect(); });}); Client（視訊聊天室）套件安裝（CDN） WebRTC Adapter（解決相容性問題） Socket.io-client HTML（chat.html） 加入 Video Dom #localVideo 接收本地媒體串流 #remoteVideos 接收多個遠端媒體串流 CDN WebRTC Adapter 以及 Socket.io-client 引入 chat.js &lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;meta charset=\"utf-8\"&gt; &lt;link rel=\"icon\" type=\"image/x-icon\" href=\"./favicon.ico\"&gt; &lt;meta name=\"viewport\" content=\"width=device-width, user-scalable=yes, initial-scale=1, maximum-scale=1\"&gt; &lt;title&gt;chat&lt;/title&gt; &lt;style lang=\"scss\"&gt; .local-video { transform: scaleX(-1); } &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div class=\"container\"&gt; &lt;video muted=\"true\" autoplay=\"true\" playsinline=\"true\" id=\"localVideo\" class=\"local-video\"&gt;&lt;/video&gt; &lt;div id=\"remoteVideos\"&gt;&lt;/div&gt; &lt;div class=\"btn-group\"&gt; &lt;button type=\"button\" id=\"enter\"&gt;enter&lt;/button&gt; &lt;button type=\"button\" id=\"leave\"&gt;leave&lt;/button&gt; &lt;/div&gt; &lt;/div&gt; &lt;script src=\"https://webrtc.github.io/adapter/adapter-latest.js\"&gt;&lt;/script&gt; &lt;script src=\"https://cdn.jsdelivr.net/npm/socket.io-client@3.0.4/dist/socket.io.js\"&gt;&lt;/script&gt; &lt;script src=\"chat.js\" type=\"module\" async&gt;&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; Javascript（chat.js）步驟拆分 開啟視窗時，先透過 getUserMedia() 取得本地媒體串流 點擊進入聊天室按鈕：連接 Socket Server（Signaling Server），透過 Offer／Answer SDP 和遠端裝置交換 ICE 候選位址與 SDP 資訊，建立點對點連線 點擊離開聊天室按鈕：移除事件監聽、關閉 RTCPeerConnection 連線、釋放記憶體，並傳送離開事件給 Socket Server 定義常數與變數const localVideo = document.querySelector('#localVideo')const remoteVideos = document.querySelector('#remoteVideos')const enterBtn = document.querySelector('#enter');const leaveBtn = document.querySelector('#leave'); let peerConnectionList = {};let socket;let localStream;const room = 'room1'; // 房間先預設為 room1 開啟視窗時，先透過 getUserMedia 取得本地媒體串流 取得本地影音串流 Dom 設置本地串流 傳出媒體串流 const createStream = async () =&gt; { const constraints = { audio: true, video: true }; // 1. 取得本地影音串流 const stream = await navigator.mediaDevices.getUserMedia(constraints); // 2. Dom 設置本地媒體串流 localVideo.srcObject = stream; // 3. 傳出媒體串流 localStream = stream;}createStream(); // 畫面一開啟即呼叫 點擊進入聊天室按鈕事件觸發enterBtn.addEventListener('click', socketConnect); 連接 Socket Server（Signaling Server），透過 Offer／Answer SDP 和遠端裝置交換 ICE 候選位址與 SDP 資訊，建立點對點連線 Socket Server 連線 加入房間 監聽有裝置加入房間：如果是自己，建立 RTCPeerConnection，設定本地 SDP（setLocalDescription），並發送 Offer SDP 監聽收到 Offer SDP：建立 RTCPeerConnection，，設定遠端 SDP（setRemoteDescription）與本地 SDP（setLocalDescription），並發送 Answer SDP 監聽收到 Answer SDP：設定遠端 SDP（setRemoteDescription） 監聽收到 ICE 候選位址：使用 RTCIceCandidate 定義 ICE 候選位址 const socketConnect = () =&gt; { // 1. Socket Server 連線 socket = io('ws://localhost:3000'); // 2. 加入房間 socket.emit('join', room); // 3. 監聽有裝置加入房間 socket.on('joined', (id, roomMembers) =&gt; { // 檢查 server 傳來的 socket.id 是否等於自己的 socket.id // 且聊天室裝置大於一，依序發送 Offer SDP if (id === socket.id &amp;&amp; roomMembers.length &gt; 1) { console.log('發送 offer'); // 3-1. 發送 Offer SDP roomMembers.forEach(remoteId =&gt; { if (remoteId !== socket.id) { setOfferSDP(remoteId); } }); } }); // 4. 監聽收到 Offer SDP socket.on('offer', async (desc, remoteId) =&gt; { console.log('收到 offer'); // 4-1. 發送 Answer SDP console.log('發送 answer'); await sendAnswerSDP(remoteId, desc); }) // 5. 監聽收到 Answer SDP socket.on('answer', (desc, remoteId) =&gt; { console.log('收到 answer'); // 設定遠端媒體串流 peerConnectionList[remoteId].setRemoteDescription(desc); }) // 6. 監聽收到 ICE 候選位址 socket.on('ice_candidate', (data, remoteId) =&gt; { console.log('收到 ice_candidate'); // RTCIceCandidate 定義 ICE 候選位址 const candidate = new RTCIceCandidate({ sdpMLineIndex: data.label, candidate: data.candidate, }); // 加入候選位址 peerConnectionList[remoteId].addIceCandidate(candidate); })} 3-1. 發送 Offer SDP 建立 RTCPeerConnection 建立本地 SDP 設定本地 SDP 發送 Offer SDP const setOfferSDP = async (remoteId) =&gt; { // 1. 建立 RTCPeerConnection const peerConnection = await createPeerConnection(remoteId); const offerOptions = { offerToReceiveAudio: true, // 是否傳送聲音流給對方 offerToReceiveVideo: true // 是否傳送影像流給對方 }; // 2. 建立本地 SDP const localSDP = await peerConnection.createOffer(offerOptions); // 3. 設定本地 SDP await peerConnection.setLocalDescription(localSDP); // 4. 發送 Offer SDP socket.emit('offer', room, peerConnection.localDescription, socket.id, remoteId);} 4-1. 發送 Answer SDP 建立 RTCPeerConnection 設定遠端 SDP 建立本地 SDP 設定本地 SDP 發送 Answer SDP const sendAnswerSDP = async (remoteId, desc) =&gt; { // 1. 建立 RTCPeerConnection const peerConnection = await createPeerConnection(remoteId); // 2. 設定遠端 SDP await peerConnection.setRemoteDescription(desc); const answerOptions = { offerToReceiveAudio: true, // 是否傳送聲音流給對方 offerToReceiveVideo: true // 是否傳送影像流給對方 }; // 3. 建立本地 SDP const localSDP = await peerConnection.createAnswer(answerOptions); // 4. 設定本地 SDP await peerConnection.setLocalDescription(localSDP); // 5. 發送 Answer SDP socket.emit('answer', room, peerConnection.localDescription, socket.id, remoteId);} 3-1. 4-1. 建立 RTCPeerConnection 設定 iceServer 建立 RTCPeerConnection 增加本地媒體串流 監聽找到本地的 ICE 候選位址 監聽 ICE 連接狀態 監聽遠端裝置的串流傳入 video 標籤屬性：playsinline：控制影片在行動裝置的播放行為，避免某些裝置（如 IOS）彈出視窗播放器controls：是否顯示播放控制器，在某些裝置（如 IOS Safari）設定為 false 畫面可能會被隱藏，可以先將屬性設為 true，接著移除該屬性：video.setAttribute('controls', true)video.removeAttribute('controls') 將 P2P 連線存入 peerConnectionList const createPeerConnection = async (remoteId) =&gt; { // 1. 設定 iceServer const configuration = { iceServers: [{ urls: 'stun:stun.l.google.com:19302' // google 提供免費的 STUN server }] }; // 2. 建立 RTCPeerConnection const peerConnection = new RTCPeerConnection(configuration); // 3. 增加本地媒體串流 localStream.getTracks().forEach((track) =&gt; { peerConnection.addTrack(track, localStream); }); // 4. 監聽找到本地的 ICE 候選位址 peerConnection.onicecandidate = (e) =&gt; { console.log('找尋到 ICE 候選位址'); if (e.candidate) { console.log('發送 ICE 候選位址'); // 傳送 ICE 候選位址給遠端 socket.emit('ice_candidate', room, { label: e.candidate.sdpMLineIndex, id: e.candidate.sdpMid, candidate: e.candidate.candidate, }, socket.id, remoteId); } }; // 5. 監聽 ICE 連接狀態 peerConnection.oniceconnectionstatechange = (e) =&gt; { if (e.target.iceConnectionState === 'disconnected') { console.log('有裝置斷線'); // 移除事件監聽 peerConnectionList[remoteId].onicecandidate = null; peerConnectionList[remoteId].onnegotiationneeded = null; peerConnectionList[remoteId].oniceconnectionstatechange = null; // 關閉 RTCPeerConnection 連線並釋放記憶體 peerConnectionList[remoteId].close(); delete peerConnectionList[remoteId]; // 移除遠端 video document.getElementById(remoteId).remove(); } }; // 6. 監聽遠端裝置的串流傳入 peerConnection.onaddstream = ({ stream }) =&gt; { console.log('監聽到串流'); const video = document.createElement('video'); video.srcObject = stream; video.setAttribute('controls', true); video.setAttribute('playsinline', true); video.setAttribute('autoplay', true); video.setAttribute('muted', true); video.setAttribute('volume', 0); video.removeAttribute('controls'); video.classList.add('remote-video'); video.id = remoteId; remoteVideos.append(video); }; // 7. 將 P2P 連線存入 peerConnectionList peerConnectionList[remoteId] = peerConnection; return peerConnection;} 點擊離開聊天室按鈕事件觸發leaveBtn.addEventListener('click', leave); 離開聊天室 移除事件監聽 關閉 RTCPeerConnection 連線 釋放記憶體 移除遠端 video 傳遞離開聊天室事件給 Socket Server const leave = () =&gt; { console.log('離開聊天室'); // 檢查是否有連線 if (Object.keys(peerConnectionList).length) { Object.keys(peerConnectionList).forEach(key =&gt; { // 1. 移除事件監聽 peerConnectionList[key].onicecandidate = null; peerConnectionList[key].onnegotiationneeded = null; peerConnectionList[key].oniceconnectionstatechange = null; // 2. 關閉 RTCPeerConnection 連線 peerConnectionList[key].close(); }) // 3. 釋放記憶體 peerConnectionList = {}; // 4. 移除遠端 video remoteVideos.innerHTML = null; } // 5. 傳遞離開聊天室事件 socket.emit('disconnect_socket'); socket = null;} 這樣就大功告成囉，上述說明有試著簡化程式碼，避免細節繁瑣難以理解 試著優化看看： 1. enter button 跟 leave button 加入 disabled 屬性，避免重複操作 2. 將 socket.id 做為識別碼，加入聊天視窗（也更容易除錯！） 3. 不同裝置的螢幕寬高比不同，利用 css 優化，避免畫面破版 4. async function 加入 try / catch 捕捉錯誤情境 範例頁面：https://webrtc-socket.herokuapp.com/chat 參考資源： https://github.com/muaz-khan/RTCMultiConnection/blob/master/dist/RTCMultiConnection.js https://iter01.com/489722.html https://socket.io/docs/v3/rooms/","link":"/2023/05/10/webrtc/webrtc-group-chat/"},{"title":"WebRTC 學習筆記 (1) 基本觀念與流程","text":"WebRTC（Web Real-Time Communication）是一種用於瀏覽器之間進行即時通訊的技術。讓用戶可以透過瀏覽器建立視訊、音訊和資料傳輸的連線，並實現 P2P 點對點通訊，而無須透過中介服務。 WebRTC 如何達成連線？WebRTC 即時通訊是透過 P2P（Peer-to-Peer）連線來達成，不過 P2P 連線並沒有這麼簡單，因大部分裝置處於區域網路中，通常是透過 NAT（Network Address Translation）將內部網路 IP 轉換成外部網路 IP 來達成連線，也就是說並沒有直接開放的通訊路徑（無法直接連到內網 IP），因此需要： 先透過 ICE 框架來找到共同的連線路徑，並用 Signaling Server 交換資訊（上圖步驟 ①②③④） 透過 P2P 達成即時通訊（上圖步驟 ⑤） 為什麼要使用 P2P 連線？ICE 框架是什麼？Signaling Server又是什麼？P2P 連線如何進行視訊通話？ 看完了 WebRTC 的概念還是充滿問號？？？接下來依序說明～ P2P（Peer-to-Peer）Connection 點對點連線P2P 指的是兩個瀏覽器直接建立點對點連接，不需透過伺服器中轉，可以達到即時影音串流。WebRTC 內的 P2P 連線由 WebRTC API 達成，先透過 RTCPeerConnection() 建立實體，來進行本地跟遠端的溝通。 WebRTC APIConstructor 建構式：• RTCPeerConnection()：建立物件實體，用來處理本地跟遠端點對點連線Event Handler 事件處理器：• icecandidate：找尋到 ICE 候選位置• iceconnectionstatechange：ICE 連線狀態改變• addstream：新增串流Methods：• addTrack：增加視訊、音訊，以傳輸到另一端• createOffer：建立 Offer SDP• createAnswer：建立 Answer SDP• setLocalDescription：設定本地 SDP 資訊• setRemoteDescription：設定遠端（對方）SDP 資訊• addIceCandidate：新增 ICE 候選位址 ICE 框架（Interactive Connectivity Establishment）用於在網路中穿透 NAT 的技術框架，ICE 整合了 STUN 與 TURN 協定，用於確定兩個設備之間最佳的通訊路徑，進而達成端點間連線。 NAT（Network Address Translation）網路位置轉譯用來將私有 IP 轉換（映射）為公有 IP，由於 NAT 不允許外網主機直接訪問內網，因此會造成 P2P 直接連線的困難，NAT 跟防火牆詳細說明可以參考 這篇文章 STUN（Session Traversal Utilities for NAT）協定用來穿越 NAT 的一種協議，協助在 NAT 內的使用者找到自己的公網 IP和 Port，並將資訊傳給其他使用者，讓雙方瞭解彼此的資訊，繞過 NAT 限制，達成 P2P 連線，不過在 Symmetric NAT 不可穿透的情況下則不適用 TURN（Traversal Using Relay NAT）協定穿越 NAT 的另一種協議，使用「中繼」的方式來進行，當 STUN 的候選位址都無法連線時，將資料透過中間伺服器傳輸 ICE 建立連線流程 先嘗試用本地網路 IP 直接連線 如果失敗，再使用 STUN 協定穿透 NAT 建立連線 如果失敗，最後才使用 TURN 協定將資料透過中繼伺服器傳輸 Signaling Server 信號伺服器WebRTC 通訊時雖然不需透過伺服器中轉，使用 P2P 達到即時影音串流，但在此之前還是需要先透過伺服器來進行媒體串流和 ICE 候選位址協調，以確定通訊的對方和方式，這個伺服器就稱為 Signaling Server。 WebRTC 沒有特別規範 Signaling Server，常用的服務為 WebSocket 或是 HTTP 伺服器。 Signaling Server 建立流程 透過 WebSocket 或是 HTTP 伺服器建立連線 發送端與接收端分別使用 SDP（Session Description Protocol）offer-answer 模型描述媒體串流訊息，傳遞給 Signaling Server，Signaling Server 再傳遞給對方 發送端與接收端分別將其收集到的本地網路位址和 ICE 候選位址通知 Signaling Server，Signaling Server 再將訊息傳遞給對方 控制訊息（通話開始、暫停、結束等）與數據傳輸（聊天訊息、檔案） SDP（Session Description Protocol）協定用於描述多媒體會話的格式化文字協定，像是會議的參與者、媒體類型、媒體流的傳輸協定、編碼方式、解碼方式、封包大小等訊息。也可以包含其他相關訊息，例如時區、媒體串流的 port 號、會話持續時間等。SDP offer-answer 模型中，發送端會建立一個 SDP offer，並向接收端傳送該 SDP offer。接收端收到 SDP offer 後，會建立 SDP answer 並回傳給發送端，交換 SDP 的過程，被稱為媒體協商 P2P 連線如何進行視訊通話？P2P 連線成功後，需透過 MediaDevice API 裡的 getUserMedia() 取得本地媒體串流，媒體串流為包含視訊、音訊和資料的數據串流，WebRTC 使用多種技術來達成媒體串流傳輸，包括即時傳輸協定（RTP）和即時傳輸控制協定（RTCP）等，並使用前面提到的 WebRTC API 來達成 P2P 連線與資料傳遞。 試著使用 getUserMedia 在瀏覽器輸出影音呼叫 getUserMedia() 取得使用者的音訊和視訊，會回傳一個 Promise 物件，constraints 用來設定擷取條件（影像或聲音，至少要有一項為 true），以下範例會在瀏覽器上輸出本地端影音： &lt;video id=\"video\" autoplay&gt;&lt;/video&gt; const constraints = { audio: true, video: true};const video = document.querySelector(\"#video\");const createStream = async () =&gt; { try { const stream = await navigator.mediaDevices.getUserMedia(constraints); video.srcObject = stream; } catch (err) { throw err; }} 視訊影像是顛倒的，我們可以透過 CSS 設定反轉 #video { transform: scaleX(-1);} WebRTC 一對一視訊流程解析視訊情境裝置 A 開啟了一個聊天室，接著裝置 B 連接該聊天室進行視訊聊天 圖片參考：MDN 流程解析（搭配 STUN 協定） 裝置 A 透過 STUN server 取得本地私有 IP 以及公有 IP 裝置 B 透過 STUN server 取得本地私有 IP 以及公有 IP 裝置 A 發送 offer SDP，並設定為本地 SDP 裝置 B 收到 offer SDP，並設定為遠端 SDP 裝置 B 發送 answer SDP，並設定為本地 SDP 裝置 A 收到 answer SDP，並設定為遠端 SDP 裝置 A 傳送 ICE 候選位址 裝置 B 寫入裝置 A ICE 候選位址 裝置 B 傳送 ICE 候選位址 裝置 A 寫入裝置 B ICE 候選位址 P2P 連線建立，進行即時媒體串流（音訊、視訊） WebRTC 基本觀念說明就到這，下一篇將會進行實作，一起完成一對一視訊聊天室吧！ 參考文章： https://www.wowza.com/blog/webrtc-signaling-servers https://ithelp.ithome.com.tw/articles/10209725 https://ithelp.ithome.com.tw/articles/10284640 https://ithelp.ithome.com.tw/articles/10266739","link":"/2023/04/25/webrtc/webrtc-intro/"},{"title":"WebRTC 學習筆記 (2) 實作一對一視訊聊天室","text":"上一篇 說明了完成聊天室必備的基礎觀念，接著就來進行實作吧！ 視訊情境裝置 A 開啟了一個聊天室，接著裝置 B 連接該聊天室進行視訊聊天 圖片參考：MDN 流程解析（搭配 STUN 協定） 裝置 A 透過 STUN server 取得本地私有 IP 以及公有 IP 裝置 B 透過 STUN server 取得本地私有 IP 以及公有 IP 裝置 A 發送 offer SDP，並設定為本地 SDP 裝置 B 收到 offer SDP，並設定為遠端 SDP 裝置 B 發送 answer SDP，並設定為本地 SDP 裝置 A 收到 answer SDP，並設定為遠端 SDP 裝置 A 傳送 ICE 候選位址 裝置 B 寫入裝置 A ICE 候選位址 裝置 B 傳送 ICE 候選位址 裝置 A 寫入裝置 B ICE 候選位址 P2P 連線建立，進行即時媒體串流（音訊、視訊） 視訊實作 實作分為 Server（Signaling Server）以及 Client（視訊聊天室）進行 檔案結構如下： server.jschat.htmlchat.js Server（server.js）套件安裝（NPM） Node.js 框架 Express Websocket 套件 Socket.io 套件引入const express = require('express');const app = express();const http = require('http');const socket = require('socket.io'); 啟動伺服器port 設定 3000，因此伺服器連線網址為 http://localhost:3000 const server = http.createServer(app).listen('3000'); 連接 Client 頁面（轉換為絕對路徑 __dirname）// html 路徑轉換app.get('/chat', function(req, res) { es.sendfile(`${__dirname}/chat.html`);});// js 路徑轉換app.get(/(.*)\\.(jpg|gif|png|ico|css|js|txt)/i, function(req, res) { console.log(__dirname); res.sendfile(`${__dirname}/${req.params[0]}.${req.params[1]}`);}); 加入 Socket.io socket.on() 監聽 join, offer, answer, ice_candidate, hangup 等 Client 自訂事件 socket.emit() 傳遞事件給 Client const io = socket(server);io.on('connection', (socket) =&gt; { console.log('connection'); // 加入房間 socket.on('join', (room) =&gt; { console.log('join'); socket.join(room); socket.to(room).emit('ready', '準備通話'); }); // 轉傳 Offer socket.on('offer', (room, description) =&gt; { socket.to(room).emit('offer', description); }); // 轉傳 Answer socket.on('answer', (room, desc) =&gt; { socket.to(room).emit('answer', description); }); // 交換 ice candidate socket.on('ice_candidate', (room, data) =&gt; { socket.to(room).emit('ice_candidate', data); }); // 關閉通話 socket.on('hangup', (room) =&gt; { console.log('hangup'); socket.leave(room); });}); Client（視訊聊天室）套件安裝（CDN） WebRTC Adapter（解決相容性問題） Socket.io-client HTML（chat.html） 加入 Video Dom #localVideo 接收本地媒體串流 #remoteVideo 接收遠端媒體串流 CDN WebRTC Adapter 以及 Socket.io-client 引入 chat.js &lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;meta charset=\"utf-8\"&gt; &lt;meta name=\"viewport\" content=\"width=device-width, user-scalable=yes, initial-scale=1, maximum-scale=1\"&gt; &lt;title&gt;chat&lt;/title&gt; &lt;style lang=\"scss\"&gt; video { transform: scaleX(-1); } &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div&gt; &lt;video muted=\"false\" width=\"320\" autoplay playsinline id=\"localVideo\"&gt;&lt;/video&gt; &lt;video width=\"320\" autoplay playsinline id=\"remoteVideo\"&gt;&lt;/video&gt; &lt;button type=\"button\" id=\"call\"&gt;call&lt;/button&gt; &lt;button type=\"button\" id=\"hangup\"&gt;hangup&lt;/button&gt; &lt;/div&gt; &lt;script src=\"https://webrtc.github.io/adapter/adapter-latest.js\"&gt;&lt;/script&gt; &lt;script src=\"https://cdn.jsdelivr.net/npm/socket.io-client@3.0.4/dist/socket.io.js\"&gt;&lt;/script&gt; &lt;script src=\"chat.js\" type=\"module\" async&gt;&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; Javascript（chat.js）任務步驟拆分 連接 Socket Server（Signaling Server）透過 Socket 監聽 Offer SDP、Answer SDP、ICE Candidate getUserMedia 取得本地媒體串流 RTCPeerConnection 建立 P2P 連線，與 RTCPeerConnection 事件監聽 定義常數與變數const localVideo = document.querySelector('#localVideo');const remoteVideo = document.querySelector('#remoteVideo');const callBtn = document.querySelector('#call');const hangupBtn = document.querySelector('#hangup');let peerConnection;let socket;let localStream;const room = 'room1'; // 房間先預設為 room1 連接 Socket Server（Signaling Server）透過 Socket 監聽 Offer SDP、Answer SDP、ICE Candidate socket.emit() 以及 socket.on() 傳遞與接收資料給 Server const socketConnect = () =&gt; { // 伺服器連線網址：http://localhost:3000 socket = io('ws://localhost:3000'); // 發送房間資訊 socket.emit('join', room); // 監聽加入房間 socket.on('ready', (msg) =&gt; { // 發送 Offer SDP sendSDP('offer'); }); // 監聽收到 Offer socket.on('offer', async (desc) =&gt; { // 設定對方的媒體串流 await peerConnection.setRemoteDescription(desc); // 發送 Answer SDP await sendSDP('answer'); }); // 監聽收到 Answer socket.on('answer', (desc) =&gt; { // 設定對方的媒體串流 peerConnection.setRemoteDescription(desc) }); // 監聽收到 ICE 候選位址 socket.on('ice_candidate', (data) =&gt; { // RTCIceCandidate 用以定義 ICE 候選位址 const candidate = new RTCIceCandidate({ sdpMLineIndex: data.label, candidate: data.candidate }); // 加入 ICE 候選位址 peerConnection.addIceCandidate(candidate); });}; 處理 Offer SDP / Answer SDP /** * @param {String} type offer/answer */const sendSDP = async (type) =&gt; { try { if (!peerConnection) { console.log('尚未開啟視訊'); return; } const method = type === 'offer' ? 'createOffer' : 'createAnswer'; const offerOptions = { offerToReceiveAudio: true, // 是否傳送聲音流給對方 offerToReceiveVideo: true // 是否傳送影像流給對方 }; // 建立 SDP const localSDP = await peerConnection[method](offerOptions); // 設定本地 SDP await peerConnection.setLocalDescription(localSDP); // 發送 SDP socket.emit(type, room, peerConnection.localDescription); } catch (err) { console.log('error: ', err); }}; getUserMedia 取得本地媒體串流const createStream = async () =&gt; { try { const constraints = { audio: true, video: true }; // getUserMedia 取得本地影音串流 const stream = await navigator.mediaDevices.getUserMedia(constraints); // Dom 設置本地媒體串流 localVideo.srcObject = stream; // 傳出媒體串流 localStream = stream; } catch (err) { console.log('getUserMedia error: ', err.message, err.name); }}; RTCPeerConnection 建立 P2P 連線，與 RTCPeerConnection 事件監聽 RTCPeerConnection 內的 iceServers 用來建立兩台裝置點對點連線的伺服器 getTracks()：取得媒體串流（MediaStream）中媒體軌道（MediaStreamTrack）陣列 addTrack(MediaStreamTrack, MediaStream)：增加媒體軌道（MediaStreamTrack）到 RTCPeerConnection 中指定的媒體串流（MediaStream） const createPeerConnection = () =&gt; { // 設定 iceServer const configuration = { iceServers: [{ urls: 'stun:stun.l.google.com:19302' // google 提供免費的 STUN server }] }; // 建立 RTCPeerConnection peerConnection = new RTCPeerConnection(configuration); // 增加本地串流 localStream.getTracks().forEach((track) =&gt; { peerConnection.addTrack(track, localStream); }); // 找尋到 ICE 候選位址後，送去 Server 與另一位配對 peerConnection.onicecandidate = (e) =&gt; { if (e.candidate) { // 發送 ICE socket.emit('ice_candidate', room, { label: e.candidate.sdpMLineIndex, id: e.candidate.sdpMid, candidate: e.candidate.candidate, }); } }; // 監聽 ICE 連接狀態 peerConnection.oniceconnectionstatechange = (e) =&gt; { // 若連接已斷，執行掛斷相關動作 if (e.target.iceConnectionState === 'disconnected') { hangup(); } }; // 監聽是否有媒體串流傳入 peerConnection.onaddstream = ({ stream }) =&gt; { // Dom 加入遠端串流 remoteVideo.srcObject = stream; };}; 點擊按鈕開始連線／關閉連線// 建立本地媒體串流createStream();// 開始連線const call = () =&gt; { socketConnect(); // socket 連線 createPeerConnection(); // 建立 P2P 連線};// 關閉連線const hangup = () =&gt; { // 移除事件監聽 peerConnection.onicecandidate = null; peerConnection.onnegotiationneeded = null; // 關閉 RTCPeerConnection 連線並釋放記憶體 peerConnection.close(); peerConnection = null; // 傳遞掛斷事件給 Server socket.emit('hangup', room); socket = null; // 移除遠端 video src remoteVideo.srcObject = null; // 移除遠端媒體串流};callBtn.addEventListener('click', call);hangupBtn.addEventListener('click', hangup); 這樣一對一聊天室就完成囉，後續會說明如何達成多方視訊功能 參考文章： https://ithelp.ithome.com.tw/articles/10251454 https://ithelp.ithome.com.tw/articles/10209193 https://ithelp.ithome.com.tw/articles/10278727 https://medium.com/@jedy05097952/初探-webrtc-手把手建立線上視訊-1-5e9d4702e8e8","link":"/2023/05/02/webrtc/webrtc-video-chat/"}],"tags":[{"name":"css","slug":"css","link":"/tags/css/"},{"name":"masonry","slug":"masonry","link":"/tags/masonry/"},{"name":"javascript","slug":"javascript","link":"/tags/javascript/"},{"name":"three.js","slug":"three-js","link":"/tags/three-js/"},{"name":"node","slug":"node","link":"/tags/node/"},{"name":"nuxt2","slug":"nuxt2","link":"/tags/nuxt2/"},{"name":"axios","slug":"axios","link":"/tags/axios/"},{"name":"bootstrap","slug":"bootstrap","link":"/tags/bootstrap/"},{"name":"ckeditor","slug":"ckeditor","link":"/tags/ckeditor/"},{"name":"seo","slug":"seo","link":"/tags/seo/"},{"name":"gtag","slug":"gtag","link":"/tags/gtag/"},{"name":"sitemap","slug":"sitemap","link":"/tags/sitemap/"},{"name":"swiper","slug":"swiper","link":"/tags/swiper/"},{"name":"vee-validate","slug":"vee-validate","link":"/tags/vee-validate/"},{"name":"nuxt3","slug":"nuxt3","link":"/tags/nuxt3/"},{"name":"firebase","slug":"firebase","link":"/tags/firebase/"},{"name":"node.js","slug":"node-js","link":"/tags/node-js/"},{"name":"mongodb","slug":"mongodb","link":"/tags/mongodb/"},{"name":"nuxt","slug":"nuxt","link":"/tags/nuxt/"},{"name":"typescript","slug":"typescript","link":"/tags/typescript/"},{"name":"vue3","slug":"vue3","link":"/tags/vue3/"},{"name":"dns","slug":"dns","link":"/tags/dns/"},{"name":"github","slug":"github","link":"/tags/github/"},{"name":"webrtc","slug":"webrtc","link":"/tags/webrtc/"}],"categories":[{"name":"CSS","slug":"CSS","link":"/categories/CSS/"},{"name":"Javascript","slug":"Javascript","link":"/categories/Javascript/"},{"name":"Node","slug":"Node","link":"/categories/Node/"},{"name":"Nuxt","slug":"Nuxt","link":"/categories/Nuxt/"},{"name":"Nuxt3","slug":"Nuxt3","link":"/categories/Nuxt3/"},{"name":"Typescript","slug":"Typescript","link":"/categories/Typescript/"},{"name":"Vue","slug":"Vue","link":"/categories/Vue/"},{"name":"Web","slug":"Web","link":"/categories/Web/"},{"name":"WebRTC","slug":"WebRTC","link":"/categories/WebRTC/"}]}